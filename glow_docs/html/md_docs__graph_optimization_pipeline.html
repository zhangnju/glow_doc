<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: Glow Graph Optimization Pipeline</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Glow Graph Optimization Pipeline </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes the optimization pipeline and how to configure it for varying precision configurations. Note that the terms "Graph" and "Function" are often used interchangably.</p>
<h3>Graph (Function) Optimization Stages and Order</h3>
<p><code><a class="el" href="namespaceglow.html#af6b48e8310d02c29962b5469885b3a75">glow::optimizeFunction()</a></code> is used to drive the optimization pipeline of a Function. Inside <code>optimizeFunction()</code>, a Function is optimized by the following optimization stages in order:</p>
<ul>
<li><code>fold()</code></li>
<li><code>optimize()</code></li>
<li><code>lower()</code></li>
<li><code>transformForPrecisionMode()</code></li>
<li><code>optimize()</code></li>
<li><code>Backend::transformPostLowering()</code></li>
<li><code>optimize()</code></li>
<li><code>checkAllNodesSupported()</code></li>
</ul>
<p>Note that optimize is called many times, usually after every other stage. This is because the other stages may add or change the graph in some ways that allow for previously inapplicable optimizations to now occur, or new nodes may be able to take advantage of the optimizations.</p>
<h3>Descriptions of Optimization Stages</h3>
<ul>
<li><code><a class="el" href="namespaceglow.html#a1af90308823b5fb36b860a8a73aaa923" title="Fold nodes that were expressed lowered in the input model. ">glow::fold()</a></code>: Fold low-level Nodes into higher-level Nodes. This is useful when compiling an input model where some high-level operators have been lowered (this can be for instance a side effect of model converters, like converters from Tensorflow to ONNX). In this situation, such folding can then enable more optimizations and also improve the performance of backends that support natively such high-level operators. Folding is done first, as we want to raise the graph to a higher level in order to take advantage of high-level optimizations and allow for backends to prevent lowering on them as well if desired.</li>
<li><code><a class="el" href="namespaceglow.html#a0069e8261c2e2ddf94d4697de80150ad">glow::lower()</a></code>: Lowers high-level Nodes into lower-level Nodes. This allows backends to be agnostic to higher-level representations of Nodes. For example, a backend may support an LSTM if it supports all of the sub-nodes found inside an LSTM. However, it does not need to be responsible for understanding that it supports an LSTM. This future-proofs the backend, allowing it to support future high-level complex nodes without understanding their higher-level semantics. Note that <a href="Backends.md#backend-abstract-class">Backends can prevent lowering</a> if preferred via <code>Backend::shouldLower()</code>.</li>
<li><code>transformForPrecisionMode()</code>: Transforms the graph depending on requested precision configuration. There are a few different options here:<ul>
<li><code>Profile</code>: Add special profiling nodes to the graph to gather a histogram of values flowing through each Node in the graph. This can then be used to automatically quantize the graph.</li>
<li><code>Quantize</code>: Quantize the graph, given a previously gathered profile as mentioned above. This converts all Float inputs and outputs of each Node if the backend supports the node as quantized.</li>
<li><code>ConvertToFP16</code>: Convert all Float inputs and outputs of Nodes to Float16. Note that this does not require any sort of profile. It can also be performed alongside Quantization to get a mixed precision graph.</li>
</ul>
</li>
<li><code>Backend::transformPostLowering()</code>: Allow the Backend to transform the graph. This includes swapping in its own backend-specific nodes. More info can be found <a href="Backends.md#backend-abstract-class">here</a> and <a href="NewBackendSpecificNode.md#steps">here</a>.</li>
<li><code><a class="el" href="namespaceglow.html#a902cda054ebe738e9395e218ae09f291" title="Perform optimizations on the graph representation. ">glow::optimize()</a></code>: Performs a series of graph optimizations, as listed <a href="Optimizations.md#set-of-supported-graph-optimizations">here</a>. Many of these are common compiler optimizations, such as DCE and CSE. Others are more ML and linear algebra related, such as fusing BatchNormalization into Convolutions in inference mode, or combining a series of Transpose operations into a single Transpose.</li>
<li><code>checkAllNodesSupported()</code>: Given some Backend that we are optimizing the Graph for, this verifies that the backend supports each of the nodes after the entire optimization pipeline is complete, via <a href="Backends.md#backend-abstract-class">Backend::isOpSupported()</a>. If any node is not supported it will return an error, which <code>optimizeFunction()</code> will then return up the stack.</li>
</ul>
<h2>How to call <code><a class="el" href="namespaceglow.html#af6b48e8310d02c29962b5469885b3a75">glow::optimizeFunction()</a></code></h2>
<p>Here we describe the API for <code><a class="el" href="namespaceglow.html#af6b48e8310d02c29962b5469885b3a75">glow::optimizeFunction()</a></code> and how to use it in different modes.</p>
<div class="fragment"><div class="line">Error glow::optimizeFunction(Function *F, const Backend &amp;B,</div><div class="line">                                   CompilationContext &amp;cctx);</div></div><!-- fragment --><p>An error is returned if something goes wrong during the optimization pipeline, for example if a Node is no longer supported by the backend after optimizations, or if the CompilationContext is not set up correctly.</p>
<ul>
<li><code>F</code>: The Function (graph) to optimize. It will be transformed; if the caller would like to keep an original copy of the Function it is responsible for cloning it before calling <code>optimizeFunction()</code>.</li>
<li><code>B</code>: The Backend for which we are optimizing <code>F</code>. It is able to control what is lowered (<code>Backend::shouldLower()</code>), to specify what should be quantized (<code>Backend::isOpSupported()</code>); and to transform the graph however it wishes (<code>Backend::transformPostLowering()</code>).</li>
<li><code>cctx</code>: The CompilationContext, containing important data structures to keep some state before/after compilation is complete, as well as configuration information for what kinds of transformations to perform.<ul>
<li><code>PlaceholderBindings *bindings</code>: Mapping between Placeholders and Tensors for this compilation run. For example, this is used when instrumenting a Function for quantizaiton profiling, to create Placeholders and their Tensors for inserted <code>QuantizationProfileNodes</code>.</li>
<li><code>LoweredInfoMap *loweredInfoMap</code>: Mapping from each Node output name in a Function (corresponding to unique NodeValues in a Function), to a set of <code>NodeNameAndKind</code> (which is a pair of Node output name and Kind). This is used to keep track of what Nodes are lowered into what other Nodes, for use during Profiling and Quantization.</li>
<li><code>enum class CompilationMode compMode</code>: This is set to either <code>Train</code> or <code>Infer</code>, depending on what the Function is being used for. Some optimizations may only be performed during one of these modes.</li>
<li><code>struct BackendOptions backendOpts</code>: Different options for compilation after graph optimizations have been completed. <a href="Backends.md#backendoptions-helper-struct">See here</a> for more info.</li>
<li><code>struct PrecisionConfiguration precisionConfig</code>: Configuration for different precision modes, used during <code>transformForPrecisionMode()</code>. Contains the following:<ul>
<li><code>enum class QuantizationMode quantMode</code>: One of <code>None</code>, <code>Quantize</code>, or <code>Profile</code>, as previously mentioned above.</li>
<li><code>quantization::QuantizationConfiguration quantConfig</code>: Configuration for quantization, including the quantizaion precision <code>ElemKind</code> (e.g. <code>Int8QTy</code>, <code>Int16QTy</code>, etc.), <a href="Quantization.md#how-to-perform-nn-conversion">schema</a> (e.g. Asymmetric, Symmetric, etc.), whether to use rowwise quantization, etc.</li>
<li><code>bool convertToFP16</code>: Whether to convert all found <code>FloatTy</code> to <code>Float16Ty</code> in the Function. This is performed after Quantization, and so can be used together to get a mixed precision model.</li>
<li><code>KindSet precisionModeKindSet</code>: A set of node kinds. This has different uses depending on the precision mode. If in profiling mode, this represents node kinds that should not be lowered (<a href="Quantization.md#how-to-perform-nn-conversion">mentioned here</a>). If performing quantization or FP16 conversion this represents node kinds that should not be converted, and should instead be left in FloatTy. </li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
