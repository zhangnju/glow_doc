<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow::ProtobufLoader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglow.html">glow</a></li><li class="navelem"><a class="el" href="classglow_1_1_protobuf_loader.html">ProtobufLoader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classglow_1_1_protobuf_loader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">glow::ProtobufLoader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Loads model: graph and weights.  
 <a href="classglow_1_1_protobuf_loader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_protobuf_loader_8h_source.html">ProtobufLoader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for glow::ProtobufLoader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classglow_1_1_protobuf_loader.png" usemap="#glow::ProtobufLoader_map" alt=""/>
  <map id="glow::ProtobufLoader_map" name="glow::ProtobufLoader_map">
<area href="classglow_1_1_common_operator_loader.html" alt="glow::CommonOperatorLoader&lt; caffe2::OperatorDef, caffe2::Argument &gt;" shape="rect" coords="0,56,611,80"/>
<area href="classglow_1_1_common_operator_loader.html" alt="glow::CommonOperatorLoader&lt; ONNX_NAMESPACE::NodeProto, ONNX_NAMESPACE::AttributeProto &gt;" shape="rect" coords="621,56,1232,80"/>
<area href="classglow_1_1_common_operator_loader.html" alt="glow::CommonOperatorLoader&lt; OpType, AttrType &gt;" shape="rect" coords="1242,56,1853,80"/>
<area href="classglow_1_1_caffe2_model_loader.html" title="Loads caffe2 models. " alt="glow::Caffe2ModelLoader" shape="rect" coords="0,112,611,136"/>
<area href="classglow_1_1_o_n_n_x_model_loader.html" title="Loads ONNX models. " alt="glow::ONNXModelLoader" shape="rect" coords="621,112,1232,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe06768b43d8aa8398d8d4c0c9668540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#afe06768b43d8aa8398d8d4c0c9668540">getNodeValueByName</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:afe06768b43d8aa8398d8d4c0c9668540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50508e4cbe83b3cafd7d7319199c0fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a50508e4cbe83b3cafd7d7319199c0fb7">hasNodeByName</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:a50508e4cbe83b3cafd7d7319199c0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebda831dd716c8c1056f520783a062ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#aebda831dd716c8c1056f520783a062ac">ProtobufLoader</a> (llvm::ArrayRef&lt; const char *&gt; tensorNames, llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_type.html">TypeRef</a> &gt; types, <a class="el" href="classglow_1_1_function.html">Function</a> &amp;F, <a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> *errPtr=nullptr)</td></tr>
<tr class="separator:aebda831dd716c8c1056f520783a062ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f3f978f452dffff98a6dceed704240"><td class="memItemLeft" align="right" valign="top"><a id="a60f3f978f452dffff98a6dceed704240"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ProtobufLoader</b> (const <a class="el" href="classglow_1_1_protobuf_loader.html">ProtobufLoader</a> &amp;other)=delete</td></tr>
<tr class="separator:a60f3f978f452dffff98a6dceed704240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993f1998ae3c5443c5fd5d0905bc0a89"><td class="memItemLeft" align="right" valign="top"><a id="a993f1998ae3c5443c5fd5d0905bc0a89"></a>
<a class="el" href="classglow_1_1_protobuf_loader.html">ProtobufLoader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classglow_1_1_protobuf_loader.html">ProtobufLoader</a> &amp;)=delete</td></tr>
<tr class="separator:a993f1998ae3c5443c5fd5d0905bc0a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89514a172bff5eb02915725d26e315"><td class="memItemLeft" align="right" valign="top">const llvm::StringMap&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a7e89514a172bff5eb02915725d26e315">getOutputVarsMapping</a> () const</td></tr>
<tr class="separator:a7e89514a172bff5eb02915725d26e315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07756504a756acf83d49ef59ae1ff2f"><td class="memItemLeft" align="right" valign="top">const llvm::StringMap&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#ac07756504a756acf83d49ef59ae1ff2f">getInputVarsMapping</a> () const</td></tr>
<tr class="separator:ac07756504a756acf83d49ef59ae1ff2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d14ec2ce55c5fd11a96fe688435b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a84d14ec2ce55c5fd11a96fe688435b40">getSingleOutput</a> ()</td></tr>
<tr class="separator:a84d14ec2ce55c5fd11a96fe688435b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74cf67a8dae7eb8c6793aae25589c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#aa74cf67a8dae7eb8c6793aae25589c24">getOutputByName</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:aa74cf67a8dae7eb8c6793aae25589c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ed5b8175104dffe27f3f88b45ceede"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a60ed5b8175104dffe27f3f88b45ceede">isConstantFoldable</a> (llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs, std::string typeName) const</td></tr>
<tr class="separator:a60ed5b8175104dffe27f3f88b45ceede"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a119e008b20c497b020e7bc706021d04d"><td class="memItemLeft" align="right" valign="top"><a id="a119e008b20c497b020e7bc706021d04d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteUnusedConstants</b> ()</td></tr>
<tr class="separator:a119e008b20c497b020e7bc706021d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c3cd81547d30058fc6061e31353289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#ab6c3cd81547d30058fc6061e31353289">createAndRegisterConstant</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&amp;tensor)</td></tr>
<tr class="separator:ab6c3cd81547d30058fc6061e31353289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423b742fbe850b05ee21e3dd06276fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a423b742fbe850b05ee21e3dd06276fd2">createAndRegisterPlaceholder</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> T)</td></tr>
<tr class="separator:a423b742fbe850b05ee21e3dd06276fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac558da9000f7c4cf499e2b4862827e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#ac558da9000f7c4cf499e2b4862827e5c">getNodeValueByNameOrNullNodeValue</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:ac558da9000f7c4cf499e2b4862827e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a86c2a07a5c396cc6a9fd25de6a2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a85a86c2a07a5c396cc6a9fd25de6a2ae">getConstantByNameOrNull</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:a85a86c2a07a5c396cc6a9fd25de6a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622b34ab4bbe4cfc5bcc5b03af58c214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_constant.html">Constant</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#a622b34ab4bbe4cfc5bcc5b03af58c214">getConstantByName</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:a622b34ab4bbe4cfc5bcc5b03af58c214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb6af3498f15a1d84bc8800dda2a8e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#abcb6af3498f15a1d84bc8800dda2a8e2">hasConstantByName</a> (llvm::StringRef name) const</td></tr>
<tr class="separator:abcb6af3498f15a1d84bc8800dda2a8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac16d6a010eff091f2741bcd217330c20"><td class="memItemLeft" align="right" valign="top"><a id="ac16d6a010eff091f2741bcd217330c20"></a>
<a class="el" href="classglow_1_1_function.html">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#ac16d6a010eff091f2741bcd217330c20">G_</a></td></tr>
<tr class="memdesc:ac16d6a010eff091f2741bcd217330c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph that we are constructing. <br /></td></tr>
<tr class="separator:ac16d6a010eff091f2741bcd217330c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0537bf30bcdeb245f90d266bec80146"><td class="memItemLeft" align="right" valign="top"><a id="aa0537bf30bcdeb245f90d266bec80146"></a>
llvm::StringMap&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#aa0537bf30bcdeb245f90d266bec80146">nodeValueByName_</a></td></tr>
<tr class="memdesc:aa0537bf30bcdeb245f90d266bec80146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves network nodes by name. <br /></td></tr>
<tr class="separator:aa0537bf30bcdeb245f90d266bec80146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd798ac70c0f8ebf3036b9dd25969484"><td class="memItemLeft" align="right" valign="top"><a id="acd798ac70c0f8ebf3036b9dd25969484"></a>
llvm::StringMap&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#acd798ac70c0f8ebf3036b9dd25969484">outputVarsByName_</a></td></tr>
<tr class="memdesc:acd798ac70c0f8ebf3036b9dd25969484"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from names of the external outputs of the network to Variables. <br /></td></tr>
<tr class="separator:acd798ac70c0f8ebf3036b9dd25969484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a24b02060b09e46f0c8eed907e5b99"><td class="memItemLeft" align="right" valign="top"><a id="aa6a24b02060b09e46f0c8eed907e5b99"></a>
llvm::StringMap&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html#aa6a24b02060b09e46f0c8eed907e5b99">inputVarsByName_</a></td></tr>
<tr class="memdesc:aa6a24b02060b09e46f0c8eed907e5b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from names of the external inputs of the network to Variables. <br /></td></tr>
<tr class="separator:aa6a24b02060b09e46f0c8eed907e5b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Loads model: graph and weights. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aebda831dd716c8c1056f520783a062ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebda831dd716c8c1056f520783a062ac">&#9670;&nbsp;</a></span>ProtobufLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glow::ProtobufLoader::ProtobufLoader </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; const char *&gt;&#160;</td>
          <td class="paramname"><em>tensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_type.html">TypeRef</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> *&#160;</td>
          <td class="paramname"><em>errPtr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs new <a class="el" href="classglow_1_1_protobuf_loader.html" title="Loads model: graph and weights. ">ProtobufLoader</a> object. It will populate the network into <code>F</code>. The list <code>types</code> and <code>names</code> are used to initialized the inputs and outputs with specific names and types. If <code>errPtr</code> is not null then if an error occurs it will get assigned there otherwise if an error occurs it will abort. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab6c3cd81547d30058fc6061e31353289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c3cd81547d30058fc6061e31353289">&#9670;&nbsp;</a></span>createAndRegisterConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::ProtobufLoader::createAndRegisterConstant </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new constant that's initialized with <code>tensor</code>, and register it under the name <code>name</code>. If an existing <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> is already registered under the same name then the tensor is thrown out and no new <a class="el" href="classglow_1_1_constant.html">Constant</a> is created. </p>

</div>
</div>
<a id="a423b742fbe850b05ee21e3dd06276fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423b742fbe850b05ee21e3dd06276fd2">&#9670;&nbsp;</a></span>createAndRegisterPlaceholder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt; glow::ProtobufLoader::createAndRegisterPlaceholder </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> of type <code>T</code>, and register it under the name <code>name</code>. </p><dl class="section return"><dt>Returns</dt><dd>The newly created placeholder. </dd></dl>

</div>
</div>
<a id="a622b34ab4bbe4cfc5bcc5b03af58c214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622b34ab4bbe4cfc5bcc5b03af58c214">&#9670;&nbsp;</a></span>getConstantByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_constant.html">Constant</a> * &gt; glow::ProtobufLoader::getConstantByName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an Expected of the <a class="el" href="classglow_1_1_constant.html">Constant</a> registered with the given <code>name</code> and returns and Error if no <a class="el" href="classglow_1_1_constant.html">Constant</a> has been registered with this name. </dd></dl>

</div>
</div>
<a id="a85a86c2a07a5c396cc6a9fd25de6a2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a86c2a07a5c396cc6a9fd25de6a2ae">&#9670;&nbsp;</a></span>getConstantByNameOrNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_constant.html">Constant</a> * glow::ProtobufLoader::getConstantByNameOrNull </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classglow_1_1_constant.html">Constant</a> registered with the given <code>name</code> and nullptr if no <a class="el" href="classglow_1_1_constant.html">Constant</a> has been registered with this name. </dd></dl>

</div>
</div>
<a id="ac07756504a756acf83d49ef59ae1ff2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07756504a756acf83d49ef59ae1ff2f">&#9670;&nbsp;</a></span>getInputVarsMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::StringMap&lt;<a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt;&amp; glow::ProtobufLoader::getInputVarsMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>mapping between external names and actual Glow input nodes. </dd></dl>

</div>
</div>
<a id="afe06768b43d8aa8398d8d4c0c9668540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe06768b43d8aa8398d8d4c0c9668540">&#9670;&nbsp;</a></span>getNodeValueByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; glow::ProtobufLoader::getNodeValueByName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> that was registered with the name <code>name</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>hasNodeByName(name) </dd></dl>

</div>
</div>
<a id="ac558da9000f7c4cf499e2b4862827e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac558da9000f7c4cf499e2b4862827e5c">&#9670;&nbsp;</a></span>getNodeValueByNameOrNullNodeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a> glow::ProtobufLoader::getNodeValueByNameOrNullNodeValue </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> that was registered with the name <code>name</code> or a nullptr wrapped in a <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> if no node has been registered with this name. </dd></dl>

</div>
</div>
<a id="aa74cf67a8dae7eb8c6793aae25589c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74cf67a8dae7eb8c6793aae25589c24">&#9670;&nbsp;</a></span>getOutputByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt; glow::ProtobufLoader::getOutputByName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> for the external output with <code>name</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>outputVarsByName_.find(name) != outputVarsByName_.end() </dd></dl>

</div>
</div>
<a id="a7e89514a172bff5eb02915725d26e315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e89514a172bff5eb02915725d26e315">&#9670;&nbsp;</a></span>getOutputVarsMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::StringMap&lt;<a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt;&amp; glow::ProtobufLoader::getOutputVarsMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>mapping between external names and actual Glow output nodes. </dd></dl>

</div>
</div>
<a id="a84d14ec2ce55c5fd11a96fe688435b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d14ec2ce55c5fd11a96fe688435b40">&#9670;&nbsp;</a></span>getSingleOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1detail_1_1_glow_expected.html">Expected</a>&lt;<a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt; glow::ProtobufLoader::getSingleOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the single final output of the network. The function assumes that there is only one output, returns Error otherwise. For image classification, this single final output is usually the result of the last softmax or regression layer. </dd></dl>

</div>
</div>
<a id="abcb6af3498f15a1d84bc8800dda2a8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb6af3498f15a1d84bc8800dda2a8e2">&#9670;&nbsp;</a></span>hasConstantByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::ProtobufLoader::hasConstantByName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether or not a <a class="el" href="classglow_1_1_constant.html">Constant</a> has been registered with the given <code>name</code>. </dd></dl>

</div>
</div>
<a id="a50508e4cbe83b3cafd7d7319199c0fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50508e4cbe83b3cafd7d7319199c0fb7">&#9670;&nbsp;</a></span>hasNodeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::ProtobufLoader::hasNodeByName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the node that's registered using <code>name</code> exists. </dd></dl>

</div>
</div>
<a id="a60ed5b8175104dffe27f3f88b45ceede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ed5b8175104dffe27f3f88b45ceede">&#9670;&nbsp;</a></span>isConstantFoldable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::ProtobufLoader::isConstantFoldable </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>typeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the operator with name <code>typeName</code> having input node list as <code>inputs</code> is constant foldable. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/glow/Importer/<a class="el" href="_protobuf_loader_8h_source.html">ProtobufLoader.h</a></li>
<li>lib/Importer/ProtobufLoader.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
