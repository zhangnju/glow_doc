<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow::Handle&lt; ElemTy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglow.html">glow</a></li><li class="navelem"><a class="el" href="classglow_1_1_handle.html">Handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classglow_1_1_handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">glow::Handle&lt; ElemTy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_tensor_8h_source.html">Tensor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1870bb8d89827d3db93c0bf6500bda1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a>&lt; ElemTy, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a1870bb8d89827d3db93c0bf6500bda1f">begin</a> ()</td></tr>
<tr class="separator:a1870bb8d89827d3db93c0bf6500bda1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d1e52f79b0719837637ba9f24edcb"><td class="memItemLeft" align="right" valign="top"><a id="a416d1e52f79b0719837637ba9f24edcb"></a>
<a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a>&lt; ElemTy, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a416d1e52f79b0719837637ba9f24edcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb451dd6a54e840ff39a403a655097b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a>&lt; ElemTy, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a9fb451dd6a54e840ff39a403a655097b">end</a> ()</td></tr>
<tr class="separator:a9fb451dd6a54e840ff39a403a655097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5540aa3fca1906bbe77343d36023dd"><td class="memItemLeft" align="right" valign="top"><a id="a0e5540aa3fca1906bbe77343d36023dd"></a>
<a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a>&lt; ElemTy, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a0e5540aa3fca1906bbe77343d36023dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae201c577bfa7423f14722f365bbb8ddd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#ae201c577bfa7423f14722f365bbb8ddd">isValid</a> () const</td></tr>
<tr class="separator:ae201c577bfa7423f14722f365bbb8ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c31f9861ab398e8e244dde4bf7a122"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#aa2c31f9861ab398e8e244dde4bf7a122">getElementPtr</a> (llvm::ArrayRef&lt; size_t &gt; indices) const</td></tr>
<tr class="separator:aa2c31f9861ab398e8e244dde4bf7a122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f6b264d70213e15a0f1fc8560b5a04"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#ad3f6b264d70213e15a0f1fc8560b5a04">getDimForPtr</a> (size_t dim, size_t idx) const</td></tr>
<tr class="separator:ad3f6b264d70213e15a0f1fc8560b5a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012e00131edb5c3112c630c0e957c4cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a012e00131edb5c3112c630c0e957c4cf">getType</a> () const</td></tr>
<tr class="separator:a012e00131edb5c3112c630c0e957c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d71a692770a4dcb8654485d74965294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a2d71a692770a4dcb8654485d74965294">getElementType</a> () const</td></tr>
<tr class="separator:a2d71a692770a4dcb8654485d74965294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2df11f63a6d74d56f9630ab0d5b213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a9c2df11f63a6d74d56f9630ab0d5b213">Handle</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> *tensor)</td></tr>
<tr class="memdesc:a9c2df11f63a6d74d56f9630ab0d5b213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> handle.  <a href="#a9c2df11f63a6d74d56f9630ab0d5b213">More...</a><br /></td></tr>
<tr class="separator:a9c2df11f63a6d74d56f9630ab0d5b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade42ad6f343eca2623f33e0db0845426"><td class="memItemLeft" align="right" valign="top"><a id="ade42ad6f343eca2623f33e0db0845426"></a>
llvm::ArrayRef&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dims</b> () const</td></tr>
<tr class="separator:ade42ad6f343eca2623f33e0db0845426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7322ebb8b8d2d57f4ea9ec93f238b7a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a7322ebb8b8d2d57f4ea9ec93f238b7a5">size</a> () const</td></tr>
<tr class="separator:a7322ebb8b8d2d57f4ea9ec93f238b7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e96d19c373742cc3e667720958097"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a1e2e96d19c373742cc3e667720958097">actualSize</a> () const</td></tr>
<tr class="separator:a1e2e96d19c373742cc3e667720958097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e32121664e86e9ef7ca79967494cc8"><td class="memItemLeft" align="right" valign="top"><a id="ac6e32121664e86e9ef7ca79967494cc8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInBounds</b> (llvm::ArrayRef&lt; size_t &gt; indices) const</td></tr>
<tr class="separator:ac6e32121664e86e9ef7ca79967494cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc0c4a5e81c496abca71df14e08b605"><td class="memItemLeft" align="right" valign="top"><a id="a9dc0c4a5e81c496abca71df14e08b605"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (ElemTy value=0)</td></tr>
<tr class="separator:a9dc0c4a5e81c496abca71df14e08b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4170feefa1d97ce95bbdf7c880811c2b"><td class="memItemLeft" align="right" valign="top">ElemTy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a4170feefa1d97ce95bbdf7c880811c2b">at</a> (llvm::ArrayRef&lt; size_t &gt; indices)</td></tr>
<tr class="separator:a4170feefa1d97ce95bbdf7c880811c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff86c3f4eec15f312089c498a9426486"><td class="memItemLeft" align="right" valign="top"><a id="aff86c3f4eec15f312089c498a9426486"></a>
const ElemTy &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (llvm::ArrayRef&lt; size_t &gt; indices) const</td></tr>
<tr class="separator:aff86c3f4eec15f312089c498a9426486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea03569f22a6d701b671403b5d4c2d43"><td class="memItemLeft" align="right" valign="top">ElemTy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#aea03569f22a6d701b671403b5d4c2d43">raw</a> (size_t index)</td></tr>
<tr class="separator:aea03569f22a6d701b671403b5d4c2d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9004553e87770e18aa2396d88bfeeff"><td class="memItemLeft" align="right" valign="top">const ElemTy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#ae9004553e87770e18aa2396d88bfeeff">raw</a> (size_t index) const</td></tr>
<tr class="separator:ae9004553e87770e18aa2396d88bfeeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602cde4751f83f7a3b11a3b099ade080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a602cde4751f83f7a3b11a3b099ade080">extractSlice</a> (size_t idx) const</td></tr>
<tr class="separator:a602cde4751f83f7a3b11a3b099ade080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f14f140791e25024d601c91ca2f8ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a4f14f140791e25024d601c91ca2f8ced">insertSlice</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;slice, size_t idx)</td></tr>
<tr class="separator:a4f14f140791e25024d601c91ca2f8ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b958e66171d3824c9c7e67972c419ea"><td class="memItemLeft" align="right" valign="top"><a id="a2b958e66171d3824c9c7e67972c419ea"></a>
<a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a2b958e66171d3824c9c7e67972c419ea">clone</a> () const</td></tr>
<tr class="memdesc:a2b958e66171d3824c9c7e67972c419ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new copy of the current tensor. <br /></td></tr>
<tr class="separator:a2b958e66171d3824c9c7e67972c419ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50bb3902caf5a41a874e93fedfc872"><td class="memItemLeft" align="right" valign="top"><a id="afe50bb3902caf5a41a874e93fedfc872"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#afe50bb3902caf5a41a874e93fedfc872">operator=</a> (const std::initializer_list&lt; ElemTy &gt; &amp;vec)</td></tr>
<tr class="memdesc:afe50bb3902caf5a41a874e93fedfc872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the content of the tensor from a literal list: <br /></td></tr>
<tr class="separator:afe50bb3902caf5a41a874e93fedfc872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827aa2c9d05d80c7b0cd0947012e30bc"><td class="memItemLeft" align="right" valign="top"><a id="a827aa2c9d05d80c7b0cd0947012e30bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (llvm::ArrayRef&lt; ElemTy &gt; array)</td></tr>
<tr class="separator:a827aa2c9d05d80c7b0cd0947012e30bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ab471b0a2db4245382692a87d8d117"><td class="memItemLeft" align="right" valign="top"><a id="a19ab471b0a2db4245382692a87d8d117"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpAscii</b> (llvm::raw_ostream &amp;os) const</td></tr>
<tr class="separator:a19ab471b0a2db4245382692a87d8d117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aa58ad75ec36c3abbd673c552b4d67"><td class="memItemLeft" align="right" valign="top"><a id="a71aa58ad75ec36c3abbd673c552b4d67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpAscii</b> () const</td></tr>
<tr class="separator:a71aa58ad75ec36c3abbd673c552b4d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4004af33a68096e15f642e5e91d954d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#ac4004af33a68096e15f642e5e91d954d">minMaxArg</a> () const</td></tr>
<tr class="separator:ac4004af33a68096e15f642e5e91d954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add064d7f0e9c193dd326e237a3a2f767"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#add064d7f0e9c193dd326e237a3a2f767">isZero</a> (float allowedError=0.0) const</td></tr>
<tr class="separator:add064d7f0e9c193dd326e237a3a2f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2855b35850a35e27d81c184c1e9a035"><td class="memItemLeft" align="right" valign="top"><a id="ab2855b35850a35e27d81c184c1e9a035"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (llvm::raw_ostream &amp;os, unsigned maxNumElem=MAX_DUMP_ELEMS) const</td></tr>
<tr class="separator:ab2855b35850a35e27d81c184c1e9a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d7eb7099d95288357f7946c7ab8f4b"><td class="memItemLeft" align="right" valign="top"><a id="a71d7eb7099d95288357f7946c7ab8f4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (unsigned maxNumElem) const</td></tr>
<tr class="separator:a71d7eb7099d95288357f7946c7ab8f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73265b9bb46df7b521110d93b3777708"><td class="memItemLeft" align="right" valign="top"><a id="a73265b9bb46df7b521110d93b3777708"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:a73265b9bb46df7b521110d93b3777708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb37b02423e68e306cd4e0067e8689e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#aebb37b02423e68e306cd4e0067e8689e">initXavier</a> (size_t filterSize, <a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;PRNG)</td></tr>
<tr class="separator:aebb37b02423e68e306cd4e0067e8689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba569359ae39c17970cbfba5bbb6fa79"><td class="memTemplParams" colspan="2">template&lt;typename T  = ElemTy&gt; </td></tr>
<tr class="memitem:aba569359ae39c17970cbfba5bbb6fa79"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#aba569359ae39c17970cbfba5bbb6fa79">randomize</a> (float low, float high, <a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;PRNG)</td></tr>
<tr class="separator:aba569359ae39c17970cbfba5bbb6fa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b66d372800e15c009ee8d4aae8d32c2"><td class="memTemplParams" colspan="2">template&lt;typename T  = ElemTy&gt; </td></tr>
<tr class="memitem:a7b66d372800e15c009ee8d4aae8d32c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a7b66d372800e15c009ee8d4aae8d32c2">randomize</a> (int low, int high, <a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;PRNG)</td></tr>
<tr class="separator:a7b66d372800e15c009ee8d4aae8d32c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9f5d40382d7db26e117c2e7b3636a3"><td class="memTemplParams" colspan="2">template&lt;typename T  = ElemTy&gt; </td></tr>
<tr class="memitem:afc9f5d40382d7db26e117c2e7b3636a3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#afc9f5d40382d7db26e117c2e7b3636a3">randomize</a> (float low, float high, <a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;PRNG)</td></tr>
<tr class="separator:afc9f5d40382d7db26e117c2e7b3636a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542bc11508e42c8e2d2b1d2b07a40e8d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a542bc11508e42c8e2d2b1d2b07a40e8d">calculateMeanVariance</a> () const</td></tr>
<tr class="separator:a542bc11508e42c8e2d2b1d2b07a40e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e46eccc2e9bd998d798f19f368cf400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a8e46eccc2e9bd998d798f19f368cf400">insertTensors</a> (<a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt; &amp;slice, llvm::ArrayRef&lt; size_t &gt; offset, size_t count=1, size_t axis=0)</td></tr>
<tr class="separator:a8e46eccc2e9bd998d798f19f368cf400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ce4936e95b70768a705074098e0f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#ae4ce4936e95b70768a705074098e0f30">extractTensors</a> (<a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt; &amp;slice, llvm::ArrayRef&lt; size_t &gt; offset)</td></tr>
<tr class="separator:ae4ce4936e95b70768a705074098e0f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cf4cea87ecab8304875b1b609a6591"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8cf4cea87ecab8304875b1b609a6591"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#ae8cf4cea87ecab8304875b1b609a6591">getFusedScaleOffsetFromRow</a> (size_t rowIdx)</td></tr>
<tr class="separator:ae8cf4cea87ecab8304875b1b609a6591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885d9052ce52d0125e99e47b45bc5fcc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a885d9052ce52d0125e99e47b45bc5fcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a885d9052ce52d0125e99e47b45bc5fcc">setFusedScaleOffsetInRow</a> (size_t rowIdx, T scale, T offset)</td></tr>
<tr class="separator:a885d9052ce52d0125e99e47b45bc5fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0a6464ed0e2ca10bb7847227586f36f2"><td class="memItemLeft" align="right" valign="top"><a id="a0a6464ed0e2ca10bb7847227586f36f2"></a>
static <a class="el" href="classglow_1_1_handle.html">Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html#a0a6464ed0e2ca10bb7847227586f36f2">createInvalidHandle</a> ()</td></tr>
<tr class="memdesc:a0a6464ed0e2ca10bb7847227586f36f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new invalid handle. <br /></td></tr>
<tr class="separator:a0a6464ed0e2ca10bb7847227586f36f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ElemTy&gt;<br />
class glow::Handle&lt; ElemTy &gt;</h3>

<p>A class that provides indexed access to a tensor. This class has value semantics and it's copied around. One of the reasons for making this class value semantics is to allow efficient index calculation that the compiler can optimize (because stack allocated structures don't alias). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9c2df11f63a6d74d56f9630ab0d5b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2df11f63a6d74d56f9630ab0d5b213">&#9670;&nbsp;</a></span>Handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::<a class="el" href="classglow_1_1_handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> handle. </p>
<p>We allow handles that wrap uninitialized tensors. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e2e96d19c373742cc3e667720958097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e96d19c373742cc3e667720958097">&#9670;&nbsp;</a></span>actualSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::actualSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the actual number of elements in the tensor taking striding into account. Since <a class="el" href="classglow_1_1_handle.html#a7322ebb8b8d2d57f4ea9ec93f238b7a5">size()</a> does not take striding into account, <a class="el" href="classglow_1_1_handle.html#a7322ebb8b8d2d57f4ea9ec93f238b7a5">size()</a> is always &lt;= <a class="el" href="classglow_1_1_handle.html#a1e2e96d19c373742cc3e667720958097">actualSize()</a>. </dd></dl>

</div>
</div>
<a id="a4170feefa1d97ce95bbdf7c880811c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4170feefa1d97ce95bbdf7c880811c2b">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElemTy&amp; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to a meaningful data element. This method does not address padding elements. </p>

</div>
</div>
<a id="a1870bb8d89827d3db93c0bf6500bda1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1870bb8d89827d3db93c0bf6500bda1f">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a>&lt;ElemTy, false&gt; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first element of the tensor. </dd></dl>

</div>
</div>
<a id="a542bc11508e42c8e2d2b1d2b07a40e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542bc11508e42c8e2d2b1d2b07a40e8d">&#9670;&nbsp;</a></span>calculateMeanVariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;double, double&gt; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::calculateMeanVariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the mean and variance of the tensor. </dd></dl>

</div>
</div>
<a id="a9fb451dd6a54e840ff39a403a655097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb451dd6a54e840ff39a403a655097b">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a>&lt;ElemTy, false&gt; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator referring to the past-the-end element. </dd></dl>

</div>
</div>
<a id="a602cde4751f83f7a3b11a3b099ade080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602cde4751f83f7a3b11a3b099ade080">&#9670;&nbsp;</a></span>extractSlice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::extractSlice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract a smaller dimension tensor from a specific slice (that has to be the first dimension). </p>

</div>
</div>
<a id="ae4ce4936e95b70768a705074098e0f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ce4936e95b70768a705074098e0f30">&#9670;&nbsp;</a></span>extractTensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::extractTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract the tensor <code>slice</code> at location <code>offset</code>. This operation is equivalent to the operation of scanning the destination tensor, and copying into the cell at coordinate {d_0, d_1, ... d_n} a value from the tensor at {d_0 + O_0, d_1 + O_1, ... d_n + O_n}, where O is the offset vector. The tensors must be of the right dimensions. </p>

</div>
</div>
<a id="ad3f6b264d70213e15a0f1fc8560b5a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f6b264d70213e15a0f1fc8560b5a04">&#9670;&nbsp;</a></span>getDimForPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::getDimForPtr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of the n'th dimension <code>dim</code>, for the index <code>idx</code>. 0 &lt;= idx &lt; <a class="el" href="classglow_1_1_handle.html#a7322ebb8b8d2d57f4ea9ec93f238b7a5">size()</a>, meaning that <code>idx</code> addresses a real data elements, not paddings. </dd></dl>

</div>
</div>
<a id="aa2c31f9861ab398e8e244dde4bf7a122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c31f9861ab398e8e244dde4bf7a122">&#9670;&nbsp;</a></span>getElementPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::getElementPtr </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the index for a specific element in the tensor. Notice that the list of indices may be incomplete. This method provides access to padding elements, meaning that it's possible to get an index pointing at data, added to meet alignment requirements. </p>

</div>
</div>
<a id="a2d71a692770a4dcb8654485d74965294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d71a692770a4dcb8654485d74965294">&#9670;&nbsp;</a></span>getElementType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::getElementType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the element type of the tensor. </dd></dl>

</div>
</div>
<a id="ae8cf4cea87ecab8304875b1b609a6591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cf4cea87ecab8304875b1b609a6591">&#9670;&nbsp;</a></span>getFusedScaleOffsetFromRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T, T&gt; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::getFusedScaleOffsetFromRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pair of the scale and offset from a row <code>rowIdx</code> of a FusedRowwiseQuantized <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a>. </dd></dl>

</div>
</div>
<a id="a012e00131edb5c3112c630c0e957c4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012e00131edb5c3112c630c0e957c4cf">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structglow_1_1_type.html">Type</a>&amp; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the type of the tensor. </dd></dl>

</div>
</div>
<a id="aebb37b02423e68e306cd4e0067e8689e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb37b02423e68e306cd4e0067e8689e">&#9670;&nbsp;</a></span>initXavier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::initXavier </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>filterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>PRNG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the array with random data that's close to zero using the Xavier method, based on the paper [Bengio and Glorot 2010]. This type of initialization facilitates better training performance. The parameter <code>filterSize</code> is the number of "input" neurons in the tensor (or the relevant slice). For example, consider case of MatMul: NxM (<code>input</code>) * MxK (<code>weights</code>) == NxK (<code>result</code>) Correct <code>filterSize</code> for weights tensor is M, so that norm for each row of <code>input</code> equals to norm of corresponding row of <code>result</code>. </p>

</div>
</div>
<a id="a4f14f140791e25024d601c91ca2f8ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f14f140791e25024d601c91ca2f8ced">&#9670;&nbsp;</a></span>insertSlice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::insertSlice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a smaller dimension tensor into a larger tensor at a specific first-dimension index. </p>

</div>
</div>
<a id="a8e46eccc2e9bd998d798f19f368cf400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e46eccc2e9bd998d798f19f368cf400">&#9670;&nbsp;</a></span>insertTensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::insertTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert the tensor <code>slice</code> at location <code>offset</code> <code>count</code> times along the <code>axis</code>. This operation is equivalent to the operation of scanning the source tensor, and saving the value that is stored at coordinate {d_0, d_1, ... d_n} in the new tensor at {d_0 + O_0, d_1 + O_1, ... d_n + O_n}, where O is the offset vector, assuming <code>count</code> = 1. For <code>count</code> &gt; 1, the same <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> is copied <code>count</code> times along the provided <code>axis</code>. The tensors must be of the right dimensions. </p>

</div>
</div>
<a id="ae201c577bfa7423f14722f365bbb8ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae201c577bfa7423f14722f365bbb8ddd">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="classglow_1_1_handle.html">Handle</a> points to a valid tensor. </dd></dl>

</div>
</div>
<a id="add064d7f0e9c193dd326e237a3a2f767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add064d7f0e9c193dd326e237a3a2f767">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::isZero </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>allowedError</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if tensor contains only elements equal to zero. <code>allowedError</code> represents the delta from zero that is allowed before returning false. </dd></dl>

</div>
</div>
<a id="ac4004af33a68096e15f642e5e91d954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4004af33a68096e15f642e5e91d954d">&#9670;&nbsp;</a></span>minMaxArg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t, size_t&gt; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::minMaxArg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the raw indices of a min and max values from the tensor. In case of multiple min or max, the smallest index is returned. </dd></dl>

</div>
</div>
<a id="aba569359ae39c17970cbfba5bbb6fa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba569359ae39c17970cbfba5bbb6fa79">&#9670;&nbsp;</a></span>randomize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<div class="memtemplate">
template&lt;typename T  = ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::randomize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>PRNG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the tensor with uniformly distributed values in the range [low .. high). </p>

</div>
</div>
<a id="a7b66d372800e15c009ee8d4aae8d32c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b66d372800e15c009ee8d4aae8d32c2">&#9670;&nbsp;</a></span>randomize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<div class="memtemplate">
template&lt;typename T  = ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::randomize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>PRNG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the tensor with uniformly distributed values in the range [low .. high]. For quantized fused tensors leave scales/offsets unchanged. </p>

</div>
</div>
<a id="afc9f5d40382d7db26e117c2e7b3636a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9f5d40382d7db26e117c2e7b3636a3">&#9670;&nbsp;</a></span>randomize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<div class="memtemplate">
template&lt;typename T  = ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value&gt;::type <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::randomize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>PRNG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the tensor with uniformly distributed values in the range [low .. high). </p>

</div>
</div>
<a id="aea03569f22a6d701b671403b5d4c2d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea03569f22a6d701b671403b5d4c2d43">&#9670;&nbsp;</a></span>raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElemTy&amp; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::raw </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the element at offset <code>idx</code> without any size calculations. The returned element can be a pad element. </dd></dl>

</div>
</div>
<a id="ae9004553e87770e18aa2396d88bfeeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9004553e87770e18aa2396d88bfeeff">&#9670;&nbsp;</a></span>raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ElemTy&amp; <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::raw </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the element at offset <code>idx</code> without any size calculations. The returned element can be a pad element. </dd></dl>

</div>
</div>
<a id="a885d9052ce52d0125e99e47b45bc5fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885d9052ce52d0125e99e47b45bc5fcc">&#9670;&nbsp;</a></span>setFusedScaleOffsetInRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::setFusedScaleOffsetInRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <code>scale</code> and <code>offset</code> to a row <code>rowIdx</code> of a FusedRowwiseQuantized <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a>. </p>

</div>
</div>
<a id="a7322ebb8b8d2d57f4ea9ec93f238b7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7322ebb8b8d2d57f4ea9ec93f238b7a5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classglow_1_1_handle.html">glow::Handle</a>&lt; ElemTy &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of elements in the whole tensor. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/glow/Base/<a class="el" href="_tensor_8h_source.html">Tensor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
