<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">glow Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceglow_1_1_arithmetic_node"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow_1_1_arithmetic_node.html">ArithmeticNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceglow_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceglow_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceglow_1_1tagged__list__details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow_1_1tagged__list__details.html">tagged_list_details</a></td></tr>
<tr class="memdesc:namespaceglow_1_1tagged__list__details"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of <a class="el" href="classglow_1_1_tagged_list.html">TaggedList</a> implementation details. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_adaptive_avg_pool_grad_inst.html">AdaptiveAvgPoolGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_adaptive_avg_pool_grad_node.html">AdaptiveAvgPoolGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_adaptive_avg_pool_inst.html">AdaptiveAvgPoolInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_adaptive_avg_pool_node.html">AdaptiveAvgPoolNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an Adaptive Average Pool operation on the Input given.  <a href="classglow_1_1_adaptive_avg_pool_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_add_grad_node.html">AddGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_add_node.html">AddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Add on the LHS and RHS operands.  <a href="classglow_1_1_add_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_alloc_activation_inst.html">AllocActivationInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_arg_max_inst.html">ArgMaxInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_arg_max_node.html">ArgMaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds index of a maximum element along Axis.If KeepDims is not true, the axis is removed from output.  <a href="classglow_1_1_arg_max_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_avg_pool_grad_inst.html">AvgPoolGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_avg_pool_grad_node.html">AvgPoolGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_avg_pool_inst.html">AvgPoolInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_avg_pool_node.html">AvgPoolNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an Average Pool operation on the Input given provided Kernels, Strides, and Pads. Supported layouts are defined in the ConvolutionLayout enum: NHWC and NCHW.  <a href="classglow_1_1_avg_pool_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_backend.html">Backend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_backend_hints.html">BackendHints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hints provided to the <a class="el" href="classglow_1_1_backend.html">Backend</a>, the backend is not required to honor them.  <a href="structglow_1_1_backend_hints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_backend_options.html">BackendOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options relevant to Backends during compilation.  <a href="structglow_1_1_backend_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_backend_using_glow_i_r.html">BackendUsingGlowIR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_base_factory.html">BaseFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batch_box_cox_node.html">BatchBoxCoxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply box-cox transform for each column for each column in NxD input tensor.  <a href="classglow_1_1_batch_box_cox_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_add_inst.html">BatchedAddInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_add_node.html">BatchedAddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the 'Slice' operand to each one of the slices in the batch.  <a href="classglow_1_1_batched_add_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_reduce_add_inst.html">BatchedReduceAddInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_reduce_add_node.html">BatchedReduceAddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates all of the layers in the batch and produce a tensor that has the same dimensions as the input tensor without the first dimension.  <a href="classglow_1_1_batched_reduce_add_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_reduce_mean_node.html">BatchedReduceMeanNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Average Mean operation on the Input given Axes.  <a href="classglow_1_1_batched_reduce_mean_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_reduce_min_inst.html">BatchedReduceMinInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batched_reduce_min_node.html">BatchedReduceMinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Reduce Min operation on the Input given Axes.  <a href="classglow_1_1_batched_reduce_min_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batch_mat_mul_node.html">BatchMatMulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs batch matrix multiplication between the LHS and RHS. The operands are a stack of two dimensional matrices. Example: (N, A, Z) x (N, Z, B) =&gt; (N, A, B)  <a href="classglow_1_1_batch_mat_mul_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batch_normalization_grad_node.html">BatchNormalizationGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batch_normalization_node.html">BatchNormalizationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs batch normalization on the Input tensor with the provided Scale, Bias, Mean, Var, ChannelIdx, Epsilon, and Momentum. Similar to Caffe2 SpatialBN, and ONNX BatchNormalization operator.  <a href="classglow_1_1_batch_normalization_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batch_one_hot_inst.html">BatchOneHotInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_batch_one_hot_node.html">BatchOneHotNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands each row of the Data to a row of zeros and ones, according to One Hot Encoding. i-th element of Result's row is one iff Values[i] equals to the corresponding element of Data.  <a href="classglow_1_1_batch_one_hot_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_block_stream.html">BlockStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_bound_interpreter_function.html">BoundInterpreterFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classglow_1_1_interpreter_function.html" title="Function &quot;compiled&quot; for execution by the interpreter. ">InterpreterFunction</a> bound to a specific invocation.  <a href="classglow_1_1_bound_interpreter_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_bucketize_node.html">BucketizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bucketization on the input given Boundaries.  <a href="classglow_1_1_bucketize_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_bundle_saver.html">BundleSaver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_caffe2_model_loader.html">Caffe2ModelLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads <a class="el" href="namespacecaffe2.html">caffe2</a> models.  <a href="classglow_1_1_caffe2_model_loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_channel_shuffle_node.html">ChannelShuffleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Channel shuffle.  <a href="classglow_1_1_channel_shuffle_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_channelwise_quantized_convolution_inst.html">ChannelwiseQuantizedConvolutionInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_channelwise_quantized_convolution_node.html">ChannelwiseQuantizedConvolutionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, and Group. Quantization parameters are provided by Scales and Offsets. If Groupwise is true then the quantization is per-group otherwise it is per-channel.  <a href="classglow_1_1_channelwise_quantized_convolution_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_child_mem_size_based_scheduler.html">ChildMemSizeBasedScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_clip_node.html">ClipNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip range of inputs to lie in [Min, Max].  <a href="classglow_1_1_clip_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cmp_e_q_node.html">CmpEQNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an element-wise equal comparison on the LHS and RHS operands. Inputs must be integer.  <a href="classglow_1_1_cmp_e_q_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cmp_l_t_e_node.html">CmpLTENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs CmpLTE on the LHS and RHS operands. Generates a mask that's consumed by the select instruction. The format of the result is target- and type-specific.  <a href="classglow_1_1_cmp_l_t_e_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cmp_l_t_node.html">CmpLTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares X and Y element wise sets Dest[i] true if LHS[i] &lt; RHS[i] otherwise false. Final result is a mask consumed by Select, ONNX Where, operator.  <a href="classglow_1_1_cmp_l_t_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_common_operator_loader.html">CommonOperatorLoader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_common_operator_writer.html">CommonOperatorWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_compare_operator_equal.html">CompareOperatorEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator ==.  <a href="structglow_1_1_compare_operator_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_compare_operator_greater_equal.html">CompareOperatorGreaterEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator &gt;=.  <a href="structglow_1_1_compare_operator_greater_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_compare_operator_greater_than.html">CompareOperatorGreaterThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator &gt;.  <a href="structglow_1_1_compare_operator_greater_than.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_compare_operator_less_equal.html">CompareOperatorLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator &lt;=.  <a href="structglow_1_1_compare_operator_less_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_compare_with_name.html">CompareWithName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface that the comparison operator must implement.  <a href="structglow_1_1_compare_with_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for compilation.  <a href="structglow_1_1_compilation_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_compiled_function.html">CompiledFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for executing a compiled function.  <a href="classglow_1_1_compiled_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_concat_node.html">ConcatNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convert_to_inst.html">ConvertToInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convert_to_node.html">ConvertToNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input from its current type to the destination type. The input and output types must have the same shapes. Moreover the input and output types must not be quantized types. Quantized types should use the appropriate Quantize, Dequantize, and Rescale nodes.  <a href="classglow_1_1_convert_to_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution3_d_grad_inst.html">Convolution3DGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution3_d_grad_node.html">Convolution3DGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution3_d_inst.html">Convolution3DInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, and Group.  <a href="classglow_1_1_convolution3_d_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution_grad_inst.html">ConvolutionGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution_grad_node.html">ConvolutionGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution_inst.html">ConvolutionInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, Group and Dilation. Supported Layouts are defined in the ConvolutionLayout enum: NHWC and NCHW. Supported FusedActivations are defined in the FusedActivation enum.  <a href="classglow_1_1_convolution_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_copy_inst.html">CopyInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_backend.html">CPUBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_conv_d_k_k_c8_inst.html">CPUConvDKKC8Inst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_conv_d_k_k_c8_node.html">CPUConvDKKC8Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a cpu-specific convolution implementation where the filter is transposed to the shape [D/8, K, K, C, 8].  <a href="classglow_1_1_c_p_u_conv_d_k_k_c8_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_function.html">CPUFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Glow IR function compiled for the CPU using LLVM.  <a href="classglow_1_1_c_p_u_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_l_l_v_m_i_r_gen.html">CPULLVMIRGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_max_splat_inst.html">CPUMaxSplatInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_c_p_u_max_splat_node.html">CPUMaxSplatNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Max node with one splat input; CPU specific.  <a href="classglow_1_1_c_p_u_max_splat_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cross_entropy_loss_grad_inst.html">CrossEntropyLossGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cross_entropy_loss_grad_node.html">CrossEntropyLossGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cross_entropy_loss_inst.html">CrossEntropyLossInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_cross_entropy_loss_node.html">CrossEntropyLossNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average cross entropy loss of the input.  <a href="classglow_1_1_cross_entropy_loss_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_dealloc_activation_inst.html">DeallocActivationInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_debug_info.html">DebugInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A POD struct that stores information related to debug info.  <a href="structglow_1_1_debug_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_debug_print_inst.html">DebugPrintInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_dequantize_inst.html">DequantizeInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_dequantize_node.html">DequantizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert quantized input tensor into the float representation. x = Scale * (x_q - Offset).  <a href="classglow_1_1_dequantize_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_description_builder.html">DescriptionBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that builds a textual descriptor of a group of parameters.  <a href="classglow_1_1_description_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_device_bindings.html">DeviceBindings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_device_config_helper.html">DeviceConfigHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure used to read the yaml file for Device Configs.  <a href="structglow_1_1_device_config_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_div_grad_node.html">DivGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_div_node.html">DivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Div on the LHS and RHS operands.  <a href="classglow_1_1_div_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_add_inst.html">ElementAddInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_cmp_e_q_inst.html">ElementCmpEQInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_cmp_l_t_e_inst.html">ElementCmpLTEInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_cmp_l_t_inst.html">ElementCmpLTInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_div_inst.html">ElementDivInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_exp_inst.html">ElementExpInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_is_na_n_inst.html">ElementIsNaNInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_log_inst.html">ElementLogInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_max_inst.html">ElementMaxInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_min_inst.html">ElementMinInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_mul_inst.html">ElementMulInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_pow_inst.html">ElementPowInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_select_inst.html">ElementSelectInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_element_sub_inst.html">ElementSubInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_execution_context.html">ExecutionContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_execution_engine.html">ExecutionEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_exp_node.html">ExpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise exponential to the Input.  <a href="classglow_1_1_exp_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_extract_tensor_inst.html">ExtractTensorInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_factory_registry.html">FactoryRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_file_adapter.html">FileAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1float16.html">float16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_fully_connected_grad_node.html">FullyConnectedGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a FullyConnected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output.  <a href="classglow_1_1_fully_connected_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the compute graph.  <a href="classglow_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function_converter.html">FunctionConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_function_name_comparator.html">FunctionNameComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function_pass.html">FunctionPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function_pass_config.html">FunctionPassConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function_pass_manager.html">FunctionPassManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a pipeline for executing a series of FunctionPasses.  <a href="classglow_1_1_function_pass_pipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html">FusedRowwiseQuantizedSparseLengthsSumNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Lengths) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). The input data is fused rowwise-quantized, where the Scales and Offsets are appended to the end of each row. Thus, Data must be a two-dimensional tensor.  <a href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_inst.html">FusedRowwiseQuantizedSparseLengthsWeightedSumInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html">FusedRowwiseQuantizedSparseLengthsWeightedSumNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Lengths) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). Before doing aggregation, each individual slice is scaled by its weight: Result[0] = Weights[0] * Slice(0) + Weights[1] * Slice(1) + ... It implies that len(Weights) == len(Indices). The input data is fused rowwise-quantized, where the Scales and Offsets are appended to the end of each row. Thus, Data must be a two-dimensional tensor.  <a href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_gather_inst.html">GatherInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_gather_node.html">GatherNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers entries of the outer-most dimension of Data indexed by Indices, and concatenates them. Output tensor will have dimensions: {I_0, I_1, ... I_n, D_1, D_2, ... D_m}, where D_i and I_j denote Data and Indices dimensions respectively. If batchDims is not zero, the gather operator will treat the first batchDims as the batch and will concat the result of the gather operation on each sample in the batch.  <a href="classglow_1_1_gather_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_gather_ranges_inst.html">GatherRangesInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_gather_ranges_node.html">GatherRangesNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers entries of Data into Output in groups specified by the elements of Ranges. Each element of Ranges contains a list of pairs of indices of the form (index, length) which specify which entries of data to gather. The ordering of elements in Ranges and of pairs within an element is preserved in Output. Lengths contains the lengths of the ranges gathered by each list of pairs in Ranges.  <a href="classglow_1_1_gather_ranges_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_graph_grad_mapper.html">GraphGradMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory usage of a subgraph (i.e. a list of nodes of a function).  <a href="structglow_1_1_graph_mem_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_graph_post_order_visitor.html">GraphPostOrderVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for ordering Graph nodes in a post-order order.  <a href="classglow_1_1_graph_post_order_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_graph_pre_order_visitor.html">GraphPreOrderVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for ordering Graph nodes in a pre-order order.  <a href="classglow_1_1_graph_pre_order_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_habana_backend.html">HabanaBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_habana_bindings.html">HabanaBindings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_habana_function.html">HabanaFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_habana_i_o_buffer.html">HabanaIOBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_habana_i_o_buffer_pool.html">HabanaIOBufferPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_habana_wait_handle.html">HabanaWaitHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle.html">Handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_handle_iterator.html">HandleIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_hooked_function.html">HookedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_i_n_n_p_i_node_importer.html">INNPINodeImporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for all node specific importers.  <a href="classglow_1_1_i_n_n_p_i_node_importer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_insert_tensor_inst.html">InsertTensorInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_insert_tensor_node.html">InsertTensorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert tensor Small into tensor Big given indices Start. Small is inserted Count times along Axis. The resulting <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> will have the same type as the input Big tensor.  <a href="classglow_1_1_insert_tensor_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_instruction.html">Instruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an instruction in our IR.  <a href="classglow_1_1_instruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_instruction_numbering.html">InstructionNumbering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used for instructions numbering.  <a href="classglow_1_1_instruction_numbering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_instruction_traits.html">InstructionTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_interpreter.html">Interpreter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_interpreter_function.html">InterpreterFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> "compiled" for execution by the interpreter.  <a href="classglow_1_1_interpreter_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_int_lookup_table_inst.html">IntLookupTableInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_int_lookup_table_node.html">IntLookupTableNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple mapping between quantized numbers.This can be used as quantized sigmoid or tanh functions.  <a href="classglow_1_1_int_lookup_table_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_i_r_builder.html">IRBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classglow_1_1_i_r_builder.html" title="The IRBuilder constructs the IR in the function. ">IRBuilder</a> constructs the IR in the function.  <a href="classglow_1_1_i_r_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that represents the compilation unit.  <a href="classglow_1_1_i_r_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_i_r_gen_visitor.html">IRGenVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_is_na_n_node.html">IsNaNNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether each element of the Input is NaN and generates a mask that can be consumed by a Select node.  <a href="classglow_1_1_is_na_n_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_kernel_launch.html">KernelLaunch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct with information about kernels launches.  <a href="structglow_1_1_kernel_launch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_kinded.html">Kinded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="classglow_1_1_value.html">Value</a> have an enum that describe their kind.  <a href="classglow_1_1_kinded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_lengths_range_fill_inst.html">LengthsRangeFillInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_lengths_range_fill_node.html">LengthsRangeFillNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an input Lengths 1D vector into a range sequence.  <a href="classglow_1_1_lengths_range_fill_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_lengths_sum_inst.html">LengthsSumInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_lengths_sum_node.html">LengthsSumNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums slices of the outermost dimension of Data in groups defined by Lengths. The first Lengths[0] slices are added together and stored in Result[0], the subsequent Lengths[1] slices are added together and stored in Result[1], etc.  <a href="classglow_1_1_lengths_sum_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_lengths_to_ranges_inst.html">LengthsToRangesInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_lengths_to_ranges_node.html">LengthsToRangesNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of segment lengths, calculates offsets of each segment and packs them next to the lengths. For the input vector of length N the output is a Nx2 matrix with (offset, lengths) packaged for each segment.  <a href="classglow_1_1_lengths_to_ranges_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_backend.html">LLVMBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_compiled_function.html">LLVMCompiledFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Glow IR function compiled using LLVM.  <a href="classglow_1_1_l_l_v_m_compiled_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html">LLVMIRGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_loader.html">Loader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_load_weight_result.html">LoadWeightResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_local_response_normalization_grad_inst.html">LocalResponseNormalizationGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_local_response_normalization_grad_node.html">LocalResponseNormalizationGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_local_response_normalization_inst.html">LocalResponseNormalizationInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_local_response_normalization_node.html">LocalResponseNormalizationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs local response normalization on the Input tensor with the provided Scale, Bias, Mean, Var, ChannelIdx, Epsilon, and Momentum. Similar to Caffe2 and ONNX LRN.  <a href="classglow_1_1_local_response_normalization_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_log_context.html">LogContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for logging all compilation related activities.  <a href="classglow_1_1_log_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_log_create.html">LogCreate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_log_delete.html">LogDelete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_log_event.html">LogEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_log_input_change.html">LogInputChange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_log_node.html">LogNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise natural log to the Input.  <a href="classglow_1_1_log_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_log_scope.html">LogScope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_mat_mul_inst.html">MatMulInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_mat_mul_node.html">MatMulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix multiplication between the LHS and RHS.Example: (A, Z) x (Z, B) =&gt; (A, B)  <a href="classglow_1_1_mat_mul_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_max_node.html">MaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Max on the LHS and RHS operands.  <a href="classglow_1_1_max_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_max_pool_grad_node.html">MaxPoolGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_max_pool_inst.html">MaxPoolInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_max_pool_node.html">MaxPoolNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a Max Pool with Argmax operation on the Input given provided Kernels, Strides, and Pads. Argmax is a flattened index corresponding to respective max element. Supported layouts are defined in the ConvolutionLayout enum: NHWC and NCHW.  <a href="classglow_1_1_max_pool_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_max_pool_with_argmax_grad_inst.html">MaxPoolWithArgmaxGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_max_pool_with_argmax_inst.html">MaxPoolWithArgmaxInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_mean_var_normalization_node.html">MeanVarNormalizationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates new normalized mean and variance based on the input mean, variance, and input.  <a href="classglow_1_1_mean_var_normalization_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_memory_allocator.html">MemoryAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_min_node.html">MinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Min on the LHS and RHS operands.  <a href="classglow_1_1_min_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_module.html">Module</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_modulo_inst.html">ModuloInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_modulo_node.html">ModuloNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs elementwise modulo operation on the input where each element in the output is the corresponding element in the input data modulo Divisor.  <a href="classglow_1_1_modulo_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_mul_grad_node.html">MulGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_mul_node.html">MulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Mul on the LHS and RHS operands.  <a href="classglow_1_1_mul_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_multi_line_str.html">MultiLineStr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for multi string format used in yaml file.  <a href="structglow_1_1_multi_line_str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html">Named</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This add the capability to name subclasses.  <a href="classglow_1_1_named.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_n_n_p_i_backend.html">NNPIBackend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the Intel Neural-Network Processor for Inference (NNPI) backend.  <a href="classglow_1_1_n_n_p_i_backend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_n_n_p_i_compiled_function.html">NNPICompiledFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> "compiled" for execution by the NNPI backend.  <a href="classglow_1_1_n_n_p_i_compiled_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_n_n_p_i_env_variables.html">NNPIEnvVariables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_n_n_p_i_importer.html">NNPIImporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class imports Glow IR to the NNPI backend.  <a href="classglow_1_1_n_n_p_i_importer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_n_n_p_i_message_logger.html">NNPIMessageLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NNPI logging stream controller.  <a href="classglow_1_1_n_n_p_i_message_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a node in the compute graph.  <a href="classglow_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_node_handle.html">NodeHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_info.html">NodeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_node_quantization_info.html">NodeQuantizationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> quantization parameters for a given node.  <a href="structglow_1_1_node_quantization_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_node_use.html">NodeUse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A '<a class="el" href="structglow_1_1_use.html">Use</a>' is a use-list representation of a <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> operand.  <a href="structglow_1_1_node_use.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_value_array_ref.html">NodeValueArrayRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_value_iterator_impl.html">NodeValueIteratorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_visitor.html">NodeVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_visitor_base.html">NodeVisitorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node_walker.html">NodeWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A walker that recursively visits a node and its children.  <a href="classglow_1_1_node_walker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_o_c_l_backend.html">OCLBackend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the OpenCL backend.  <a href="classglow_1_1_o_c_l_backend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_one_err_only.html">OneErrOnly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_o_n_n_x_i_f_i_model_loader.html">ONNXIFIModelLoader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_o_n_n_x_model_loader.html">ONNXModelLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads ONNX models.  <a href="classglow_1_1_o_n_n_x_model_loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_o_n_n_x_model_writer.html">ONNXModelWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ONNX models.  <a href="classglow_1_1_o_n_n_x_model_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_open_c_l_function.html">OpenCLFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Glow IR function compiled for OpenCL.  <a href="classglow_1_1_open_c_l_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_optimization_options.html">OptimizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options relevant to optimizations during compilation.  <a href="structglow_1_1_optimization_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_padding_t_l_b_r.html">PaddingTLBR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_padding_t_l_n_b_r_f.html">PaddingTLNBRF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_pad_node.html">PadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs padding of a given input tensor. The Padding information must be specified for each dimension of the tensor in Pads (start and end padding). In case the padding is negative, it means that the tensor must be cropped. Mode defines how extra padding elements are created. Supported modes are defined in the PaddingMode enum: CONSTANT, REFLECT, EDGE. <a class="el" href="classglow_1_1_value.html">Value</a> is only used with the CONSTANT mode.  <a href="classglow_1_1_pad_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_partitioner.html">Partitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_partitioner_base.html">PartitionerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_placeholder.html">Placeholder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_placeholder_input_output_info.html">PlaceholderInputOutputInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information for placeholder during allocation.  <a href="structglow_1_1_placeholder_input_output_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_post_order_visitor.html">PostOrderVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for ordering the nodes in a post-order order.  <a href="structglow_1_1_post_order_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_pow_node.html">PowNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs elementwise pow(LHS, RHS).  <a href="classglow_1_1_pow_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_precision_configuration.html">PrecisionConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration for different precision modes.  <a href="structglow_1_1_precision_configuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_p_relu_node.html">PReluNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies PReLU, slope * min(0, x) + max(0, x), to each element in the Input tensor.  <a href="classglow_1_1_p_relu_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_pre_order_visitor.html">PreOrderVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for ordering the nodes in a pre-order order.  <a href="structglow_1_1_pre_order_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_loader.html">ProtobufLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads model: graph and weights.  <a href="classglow_1_1_protobuf_loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_protobuf_writer.html">ProtobufWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes model: graph and weights.  <a href="classglow_1_1_protobuf_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_quantization_profile_inst.html">QuantizationProfileInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_quantization_profile_node.html">QuantizationProfileNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate profile (distribution of values) of the Input tensor. This data is used for quantization of the tensor later on. ProfiledNodeName contains the name of the node which is profiled by the QuantizationProfile node. ProfiledNodeName is helpful as lowering might transform the original graph. ProfiledOutputNumber contains the position of the node's output which gets profiled.  <a href="classglow_1_1_quantization_profile_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_quantization_transform32_to8.html">QuantizationTransform32To8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_quantize_inst.html">QuantizeInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_quantize_node.html">QuantizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize floating point tensor. This operation converts floating point numbers to integers based on the given Scale and Offset. Scale and Offset are deduced from the type of the output.x_q = clip(round(x/Scale) + Offset, -128, 127)  <a href="classglow_1_1_quantize_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_register_factory.html">RegisterFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_regression_grad_node.html">RegressionGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_regression_node.html">RegressionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an Input tensor and creates a regression output layer.  <a href="classglow_1_1_regression_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_relu_grad_node.html">ReluGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_relu_inst.html">ReluInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_relu_node.html">ReluNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies ReLU, max(0, x), to each element in the Input tensor.  <a href="classglow_1_1_relu_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_replace_na_n_node.html">ReplaceNaNNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces NaNs found in Input with <a class="el" href="classglow_1_1_value.html">Value</a>.  <a href="classglow_1_1_replace_na_n_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_rescale_quantized_inst.html">RescaleQuantizedInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_rescale_quantized_node.html">RescaleQuantizedNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescale the input quantized tensor to a new Scale and Offset. The new Scale and Offset are specified by the output type passed to the constructor.  <a href="classglow_1_1_rescale_quantized_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the Input tensor to shape Dims.  <a href="classglow_1_1_reshape_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_resize_nearest_inst.html">ResizeNearestInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_resize_nearest_node.html">ResizeNearestNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Input tensor of [N,H,W,C], where N is the batch, C is the channel or depth, H is the height and W is the width, Generates an Output tensor with resized spatial dimensions using nearest neighbor interpolation. The Output tensor is of shape [N, floor(H*HeightScale), floor(W*WidthScale), C].  <a href="classglow_1_1_resize_nearest_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_rowwise_quantized_fully_connected_inst.html">RowwiseQuantizedFullyConnectedInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_rowwise_quantized_fully_connected_node.html">RowwiseQuantizedFullyConnectedNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RowwiseQuantizedFullyConnected node where the Input matrix and the transpose of Weights matrix are multiplied, and then the Bias vector is broadcast-added to the result. Input, Bias and Result are regularly quantized, while Weights use row-wisequantization.  <a href="classglow_1_1_rowwise_quantized_fully_connected_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_inst.html">RowwiseQuantizedSparseLengthsWeightedSumInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Lengths) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). Before doing aggregation, each individual slice is scaled by its weight: Result[0] = Weights[0] * Slice(0) + Weights[1] * Slice(1) + ... It implies that len(Weights) == len(Indices). The input data is rowwise-quantized, where the Scales and Offsets are 1D tensors of length equal to the first dim of Data.  <a href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_save_node.html">SaveNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a node whose Input will be copied to Output.This node prevents graph optimizations from eliminating this node and all of its ancestor nodes. Generally intended to save the final result of a network.  <a href="classglow_1_1_save_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_scatter_data_inst.html">ScatterDataInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_scatter_data_node.html">ScatterDataNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies each slice from Slices into Data at the corresponding index in Indices. For example, given input Data {{1,2},{3,4},{5,6}}, Slices {{-3,-4}}, and Indices {{1}}, the result is {{1,2},{-3,-4},{5,6}}. It also supports multi-dimensional indices. For example, given input Data {{1,2},{3,4},{5,6}}, Slices {-3,-4}, and Indices {{1,0},{1,1}} also produces {{1,2},{-3,-4},{5,6}}. If Cumulative is true, the node adds values from Slices to Data instead of copying. For example, given input Data {{1,2},{3,4},{5,6}}, Slices {{-3,-4}}, and Indices {1}, the result is {{1,2},{0,0},{5,6}}. If an index is specified several times, its updates will be added several times as well.  <a href="classglow_1_1_scatter_data_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_scheduler.html">Scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_scoped_log_block.html">ScopedLogBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which traces the start and end of a compilation log scope.  <a href="classglow_1_1_scoped_log_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_scoped_trace_block.html">ScopedTraceBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_segment.html">Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A POD struct that represents a single half-open allocation [start .. end).  <a href="classglow_1_1_segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_select_node.html">SelectNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects between values on the LHS or RHS, depending on the value of Cond. Cond is generated by the compare instruction, and is target- and type-specific.  <a href="classglow_1_1_select_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_s_g_d_node.html">SGDNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stochastic Gradient Descent node used during training. Produces the updated weight that needs to be used instead of Weight for the next iteration.  <a href="classglow_1_1_s_g_d_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_shape_h_w.html">ShapeHW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_shape_h_w_d.html">ShapeHWD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_shape_n_c_h_w.html">ShapeNCHW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_shape_n_h_w_c.html">ShapeNHWC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_shape_n_h_w_d_c.html">ShapeNHWDC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sigmoid_cross_entropy_with_logits_node.html">SigmoidCrossEntropyWithLogitsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sigmoid cross entropy between two inputs.  <a href="classglow_1_1_sigmoid_cross_entropy_with_logits_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sigmoid_grad_node.html">SigmoidGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sigmoid_inst.html">SigmoidInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sigmoid_node.html">SigmoidNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Sigmoid, 1 / (1 + exp(-x)), to each element in the Input tensor.  <a href="classglow_1_1_sigmoid_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_slice_node.html">SliceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a slice of the Input tensor. The Start vector defines the starting indices for each dimension from which the slice should be taken. The end index for each dimension is determined from the input type's shape.  <a href="classglow_1_1_slice_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_soft_max_grad_inst.html">SoftMaxGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_soft_max_grad_node.html">SoftMaxGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_soft_max_inst.html">SoftMaxInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_soft_max_node.html">SoftMaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs SoftMax normalization on the Input tensor.  <a href="classglow_1_1_soft_max_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_space_to_depth_inst.html">SpaceToDepthInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_space_to_depth_node.html">SpaceToDepthNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Input tensor of [N,H,W,C], where N is the batch axis, C is the channel or depth, H is the height and W is the width. This produces Output tensor of [N, H/BlockSize, W/BlockSize, C * BlockSize * BlockSize].  <a href="classglow_1_1_space_to_depth_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_sum_inst.html">SparseLengthsSumInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_sum_node.html">SparseLengthsSumNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Lengths) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices).  <a href="classglow_1_1_sparse_lengths_sum_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_grad_inst.html">SparseLengthsWeightedSumGradInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_grad_node.html">SparseLengthsWeightedSumGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_inst.html">SparseLengthsWeightedSumInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_node.html">SparseLengthsWeightedSumNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Lengths) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). Before doing aggregation, each individual slice is scaled by its weight: Result[0] = Weights[0] * Slice(0) + Weights[1] * Slice(1) + ... It implies that len(Weights) == len(Indices).  <a href="classglow_1_1_sparse_lengths_weighted_sum_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_offsets_inst.html">SparseLengthsWeightedSumOffsetsInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_offsets_node.html">SparseLengthsWeightedSumOffsetsNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Offsets) entries: first slice between Offsets[0] and Offsets[1] (or total length if there's only one elem in Offsets) are aggregated to Result[0], etc. I.e. largest offset must be less than or equal to len(Indices). Before doing aggregation, each individual slice is scaled by its weight: Result[0] = Weights[0] * Slice(0) + Weights[1] * Slice(1) + ... It implies that len(Weights) == len(Indices).  <a href="classglow_1_1_sparse_lengths_weighted_sum_offsets_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_to_dense_inst.html">SparseToDenseInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_to_dense_mask_inst.html">SparseToDenseMaskInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_to_dense_mask_node.html">SparseToDenseMaskNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the sparse representation specified by the pair (Indices, Values) into a dense one, where compacted tensor only contains IDs from given Mask. Indices cannot contain duplicate values. Lengths is used to distinguish elements from different examples of one batch. That is, first Lengths[0] index-value pairs belong to batch's example 0, next Lengths[1] pairs belong to example 1, and so on.  <a href="classglow_1_1_sparse_to_dense_mask_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sparse_to_dense_node.html">SparseToDenseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the sparse representation specified by the pair (Indices, Values) into a dense one. This dense representation contains each value from Values at the corresponding index specified in Indices. Unspecified indices are filled with zeroes. Indices may contain duplicate values and in this case, all of the corresponding values in Values are added together.  <a href="classglow_1_1_sparse_to_dense_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_splat_inst.html">SplatInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_splat_node.html">SplatNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a tensor of a specific type filled with '<a class="el" href="classglow_1_1_value.html">Value</a>'.Splat always keep floating point value internally but canquantize it based on the output type.  <a href="classglow_1_1_splat_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_stats_exporter.html">StatsExporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_stats_exporter_registry.html">StatsExporterRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry of StatsExporters.  <a href="classglow_1_1_stats_exporter_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_storage.html">Storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_str_check.html">StrCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sub_grad_node.html">SubGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_sub_node.html">SubNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Sub on the LHS and RHS operands.  <a href="classglow_1_1_sub_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tagged_list.html">TaggedList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tagged_list_node.html">TaggedListNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_tagged_list_traits.html">TaggedListTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tanh_grad_node.html">TanhGradNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tanh_inst.html">TanhInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tanh_node.html">TanhNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies hyperbolic tangent to each element in the Input tensor.  <a href="classglow_1_1_tanh_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a contiguous n-dimensional array (a tensor).  <a href="classglow_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor_pool.html">TensorPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_tensor_quantization_params.html">TensorQuantizationParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor_view_inst.html">TensorViewInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_thread_executor.html">ThreadExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that runs Tasks on a single thread.  <a href="classglow_1_1_thread_executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_thread_pool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool for asynchronous execution of generic functions.  <a href="classglow_1_1_thread_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tile_node.html">TileNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile an Input tensor Count times along Axis.  <a href="classglow_1_1_tile_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_top_k_inst.html">TopKInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_top_k_node.html">TopKNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the top K maximal elements for each vector in the tensor. Vectors are defined as the last dimension in the tensor. The input shape {D_0, D_1, ... D_n} results in the outputs {D_0, D_1, ... D_n-1, K}, sorted in non-decreasing order.  <a href="classglow_1_1_top_k_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_topological_sort_based_scheduler.html">TopologicalSortBasedScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_trace_context.html">TraceContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_trace_event.html">TraceEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_trace_event_inst.html">TraceEventInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_trace_event_node.html">TraceEventNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <a class="el" href="structglow_1_1_trace_event.html">TraceEvent</a> for profiling.  <a href="classglow_1_1_trace_event_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_trace_info.html">TraceInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_training_config.html">TrainingConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_transpose_inst.html">TransposeInst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_transpose_node.html">TransposeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the Input tensor based on the vector Shuffle, which assigns a new axis for each dimension in Input.  <a href="classglow_1_1_transpose_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a type of a tensor.  <a href="structglow_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_type_a_to_type_b_function_converter.html">TypeAToTypeBFunctionConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_typed.html">Typed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of this class have a type associated with them.  <a href="classglow_1_1_typed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglow_1_1_use.html">Use</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html">UseDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classglow_1_1_use_def.html" title="A UseDef is something that can be an operand for an instruction. ">UseDef</a> is something that can be an operand for an instruction.  <a href="classglow_1_1_use_def.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_value.html">Value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_value_uses.html">ValueUses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_weight_var.html">WeightVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_zip_reader.html">ZipReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip reader.  <a href="classglow_1_1_zip_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_zip_writer.html">ZipWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip Writer.  <a href="classglow_1_1_zip_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab1c5bff83b098172f4dd1c9ba869e353"><td class="memItemLeft" align="right" valign="top"><a id="ab1c5bff83b098172f4dd1c9ba869e353"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ContiguousPlaceholders</b> = std::vector&lt; <a class="el" href="structglow_1_1_placeholder_input_output_info.html">PlaceholderInputOutputInfo</a> &gt;</td></tr>
<tr class="separator:ab1c5bff83b098172f4dd1c9ba869e353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffc97cbc6f11ac585d36ce9b4bdd524"><td class="memItemLeft" align="right" valign="top"><a id="a5ffc97cbc6f11ac585d36ce9b4bdd524"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KindSet</b> = llvm::SmallSet&lt; Kinded::Kind, 4 &gt;</td></tr>
<tr class="separator:a5ffc97cbc6f11ac585d36ce9b4bdd524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c621decc80700e6f5197522c3a710b6"><td class="memItemLeft" align="right" valign="top"><a id="a9c621decc80700e6f5197522c3a710b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TypeRef</b> = const <a class="el" href="structglow_1_1_type.html">Type</a> *</td></tr>
<tr class="separator:a9c621decc80700e6f5197522c3a710b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca574644e1e42ef193a9947fb4d8911"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> = uint32_t</td></tr>
<tr class="separator:a0ca574644e1e42ef193a9947fb4d8911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d2b7b208b08479f97d30186bcaac1e"><td class="memItemLeft" align="right" valign="top"><a id="a21d2b7b208b08479f97d30186bcaac1e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>float16_t</b> = <a class="el" href="classglow_1_1float16.html">float16</a></td></tr>
<tr class="separator:a21d2b7b208b08479f97d30186bcaac1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a8882a5c68517141911de7bf6662e6"><td class="memItemLeft" align="right" valign="top"><a id="af9a8882a5c68517141911de7bf6662e6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ShapeVector</b> = llvm::SmallVector&lt; size_t, max_tensor_dimensions &gt;</td></tr>
<tr class="separator:af9a8882a5c68517141911de7bf6662e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d940b6582e442881018a0abfae6a17"><td class="memItemLeft" align="right" valign="top"><a id="ac9d940b6582e442881018a0abfae6a17"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TraceLevel</b> = <a class="el" href="structglow_1_1_trace_event.html#a10132a384d74408a112510cbe1b7d978">TraceEvent::TraceLevel</a></td></tr>
<tr class="separator:ac9d940b6582e442881018a0abfae6a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2abbc85bc7a268f9927afc6ee607f"><td class="memItemLeft" align="right" valign="top"><a id="a5ff2abbc85bc7a268f9927afc6ee607f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5ff2abbc85bc7a268f9927afc6ee607f">ReportedNodes</a> = std::unordered_set&lt; const <a class="el" href="classglow_1_1_node.html">Node</a> * &gt;</td></tr>
<tr class="memdesc:a5ff2abbc85bc7a268f9927afc6ee607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique set of visited nodes. <br /></td></tr>
<tr class="separator:a5ff2abbc85bc7a268f9927afc6ee607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4128b6e54c614a0a53265ffdce7073db"><td class="memItemLeft" align="right" valign="top"><a id="a4128b6e54c614a0a53265ffdce7073db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4128b6e54c614a0a53265ffdce7073db">TypesList</a> = std::list&lt; <a class="el" href="structglow_1_1_type.html">Type</a> &gt;</td></tr>
<tr class="memdesc:a4128b6e54c614a0a53265ffdce7073db"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Types. <br /></td></tr>
<tr class="separator:a4128b6e54c614a0a53265ffdce7073db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4919b7ef01548e927f0a5acb3a7400b9"><td class="memItemLeft" align="right" valign="top"><a id="a4919b7ef01548e927f0a5acb3a7400b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4919b7ef01548e927f0a5acb3a7400b9">NodesList</a> = llvm::iplist&lt; <a class="el" href="classglow_1_1_node.html">glow::Node</a> &gt;</td></tr>
<tr class="memdesc:a4919b7ef01548e927f0a5acb3a7400b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive list of Nodes. <br /></td></tr>
<tr class="separator:a4919b7ef01548e927f0a5acb3a7400b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ec79a2f9c485bfa999ed31fd0854dd"><td class="memItemLeft" align="right" valign="top"><a id="a40ec79a2f9c485bfa999ed31fd0854dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a40ec79a2f9c485bfa999ed31fd0854dd">NodesPtrList</a> = std::list&lt; <a class="el" href="classglow_1_1_node.html">glow::Node</a> * &gt;</td></tr>
<tr class="memdesc:a40ec79a2f9c485bfa999ed31fd0854dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of pointers to Nodes. The nodes are not owned by the list. <br /></td></tr>
<tr class="separator:a40ec79a2f9c485bfa999ed31fd0854dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6f350877931e8074457bbab671b5f"><td class="memItemLeft" align="right" valign="top"><a id="ae6f6f350877931e8074457bbab671b5f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ae6f6f350877931e8074457bbab671b5f">FunctionList</a> = std::list&lt; <a class="el" href="classglow_1_1_function.html">Function</a> * &gt;</td></tr>
<tr class="memdesc:ae6f6f350877931e8074457bbab671b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Functions. <br /></td></tr>
<tr class="separator:ae6f6f350877931e8074457bbab671b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72abfcd0a98a0493b2a86803a39331ae"><td class="memItemLeft" align="right" valign="top"><a id="a72abfcd0a98a0493b2a86803a39331ae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstList</b> = std::list&lt; <a class="el" href="classglow_1_1_constant.html">Constant</a> * &gt;</td></tr>
<tr class="separator:a72abfcd0a98a0493b2a86803a39331ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327eb2a1f49bd08fcbdd467b54f4f076"><td class="memItemLeft" align="right" valign="top"><a id="a327eb2a1f49bd08fcbdd467b54f4f076"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PlaceholderList</b> = std::list&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt;</td></tr>
<tr class="separator:a327eb2a1f49bd08fcbdd467b54f4f076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162f58aa7c2d2d5adeb5644d90763c00"><td class="memItemLeft" align="right" valign="top"><a id="a162f58aa7c2d2d5adeb5644d90763c00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnsignedArrayRef</b> = llvm::ArrayRef&lt; size_t &gt;</td></tr>
<tr class="separator:a162f58aa7c2d2d5adeb5644d90763c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe305f16778f20f331d6b2016221a756"><td class="memItemLeft" align="right" valign="top"><a id="afe305f16778f20f331d6b2016221a756"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afe305f16778f20f331d6b2016221a756">NodeMap</a> = llvm::DenseMap&lt; <a class="el" href="classglow_1_1_node.html">Node</a> *, <a class="el" href="classglow_1_1_node.html">Node</a> * &gt;</td></tr>
<tr class="memdesc:afe305f16778f20f331d6b2016221a756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from original Nodes to cloned Nodes. <br /></td></tr>
<tr class="separator:afe305f16778f20f331d6b2016221a756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b70bdd9c7f0b464aab1f5052ba32f"><td class="memItemLeft" align="right" valign="top"><a id="ac90b70bdd9c7f0b464aab1f5052ba32f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VariableGradientsList</b> = std::list&lt; std::pair&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *, <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt; &gt;</td></tr>
<tr class="separator:ac90b70bdd9c7f0b464aab1f5052ba32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f95b663529f09dd2ec740fa7de7651"><td class="memItemLeft" align="right" valign="top"><a id="a27f95b663529f09dd2ec740fa7de7651"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeValueIterator</b> = <a class="el" href="classglow_1_1_node_value_iterator_impl.html">NodeValueIteratorImpl</a>&lt; false &gt;</td></tr>
<tr class="separator:a27f95b663529f09dd2ec740fa7de7651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85803b3c7a157b062a37bc07816963a1"><td class="memItemLeft" align="right" valign="top"><a id="a85803b3c7a157b062a37bc07816963a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeValueConstIterator</b> = <a class="el" href="classglow_1_1_node_value_iterator_impl.html">NodeValueIteratorImpl</a>&lt; true &gt;</td></tr>
<tr class="separator:a85803b3c7a157b062a37bc07816963a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fbdb5f438570d27e0c0b661b58b03e"><td class="memItemLeft" align="right" valign="top"><a id="a29fbdb5f438570d27e0c0b661b58b03e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndicesSet</b> = std::unordered_set&lt; unsigned &gt;</td></tr>
<tr class="separator:a29fbdb5f438570d27e0c0b661b58b03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94ce06bbb6343779020891e28a7058"><td class="memItemLeft" align="right" valign="top"><a id="a2e94ce06bbb6343779020891e28a7058"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>InstructionOperand</b> = std::pair&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, OperandKind &gt;</td></tr>
<tr class="separator:a2e94ce06bbb6343779020891e28a7058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0dc15599ae28d8556999c9cf2a2643"><td class="memItemLeft" align="right" valign="top"><a id="afe0dc15599ae28d8556999c9cf2a2643"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstInstructionOperand</b> = const std::pair&lt; const <a class="el" href="classglow_1_1_value.html">Value</a> *, OperandKind &gt;</td></tr>
<tr class="separator:afe0dc15599ae28d8556999c9cf2a2643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49ee75ee62d0543c929b88397878709"><td class="memItemLeft" align="right" valign="top"><a id="ab49ee75ee62d0543c929b88397878709"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab49ee75ee62d0543c929b88397878709">InstrIterator</a> = <a class="el" href="classglow_1_1tagged__list__details_1_1_iterator.html">IRFunction::InstrIterator</a></td></tr>
<tr class="memdesc:ab49ee75ee62d0543c929b88397878709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over inteructions. <br /></td></tr>
<tr class="separator:ab49ee75ee62d0543c929b88397878709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cab7bdf4a5e1c4a1857b205e81b9b2"><td class="memItemLeft" align="right" valign="top"><a id="a91cab7bdf4a5e1c4a1857b205e81b9b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>InstrConstIterator</b> = <a class="el" href="classglow_1_1tagged__list__details_1_1_iterator.html">IRFunction::InstrConstIterator</a></td></tr>
<tr class="separator:a91cab7bdf4a5e1c4a1857b205e81b9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b10fbca9c94f2c0d66386145e9b9d2b"><td class="memItemLeft" align="right" valign="top"><a id="a4b10fbca9c94f2c0d66386145e9b9d2b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuantizationMode</b> = <a class="el" href="structglow_1_1_precision_configuration.html#a9a40e5e2126e4c6f3e8fe3bab25ff12c">PrecisionConfiguration::QuantizationMode</a></td></tr>
<tr class="separator:a4b10fbca9c94f2c0d66386145e9b9d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a5ab10dc4435c6c8ba69a4b279d4b"><td class="memItemLeft" align="right" valign="top"><a id="ad80a5ab10dc4435c6c8ba69a4b279d4b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CompilationMode</b> = <a class="el" href="structglow_1_1_compilation_context.html#a92efb87746c0edf7756b84fdcd87014a">CompilationContext::CompilationMode</a></td></tr>
<tr class="separator:ad80a5ab10dc4435c6c8ba69a4b279d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc0e338408955f80a23cc7e0c0c82e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a32fc0e338408955f80a23cc7e0c0c82e">TensorInitializer</a> = std::function&lt; void(<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="classglow_1_1_node.html">Node</a> *node, unsigned inputIdx, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *tensor)&gt;</td></tr>
<tr class="separator:a32fc0e338408955f80a23cc7e0c0c82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad640073dcff44c25b1819e1cb420f701"><td class="memItemLeft" align="right" valign="top"><a id="ad640073dcff44c25b1819e1cb420f701"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodesSet</b> = std::set&lt; <a class="el" href="classglow_1_1_node.html">Node</a> * &gt;</td></tr>
<tr class="separator:ad640073dcff44c25b1819e1cb420f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e8d2f34b0b5876fd4f7abaf0a0d73d"><td class="memItemLeft" align="right" valign="top"><a id="a03e8d2f34b0b5876fd4f7abaf0a0d73d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a03e8d2f34b0b5876fd4f7abaf0a0d73d">BFSLevel</a> = std::vector&lt; std::vector&lt; <a class="el" href="classglow_1_1_node.html">Node</a> * &gt; &gt;</td></tr>
<tr class="memdesc:a03e8d2f34b0b5876fd4f7abaf0a0d73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of &lt;nodelist&gt; with BFS order. <br /></td></tr>
<tr class="separator:a03e8d2f34b0b5876fd4f7abaf0a0d73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872f72bd7c5e2f8cdc494b659b0b84c4"><td class="memItemLeft" align="right" valign="top"><a id="a872f72bd7c5e2f8cdc494b659b0b84c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FunctionToNodesMap</b> = std::map&lt; <a class="el" href="classglow_1_1_function.html">Function</a> *, NodesSet, <a class="el" href="structglow_1_1_function_name_comparator.html">FunctionNameComparator</a> &gt;</td></tr>
<tr class="separator:a872f72bd7c5e2f8cdc494b659b0b84c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c1a2b21677ddb0baeaff2029675698"><td class="memItemLeft" align="right" valign="top"><a id="a37c1a2b21677ddb0baeaff2029675698"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FunctionToBackendNameMap</b> = std::map&lt; <a class="el" href="classglow_1_1_function.html">Function</a> *, std::string, <a class="el" href="structglow_1_1_function_name_comparator.html">FunctionNameComparator</a> &gt;</td></tr>
<tr class="separator:a37c1a2b21677ddb0baeaff2029675698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419aca63ca48becda137d774dd06493c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a419aca63ca48becda137d774dd06493c">LoweredInfoMap</a> = llvm::StringMap&lt; std::set&lt; <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> &gt; &gt;</td></tr>
<tr class="separator:a419aca63ca48becda137d774dd06493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb176c3a672ef66db0ecfc19a8d39bf"><td class="memItemLeft" align="right" valign="top"><a id="afdb176c3a672ef66db0ecfc19a8d39bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> = <a class="el" href="classglow_1_1detail_1_1_glow_error.html">detail::GlowError</a></td></tr>
<tr class="memdesc:afdb176c3a672ef66db0ecfc19a8d39bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structglow_1_1_type.html" title="A class that represents a type of a tensor. ">Type</a> aliases to decouple Error and Expected from underlying implementation. <br /></td></tr>
<tr class="separator:afdb176c3a672ef66db0ecfc19a8d39bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ac4a89f32c03c5721dce8c26d826c1"><td class="memItemLeft" align="right" valign="top"><a id="a19ac4a89f32c03c5721dce8c26d826c1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ErrorSuccess</b> = <a class="el" href="classglow_1_1detail_1_1_glow_error_success.html">detail::GlowErrorSuccess</a></td></tr>
<tr class="separator:a19ac4a89f32c03c5721dce8c26d826c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5d74fc12bce2a8d3e50f8b50322e8"><td class="memItemLeft" align="right" valign="top"><a id="a1bf5d74fc12bce2a8d3e50f8b50322e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ErrorEmpty</b> = <a class="el" href="classglow_1_1detail_1_1_glow_error_empty.html">detail::GlowErrorEmpty</a></td></tr>
<tr class="separator:a1bf5d74fc12bce2a8d3e50f8b50322e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9342b33e8382dfa77f9f36abf16776de"><td class="memItemLeft" align="right" valign="top"><a id="a9342b33e8382dfa77f9f36abf16776de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ErrorValue</b> = <a class="el" href="classglow_1_1detail_1_1_glow_error_value.html">detail::GlowErrorValue</a></td></tr>
<tr class="separator:a9342b33e8382dfa77f9f36abf16776de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d81236adc8a9b6e32f0b1244d094ad8"><td class="memTemplParams" colspan="2"><a id="a7d81236adc8a9b6e32f0b1244d094ad8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d81236adc8a9b6e32f0b1244d094ad8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Expected</b> = <a class="el" href="classglow_1_1detail_1_1_glow_expected.html">detail::GlowExpected</a>&lt; T &gt;</td></tr>
<tr class="separator:a7d81236adc8a9b6e32f0b1244d094ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c68d23f8def44c72bbab5ee153bb7"><td class="memItemLeft" align="right" valign="top"><a id="aef6c68d23f8def44c72bbab5ee153bb7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aef6c68d23f8def44c72bbab5ee153bb7">Float16Storage</a> = uint16_t</td></tr>
<tr class="memdesc:aef6c68d23f8def44c72bbab5ee153bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structglow_1_1_use.html">Use</a> a proxy type in case we need to change it in the future. <br /></td></tr>
<tr class="separator:aef6c68d23f8def44c72bbab5ee153bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0b05ad621e4c545de25546f7093b81"><td class="memItemLeft" align="right" valign="top"><a id="a2e0b05ad621e4c545de25546f7093b81"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ManualEventMap</b> = std::map&lt; std::string, std::pair&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *, const <a class="el" href="structglow_1_1_trace_info_1_1_event.html">TraceInfo::Event</a> * &gt; &gt;</td></tr>
<tr class="separator:a2e0b05ad621e4c545de25546f7093b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af836699afb1d36a88df0d50d74fde931"><td class="memItemLeft" align="right" valign="top"><a id="af836699afb1d36a88df0d50d74fde931"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a> { <b>kneg1to1</b>, 
<b>k0to1</b>, 
<b>k0to255</b>, 
<b>kneg128to127</b>
 }<tr class="memdesc:af836699afb1d36a88df0d50d74fde931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel value ranges. <br /></td></tr>
</td></tr>
<tr class="separator:af836699afb1d36a88df0d50d74fde931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c384b9844d09e4dd277eb509728dce"><td class="memItemLeft" align="right" valign="top"><a id="a06c384b9844d09e4dd277eb509728dce"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a> { <b>NCHW</b>, 
<b>NHWC</b>
 }<tr class="memdesc:a06c384b9844d09e4dd277eb509728dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layout of image dimensions (batch, channels, height, width). <br /></td></tr>
</td></tr>
<tr class="separator:a06c384b9844d09e4dd277eb509728dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747942676633510584a944637b8eb59"><td class="memItemLeft" align="right" valign="top"><a id="a2747942676633510584a944637b8eb59"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a> { <b>BGR</b>, 
<b>RGB</b>
 }<tr class="memdesc:a2747942676633510584a944637b8eb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of color channels (red, green, blue). <br /></td></tr>
</td></tr>
<tr class="separator:a2747942676633510584a944637b8eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92e14a94329daf4083db670e95fbcdf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> : unsigned char { <br />
&#160;&#160;<b>FloatTy</b>, 
<b>Float16Ty</b>, 
<b>Int8QTy</b>, 
<b>UInt8QTy</b>, 
<br />
&#160;&#160;<b>Int16QTy</b>, 
<b>Int32QTy</b>, 
<b>Int32ITy</b>, 
<b>Int64ITy</b>, 
<br />
&#160;&#160;<b>UInt8FusedQTy</b>, 
<b>UInt8FusedFP16QTy</b>, 
<b>UInt4FusedFP16QTy</b>, 
<b>BoolTy</b>
<br />
 }</td></tr>
<tr class="separator:ab92e14a94329daf4083db670e95fbcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98da7214165b41c7d6b255503d4062"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a1c98da7214165b41c7d6b255503d4062">FunctionState</a> { <a class="el" href="namespaceglow.html#a1c98da7214165b41c7d6b255503d4062a3c96962620eddda2836d6203cf7ecfa0">FunctionState::FuncCreated</a>, 
<a class="el" href="namespaceglow.html#a1c98da7214165b41c7d6b255503d4062ae25a0b7e15a925b8bf4d8016db8d27ac">FunctionState::FuncLoaded</a>
 }</td></tr>
<tr class="separator:a1c98da7214165b41c7d6b255503d4062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787f9659e35f7ac9a80cc9f3338fe7ea"><td class="memItemLeft" align="right" valign="top"><a id="a787f9659e35f7ac9a80cc9f3338fe7ea"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a787f9659e35f7ac9a80cc9f3338fe7ea">PaddingMode</a> { <b>CONSTANT</b> = 0, 
<b>REFLECT</b>, 
<b>EDGE</b>
 }<tr class="memdesc:a787f9659e35f7ac9a80cc9f3338fe7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modes of the padding operation. <br /></td></tr>
</td></tr>
<tr class="separator:a787f9659e35f7ac9a80cc9f3338fe7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f3a33e05699df0f42295c5c4bd1f77"><td class="memItemLeft" align="right" valign="top"><a id="aa2f3a33e05699df0f42295c5c4bd1f77"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> { <b>NHWC</b> = 0, 
<b>NHWC</b>, 
<b>NCHW</b>, 
<b>NCHW</b>
 }<tr class="memdesc:aa2f3a33e05699df0f42295c5c4bd1f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution Layouts. <br /></td></tr>
</td></tr>
<tr class="separator:aa2f3a33e05699df0f42295c5c4bd1f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f2cc9ccac93130ee1cc326d968a21"><td class="memItemLeft" align="right" valign="top"><a id="ae88f2cc9ccac93130ee1cc326d968a21"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ae88f2cc9ccac93130ee1cc326d968a21">FusedActivation</a> { <b>NONE</b> = 0, 
<b>RELU</b>, 
<b>TANH</b>, 
<b>SIGMOID</b>
 }<tr class="memdesc:ae88f2cc9ccac93130ee1cc326d968a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activations fused into ConvolutionNode (not supported on all backends). <br /></td></tr>
</td></tr>
<tr class="separator:ae88f2cc9ccac93130ee1cc326d968a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac310df6cfbec51a38b1cc46d1586eedc"><td class="memItemLeft" align="right" valign="top"><a id="ac310df6cfbec51a38b1cc46d1586eedc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>OperandKind</b> : unsigned char { <b>In</b>, 
<b>InOut</b>, 
<b>Out</b>
 }</td></tr>
<tr class="separator:ac310df6cfbec51a38b1cc46d1586eedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04a18d4367765236e5de54c47379e66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab04a18d4367765236e5de54c47379e66">MemoryAreaKind</a> { <b>ConstWeightsMemoryArea</b>, 
<b>MutableWeightsMemoryArea</b>, 
<b>ActivationsMemoryArea</b>, 
<b>LastMemoryArea</b>
 }</td></tr>
<tr class="separator:ab04a18d4367765236e5de54c47379e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3157945b92abd634c79fa9d4724472eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a3157945b92abd634c79fa9d4724472eb">FunctionPassID</a> { <b>FUN_PASS</b>
 }</td></tr>
<tr class="separator:a3157945b92abd634c79fa9d4724472eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56845b9c860fa69d01d2084361d7c1f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a56845b9c860fa69d01d2084361d7c1f0">ConvergenceMode</a> { <a class="el" href="namespaceglow.html#a56845b9c860fa69d01d2084361d7c1f0accd4cef52fe08da3eeac0e4396a2aca2">ConvergenceMode::OnePass</a>, 
<a class="el" href="namespaceglow.html#a56845b9c860fa69d01d2084361d7c1f0a1a3fe1603e0a452b098a101b7d833f87">ConvergenceMode::UntilFixedPoint</a>
 }<tr class="memdesc:a56845b9c860fa69d01d2084361d7c1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies convergence mode for a FunctionPass.  <a href="namespaceglow.html#a56845b9c860fa69d01d2084361d7c1f0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a56845b9c860fa69d01d2084361d7c1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b85539f22b3e3292adf202254f0da1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a6b85539f22b3e3292adf202254f0da1e">DCERequiredMode</a> { <a class="el" href="namespaceglow.html#a6b85539f22b3e3292adf202254f0da1eaff7ad7af6ac42e36a5d538e74cde072d">DCERequiredMode::BeforePass</a>, 
<a class="el" href="namespaceglow.html#a6b85539f22b3e3292adf202254f0da1ea6adf97f83acf6453d4a6a4b1070f3754">DCERequiredMode::None</a>
 }<tr class="memdesc:a6b85539f22b3e3292adf202254f0da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the pass requires DCE.  <a href="namespaceglow.html#a6b85539f22b3e3292adf202254f0da1e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6b85539f22b3e3292adf202254f0da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b11a9c44f948717d6a886891a58b11"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af5b11a9c44f948717d6a886891a58b11">SchedulerKind</a> { <a class="el" href="namespaceglow.html#af5b11a9c44f948717d6a886891a58b11aca8f7fd5d3a60fdbaaa2f584621c7759">SchedulerKind::ChildMemSizeBased</a>, 
<a class="el" href="namespaceglow.html#af5b11a9c44f948717d6a886891a58b11afc2c746e636936c8ce50270012da3147">SchedulerKind::TopologicalSortBased</a>
 }<tr class="memdesc:af5b11a9c44f948717d6a886891a58b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the kind of graph scheduling to perform.  <a href="namespaceglow.html#af5b11a9c44f948717d6a886891a58b11">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af5b11a9c44f948717d6a886891a58b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9cd2773ca12798a14e44f6f57c2ee826"><td class="memItemLeft" align="right" valign="top"><a id="a9cd2773ca12798a14e44f6f57c2ee826"></a>
<a class="el" href="classglow_1_1_backend.html">Backend</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a9cd2773ca12798a14e44f6f57c2ee826">createBackend</a> (llvm::StringRef backendName)</td></tr>
<tr class="memdesc:a9cd2773ca12798a14e44f6f57c2ee826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a backend based on the registered backend name <code>backendName</code>. <br /></td></tr>
<tr class="separator:a9cd2773ca12798a14e44f6f57c2ee826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18ed78d6c309a7061f1b1318b9d8aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af18ed78d6c309a7061f1b1318b9d8aca">isOutput</a> (const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH, const <a class="el" href="classglow_1_1_function.html">Function</a> &amp;F)</td></tr>
<tr class="separator:af18ed78d6c309a7061f1b1318b9d8aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc28cae078d0b91e0bda921554f3ae6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afbc28cae078d0b91e0bda921554f3ae6">isInput</a> (const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH, const <a class="el" href="classglow_1_1_function.html">Function</a> &amp;F)</td></tr>
<tr class="memdesc:afbc28cae078d0b91e0bda921554f3ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>PH</code> is an input placeholder,.  <a href="#afbc28cae078d0b91e0bda921554f3ae6">More...</a><br /></td></tr>
<tr class="separator:afbc28cae078d0b91e0bda921554f3ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7a54e3291e2de0fa2c08e14cf1f36b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5a7a54e3291e2de0fa2c08e14cf1f36b">isOutput</a> (const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH, const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &amp;F)</td></tr>
<tr class="separator:a5a7a54e3291e2de0fa2c08e14cf1f36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb98192dd9bfc2315759db1806f01ad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#acb98192dd9bfc2315759db1806f01ad1">isInput</a> (const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH, const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &amp;F)</td></tr>
<tr class="memdesc:acb98192dd9bfc2315759db1806f01ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>PH</code> is an input placeholder in the function <code>F</code>,.  <a href="#acb98192dd9bfc2315759db1806f01ad1">More...</a><br /></td></tr>
<tr class="separator:acb98192dd9bfc2315759db1806f01ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab310f352073eee80ddb68b3cfaa14e12"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt;!has_getFusedActivation&lt; T, FusedActivation &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab310f352073eee80ddb68b3cfaa14e12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab310f352073eee80ddb68b3cfaa14e12">checkNoFusion</a> (const T &amp;N)</td></tr>
<tr class="memdesc:ab310f352073eee80ddb68b3cfaa14e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>N</code> does not have fused activation.  <a href="#ab310f352073eee80ddb68b3cfaa14e12">More...</a><br /></td></tr>
<tr class="separator:ab310f352073eee80ddb68b3cfaa14e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca93d79211ec0bc67ed8524634e69a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad4ca93d79211ec0bc67ed8524634e69a">checkNoFusionForNode</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;N)</td></tr>
<tr class="memdesc:ad4ca93d79211ec0bc67ed8524634e69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>N</code> does not have fused activation.  <a href="#ad4ca93d79211ec0bc67ed8524634e69a">More...</a><br /></td></tr>
<tr class="separator:ad4ca93d79211ec0bc67ed8524634e69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740e326204223c25d80b8b07e99dac18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a740e326204223c25d80b8b07e99dac18">checkNoFusionForInstr</a> (const <a class="el" href="classglow_1_1_instruction.html">Instruction</a> &amp;I)</td></tr>
<tr class="memdesc:a740e326204223c25d80b8b07e99dac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>I</code> does not have fused activation.  <a href="#a740e326204223c25d80b8b07e99dac18">More...</a><br /></td></tr>
<tr class="separator:a740e326204223c25d80b8b07e99dac18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81027b5844dd48c60ba42e8169f19c2"><td class="memTemplParams" colspan="2">template&lt;typename FUN , typename ARR &gt; </td></tr>
<tr class="memitem:ac81027b5844dd48c60ba42e8169f19c2"><td class="memTemplItemLeft" align="right" valign="top">ContiguousPlaceholders&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ac81027b5844dd48c60ba42e8169f19c2">getContiguousPlaceHolder</a> (const ARR &amp;holders, const FUN &amp;F)</td></tr>
<tr class="separator:ac81027b5844dd48c60ba42e8169f19c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277fade8bad1b16fc8c084ce52ba6f92"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a277fade8bad1b16fc8c084ce52ba6f92">convertConvGradToNCHWConvGrad</a> (<a class="el" href="classglow_1_1_convolution_grad_node.html">ConvolutionGradNode</a> *CGN, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:a277fade8bad1b16fc8c084ce52ba6f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac40bd989fd3bcb403ecfbf8c120600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aeac40bd989fd3bcb403ecfbf8c120600">convertConvToNCHWConv</a> (<a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> *CN, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:aeac40bd989fd3bcb403ecfbf8c120600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b90e6ec31547354c4e796d906cebd0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classglow_1_1_node.html">Node</a> *, <a class="el" href="classglow_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a67b90e6ec31547354c4e796d906cebd0">convertMaxPoolToNCHWPool</a> (<a class="el" href="classglow_1_1_max_pool_node.html">MaxPoolNode</a> *PN, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:a67b90e6ec31547354c4e796d906cebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b1618bc713e16d13254ae32174ea5"><td class="memItemLeft" align="right" valign="top"><a id="a2f2b1618bc713e16d13254ae32174ea5"></a>
<a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>convertMaxPoolGradToNCHWPool</b> (<a class="el" href="classglow_1_1_max_pool_grad_node.html">MaxPoolGradNode</a> *PGN, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:a2f2b1618bc713e16d13254ae32174ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8026f99cd2e11a8470cd308c4ee9fb"><td class="memItemLeft" align="right" valign="top"><a id="a6f8026f99cd2e11a8470cd308c4ee9fb"></a>
<a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>convertAvgPoolToNCHWPool</b> (<a class="el" href="classglow_1_1_avg_pool_node.html">AvgPoolNode</a> *PN, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:a6f8026f99cd2e11a8470cd308c4ee9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde6a998376eec40dbaaa3f5c0678dfa"><td class="memItemLeft" align="right" valign="top"><a id="acde6a998376eec40dbaaa3f5c0678dfa"></a>
<a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>convertAvgPoolGradToNCHWPool</b> (<a class="el" href="classglow_1_1_avg_pool_grad_node.html">AvgPoolGradNode</a> *PGN, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:acde6a998376eec40dbaaa3f5c0678dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300f3c7eeb3e5ee04d177a2acc6ac4db"><td class="memItemLeft" align="right" valign="top">std::pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a300f3c7eeb3e5ee04d177a2acc6ac4db">normModeToRange</a> (<a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a> mode)</td></tr>
<tr class="memdesc:a300f3c7eeb3e5ee04d177a2acc6ac4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the normalization to numeric floating poing ranges.  <a href="#a300f3c7eeb3e5ee04d177a2acc6ac4db">More...</a><br /></td></tr>
<tr class="separator:a300f3c7eeb3e5ee04d177a2acc6ac4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a01d4f862cb83ad8979bfa1c5794930"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; size_t, size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a8a01d4f862cb83ad8979bfa1c5794930">getPngInfo</a> (const char *filename)</td></tr>
<tr class="separator:a8a01d4f862cb83ad8979bfa1c5794930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bf5dcbdf3e69fcee124d73bc4ecace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a23bf5dcbdf3e69fcee124d73bc4ecace">readPngImage</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T, const char *filename, std::pair&lt; float, float &gt; range, llvm::ArrayRef&lt; float &gt; mean=zeroMean, llvm::ArrayRef&lt; float &gt; stddev=oneStd)</td></tr>
<tr class="separator:a23bf5dcbdf3e69fcee124d73bc4ecace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb0a7a5b75a41f5ba57843e7f242338"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#acfb0a7a5b75a41f5ba57843e7f242338">writePngImage</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T, const char *filename, std::pair&lt; float, float &gt; range, llvm::ArrayRef&lt; float &gt; mean=zeroMean, llvm::ArrayRef&lt; float &gt; stddev=oneStd)</td></tr>
<tr class="separator:acfb0a7a5b75a41f5ba57843e7f242338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05ae0a1df66d2a01e935bcfa21e1874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aa05ae0a1df66d2a01e935bcfa21e1874">readPngImageAndPreprocess</a> (llvm::StringRef filename, <a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a> <a class="el" href="namespaceglow.html#ad1aa614344d723c1b14942f55e0a92b4">imageNormMode</a>, <a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a> <a class="el" href="namespaceglow.html#a3f89e6d465a90abbf0dd62935035c1de">imageChannelOrder</a>, <a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a> <a class="el" href="namespaceglow.html#a53107002ac2c9f4c49145ee80843a1da">imageLayout</a>, llvm::ArrayRef&lt; float &gt; mean=zeroMean, llvm::ArrayRef&lt; float &gt; stddev=oneStd)</td></tr>
<tr class="separator:aa05ae0a1df66d2a01e935bcfa21e1874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4355b249e26c8744ca54250df4d12f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4355b249e26c8744ca54250df4d12f89">readPngImageAndPreprocess</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;imageData, llvm::StringRef filename, <a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a> <a class="el" href="namespaceglow.html#ad1aa614344d723c1b14942f55e0a92b4">imageNormMode</a>, <a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a> <a class="el" href="namespaceglow.html#a3f89e6d465a90abbf0dd62935035c1de">imageChannelOrder</a>, <a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a> <a class="el" href="namespaceglow.html#a53107002ac2c9f4c49145ee80843a1da">imageLayout</a>, llvm::ArrayRef&lt; float &gt; mean=zeroMean, llvm::ArrayRef&lt; float &gt; stddev=oneStd)</td></tr>
<tr class="separator:a4355b249e26c8744ca54250df4d12f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f1717e58e71e730005473efae8c91a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ae5f1717e58e71e730005473efae8c91a">loadImagesAndPreprocess</a> (const llvm::ArrayRef&lt; std::string &gt; &amp;filenames, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *inputImageData, <a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a> <a class="el" href="namespaceglow.html#ad1aa614344d723c1b14942f55e0a92b4">imageNormMode</a>, <a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a> <a class="el" href="namespaceglow.html#a3f89e6d465a90abbf0dd62935035c1de">imageChannelOrder</a>, <a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a> <a class="el" href="namespaceglow.html#a53107002ac2c9f4c49145ee80843a1da">imageLayout</a>)</td></tr>
<tr class="separator:ae5f1717e58e71e730005473efae8c91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5605652aaef5081976134120c3dcd4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5605652aaef5081976134120c3dcd4d5">writeToFile</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;T, llvm::StringRef filename)</td></tr>
<tr class="separator:a5605652aaef5081976134120c3dcd4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327fb998231805cf69b6753e763e683f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a327fb998231805cf69b6753e763e683f">readFromFile</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;T, llvm::StringRef filename)</td></tr>
<tr class="separator:a327fb998231805cf69b6753e763e683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3450f4f150909deaf8e5939537d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a44d3450f4f150909deaf8e5939537d51">genericTranspose</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *src, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *dest, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; shuffle)</td></tr>
<tr class="separator:a44d3450f4f150909deaf8e5939537d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384dccb23b7bc3ade84b8f5c64b1f136"><td class="memItemLeft" align="right" valign="top">ShapeVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a384dccb23b7bc3ade84b8f5c64b1f136">expandDimsToMax</a> (llvm::ArrayRef&lt; size_t &gt; currDims)</td></tr>
<tr class="separator:a384dccb23b7bc3ade84b8f5c64b1f136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649c3f6ae28e295be486fb5917a8d885"><td class="memItemLeft" align="right" valign="top"><a id="a649c3f6ae28e295be486fb5917a8d885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpAsciiImpl</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T, llvm::raw_ostream &amp;os)</td></tr>
<tr class="separator:a649c3f6ae28e295be486fb5917a8d885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb053ad1d1927c2af92cf37b53682c8d"><td class="memItemLeft" align="right" valign="top"><a id="adb053ad1d1927c2af92cf37b53682c8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpAsciiImpl</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T)</td></tr>
<tr class="separator:adb053ad1d1927c2af92cf37b53682c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c48cfb635307b862968dc772c85369"><td class="memItemLeft" align="right" valign="top"><a id="a96c48cfb635307b862968dc772c85369"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpImpl</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T, llvm::raw_ostream &amp;os, unsigned maxNumElem=MAX_DUMP_ELEMS)</td></tr>
<tr class="separator:a96c48cfb635307b862968dc772c85369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3020f7d0d4e127202551ea4d6d5f18"><td class="memItemLeft" align="right" valign="top"><a id="a2c3020f7d0d4e127202551ea4d6d5f18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpImpl</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T, unsigned maxNumElem)</td></tr>
<tr class="separator:a2c3020f7d0d4e127202551ea4d6d5f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360ade90e7b5a953f3ecd3843e502dbb"><td class="memItemLeft" align="right" valign="top"><a id="a360ade90e7b5a953f3ecd3843e502dbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpImpl</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T)</td></tr>
<tr class="separator:a360ade90e7b5a953f3ecd3843e502dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad1c389473834361bddd094fa014da5"><td class="memItemLeft" align="right" valign="top"><a id="a7ad1c389473834361bddd094fa014da5"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;t)</td></tr>
<tr class="separator:a7ad1c389473834361bddd094fa014da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06a31226910e776a2134f48daebdc1"><td class="memItemLeft" align="right" valign="top"><a id="a9c06a31226910e776a2134f48daebdc1"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *t)</td></tr>
<tr class="separator:a9c06a31226910e776a2134f48daebdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d2c5f23a3db76b44bbf76e2d41f60d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a47d2c5f23a3db76b44bbf76e2d41f60d">flattenCdr</a> (llvm::ArrayRef&lt; size_t &gt; dims, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> n=1)</td></tr>
<tr class="separator:a47d2c5f23a3db76b44bbf76e2d41f60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8f76ee6a51f702ae0c3842b09f740"><td class="memItemLeft" align="right" valign="top"><a id="aade8f76ee6a51f702ae0c3842b09f740"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structglow_1_1_shape_n_h_w_c.html">ShapeNHWC</a> &amp;LHS, const <a class="el" href="structglow_1_1_shape_n_h_w_c.html">ShapeNHWC</a> &amp;RHS)</td></tr>
<tr class="separator:aade8f76ee6a51f702ae0c3842b09f740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9744bfd19e6cb92b7704a46eafe2e8"><td class="memItemLeft" align="right" valign="top"><a id="a8c9744bfd19e6cb92b7704a46eafe2e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structglow_1_1_shape_n_c_h_w.html">ShapeNCHW</a> &amp;LHS, const <a class="el" href="structglow_1_1_shape_n_c_h_w.html">ShapeNCHW</a> &amp;RHS)</td></tr>
<tr class="separator:a8c9744bfd19e6cb92b7704a46eafe2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652773bb012a43c21f460b9d110e1f63"><td class="memItemLeft" align="right" valign="top"><a id="a652773bb012a43c21f460b9d110e1f63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structglow_1_1_shape_n_h_w_d_c.html">ShapeNHWDC</a> &amp;LHS, const <a class="el" href="structglow_1_1_shape_n_h_w_d_c.html">ShapeNHWDC</a> &amp;RHS)</td></tr>
<tr class="separator:a652773bb012a43c21f460b9d110e1f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fc7f0b501763e06363d035e472238c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a67fc7f0b501763e06363d035e472238c">isQuantizedElemKind</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> e)</td></tr>
<tr class="separator:a67fc7f0b501763e06363d035e472238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea823a4b44883f04b3cd7ba5eebb9ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aeea823a4b44883f04b3cd7ba5eebb9ef">isFusedQuantizedElemKind</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> e)</td></tr>
<tr class="separator:aeea823a4b44883f04b3cd7ba5eebb9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee7b49ad6e84bdb1a42ac3e5bff797e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aaee7b49ad6e84bdb1a42ac3e5bff797e">getScaleOffsetElemKindFromFused</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> e)</td></tr>
<tr class="separator:aaee7b49ad6e84bdb1a42ac3e5bff797e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd8ccc93a8963092c57a669d6035a0"><td class="memItemLeft" align="right" valign="top"><a id="a9abd8ccc93a8963092c57a669d6035a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;LHS, const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;RHS)</td></tr>
<tr class="separator:a9abd8ccc93a8963092c57a669d6035a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6e7356de0d3ed109bc3b95d9753d8d"><td class="memItemLeft" align="right" valign="top"><a id="a0e6e7356de0d3ed109bc3b95d9753d8d"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="separator:a0e6e7356de0d3ed109bc3b95d9753d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef265ed4d4604e471d8b5662c3f5a423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aef265ed4d4604e471d8b5662c3f5a423">convertFunctionToFloat16</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, const <a class="el" href="structglow_1_1_precision_configuration.html">PrecisionConfiguration</a> &amp;precConfig)</td></tr>
<tr class="separator:aef265ed4d4604e471d8b5662c3f5a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24661dfe4d11f5c1cf0db592389a43fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a24661dfe4d11f5c1cf0db592389a43fc">updateInputPlaceholders</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt; ph, llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&gt; inputs)</td></tr>
<tr class="separator:a24661dfe4d11f5c1cf0db592389a43fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe843dcf46487faf7eecfb58d8e15c04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afe843dcf46487faf7eecfb58d8e15c04">updateInputPlaceholdersByName</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, <a class="el" href="classglow_1_1_module.html">Module</a> *mod, llvm::ArrayRef&lt; llvm::StringRef &gt; ph, llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&gt; inputs)</td></tr>
<tr class="separator:afe843dcf46487faf7eecfb58d8e15c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7264d309f534807df9015c8bccda87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a2d7264d309f534807df9015c8bccda87">runBatch</a> (<a class="el" href="classglow_1_1_execution_engine.html">ExecutionEngine</a> &amp;EE, <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, size_t iterations, size_t &amp;sampleCounter, llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt; ph, llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&gt; inputs, llvm::StringRef name=&quot;&quot;)</td></tr>
<tr class="separator:a2d7264d309f534807df9015c8bccda87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7385d41afaa1bd063dfa1b74e693ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad7385d41afaa1bd063dfa1b74e693ad1">evalBatch</a> (<a class="el" href="classglow_1_1_execution_engine.html">ExecutionEngine</a> &amp;EE, <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, size_t numMinibatchRuns, size_t &amp;sampleCounter, <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *inputPH, <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *outputPH, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;samplesInput, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;labelsInput, llvm::StringRef name, std::function&lt; void(const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;sampleIn, const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;sampleOut, const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;label, size_t sampleIndex)&gt; &amp;&amp;cb)</td></tr>
<tr class="separator:ad7385d41afaa1bd063dfa1b74e693ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2a21b045e4c1595f1da56d34750169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a8d2a21b045e4c1595f1da56d34750169">differentiate</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, const <a class="el" href="structglow_1_1_training_config.html">TrainingConfig</a> &amp;config, llvm::StringRef newFuncName=&quot;&quot;, VariableGradientsList *varGrads=nullptr)</td></tr>
<tr class="separator:a8d2a21b045e4c1595f1da56d34750169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493b517e027e3c2689248c644f3747b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_save_node.html">SaveNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a493b517e027e3c2689248c644f3747b5">getOutputSave</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH)</td></tr>
<tr class="separator:a493b517e027e3c2689248c644f3747b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4089f87152e44934daec43bb106d9858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4089f87152e44934daec43bb106d9858">recursiveClone</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *newF, <a class="el" href="classglow_1_1_node.html">Node</a> *node, <a class="el" href="namespaceglow.html#afe305f16778f20f331d6b2016221a756">NodeMap</a> &amp;currToNew)</td></tr>
<tr class="separator:a4089f87152e44934daec43bb106d9858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ca558a2ae84f7c93983f608b3d2f0a"><td class="memItemLeft" align="right" valign="top"><a id="af5ca558a2ae84f7c93983f608b3d2f0a"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_module.html">Module</a> &amp;mod)</td></tr>
<tr class="separator:af5ca558a2ae84f7c93983f608b3d2f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada49a44492f70626c2cf9fa74ddf8d2f"><td class="memItemLeft" align="right" valign="top"><a id="ada49a44492f70626c2cf9fa74ddf8d2f"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_module.html">Module</a> *mod)</td></tr>
<tr class="separator:ada49a44492f70626c2cf9fa74ddf8d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45e63412051b164953d915339f08778"><td class="memItemLeft" align="right" valign="top"><a id="af45e63412051b164953d915339f08778"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_function.html">Function</a> &amp;F)</td></tr>
<tr class="separator:af45e63412051b164953d915339f08778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc599c16f44200c3ae527f8dae185ec4"><td class="memItemLeft" align="right" valign="top"><a id="adc599c16f44200c3ae527f8dae185ec4"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:adc599c16f44200c3ae527f8dae185ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87dc70f9ca570ed9bfb6f43f62ef253"><td class="memItemLeft" align="right" valign="top"><a id="ad87dc70f9ca570ed9bfb6f43f62ef253"></a>
<a class="el" href="structglow_1_1_hooked_function.html">HookedFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hookOutput</b> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="classglow_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:ad87dc70f9ca570ed9bfb6f43f62ef253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b62431330eac17d2e68decaa124a090"><td class="memItemLeft" align="right" valign="top"><a id="a8b62431330eac17d2e68decaa124a090"></a>
<a class="el" href="structglow_1_1_hooked_function.html">HookedFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hookOutput</b> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, llvm::StringRef nodeName)</td></tr>
<tr class="separator:a8b62431330eac17d2e68decaa124a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee890b8f51f27f6d9b3cf7766d5aff6"><td class="memItemLeft" align="right" valign="top"><a id="aaee890b8f51f27f6d9b3cf7766d5aff6"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;node)</td></tr>
<tr class="separator:aaee890b8f51f27f6d9b3cf7766d5aff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a0bf543041a50cfef1b5c3e64fd0ec"><td class="memItemLeft" align="right" valign="top"><a id="a62a0bf543041a50cfef1b5c3e64fd0ec"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:a62a0bf543041a50cfef1b5c3e64fd0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d8953e310c3650356892fa4e866ce3"><td class="memItemLeft" align="right" valign="top">Kinded::Kind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af5d8953e310c3650356892fa4e866ce3">getKindFromNodeName</a> (llvm::StringRef nodeName)</td></tr>
<tr class="separator:af5d8953e310c3650356892fa4e866ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3623979e9cf3437802bf2f23d15b425e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a3623979e9cf3437802bf2f23d15b425e">calculateConvPoolOutputDims</a> (size_t sx, size_t sy, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dilation=1)</td></tr>
<tr class="separator:a3623979e9cf3437802bf2f23d15b425e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110f6a4f4c9801ecca0c96826b3888ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structglow_1_1_shape_h_w_d.html">ShapeHWD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a110f6a4f4c9801ecca0c96826b3888ff">calculate3DConvPoolOutputDims</a> (size_t inH, size_t inW, size_t inD, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads)</td></tr>
<tr class="separator:a110f6a4f4c9801ecca0c96826b3888ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6fb0f683a9b1d0649e7f742b9151c4"><td class="memItemLeft" align="right" valign="top"><a id="afe6fb0f683a9b1d0649e7f742b9151c4"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afe6fb0f683a9b1d0649e7f742b9151c4">operator&lt;&lt;</a> (llvm::raw_ostream &amp;os, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout)</td></tr>
<tr class="memdesc:afe6fb0f683a9b1d0649e7f742b9151c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define output operators. <br /></td></tr>
<tr class="separator:afe6fb0f683a9b1d0649e7f742b9151c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419566d4026797c72c141815595efd47"><td class="memItemLeft" align="right" valign="top"><a id="a419566d4026797c72c141815595efd47"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, <a class="el" href="namespaceglow.html#ae88f2cc9ccac93130ee1cc326d968a21">FusedActivation</a> fusedActivation)</td></tr>
<tr class="separator:a419566d4026797c72c141815595efd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81686f1483028ad3045a94ef9760a3b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a81686f1483028ad3045a94ef9760a3b6">toBinary</a> (float f)</td></tr>
<tr class="memdesc:a81686f1483028ad3045a94ef9760a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a float into an unsigned integer binary representation.  <a href="#a81686f1483028ad3045a94ef9760a3b6">More...</a><br /></td></tr>
<tr class="separator:a81686f1483028ad3045a94ef9760a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf69ac6cea3abdeffaf975e3f9f02d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a13cf69ac6cea3abdeffaf975e3f9f02d">toBinary</a> (llvm::ArrayRef&lt; float &gt; vec)</td></tr>
<tr class="separator:a13cf69ac6cea3abdeffaf975e3f9f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a5368f277fbdfd5cb8462943ac14e"><td class="memItemLeft" align="right" valign="top"><a id="a416a5368f277fbdfd5cb8462943ac14e"></a>
llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="classglow_1_1_tensor.html">glow::Tensor</a> &amp;T)</td></tr>
<tr class="separator:a416a5368f277fbdfd5cb8462943ac14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed1766ebf7725a0051413415a1434f6"><td class="memItemLeft" align="right" valign="top"><a id="a7ed1766ebf7725a0051413415a1434f6"></a>
llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="structglow_1_1_type.html">glow::Type</a> *T)</td></tr>
<tr class="separator:a7ed1766ebf7725a0051413415a1434f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2898079dcd9fda7ffc7bed25a65a5b3"><td class="memItemLeft" align="right" valign="top"><a id="ad2898079dcd9fda7ffc7bed25a65a5b3"></a>
llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="classglow_1_1_node.html">glow::Node</a> *T)</td></tr>
<tr class="separator:ad2898079dcd9fda7ffc7bed25a65a5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d748f20bbabccdd3116d10d66ab877"><td class="memItemLeft" align="right" valign="top"><a id="a72d748f20bbabccdd3116d10d66ab877"></a>
llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="structglow_1_1_node_value.html">glow::NodeValue</a> &amp;T)</td></tr>
<tr class="separator:a72d748f20bbabccdd3116d10d66ab877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45143d1e6bebb3fadd2d86d6fa83aa98"><td class="memItemLeft" align="right" valign="top"><a id="a45143d1e6bebb3fadd2d86d6fa83aa98"></a>
llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="structglow_1_1_node_handle.html">glow::NodeHandle</a> &amp;T)</td></tr>
<tr class="separator:a45143d1e6bebb3fadd2d86d6fa83aa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efbd9d8157489eb3b55e5c9fafb5fb7"><td class="memTemplParams" colspan="2">template&lt;typename Ty &gt; </td></tr>
<tr class="memitem:a5efbd9d8157489eb3b55e5c9fafb5fb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5efbd9d8157489eb3b55e5c9fafb5fb7">reportContext</a> (const Ty &amp;a)</td></tr>
<tr class="separator:a5efbd9d8157489eb3b55e5c9fafb5fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8673fd40721984ef7418c441016ec644"><td class="memTemplParams" colspan="2"><a id="a8673fd40721984ef7418c441016ec644"></a>
template&lt;typename Ty &gt; </td></tr>
<tr class="memitem:a8673fd40721984ef7418c441016ec644"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reportContext</b> (const llvm::ArrayRef&lt; Ty &gt; &amp;arrayRef)</td></tr>
<tr class="separator:a8673fd40721984ef7418c441016ec644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0cb928a5fe2c37d8a523c701f5bc32"><td class="memItemLeft" align="right" valign="top"><a id="a0a0cb928a5fe2c37d8a523c701f5bc32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reportContext</b> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> Ty)</td></tr>
<tr class="separator:a0a0cb928a5fe2c37d8a523c701f5bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943e19401858c2091596c5e6ff2b8745"><td class="memItemLeft" align="right" valign="top"><a id="a943e19401858c2091596c5e6ff2b8745"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reportContext</b> (const <a class="el" href="structglow_1_1_shape_n_h_w_c.html">ShapeNHWC</a> &amp;shapeNHWC)</td></tr>
<tr class="separator:a943e19401858c2091596c5e6ff2b8745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9d65b269de76dda093a6237fd34b4"><td class="memItemLeft" align="right" valign="top"><a id="af0e9d65b269de76dda093a6237fd34b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reportContext</b> (const <a class="el" href="structglow_1_1_shape_n_c_h_w.html">ShapeNCHW</a> &amp;shapeNCHW)</td></tr>
<tr class="separator:af0e9d65b269de76dda093a6237fd34b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bc79983c10b531ddd8836146c76011"><td class="memItemLeft" align="right" valign="top"><a id="ae4bc79983c10b531ddd8836146c76011"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reportContext</b> (const <a class="el" href="classglow_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:ae4bc79983c10b531ddd8836146c76011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09afe64a1783afbb51ba0cd5ae2634a6"><td class="memItemLeft" align="right" valign="top"><a id="a09afe64a1783afbb51ba0cd5ae2634a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reportContext</b> (const <a class="el" href="classglow_1_1_function.html">Function</a> *function)</td></tr>
<tr class="separator:a09afe64a1783afbb51ba0cd5ae2634a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8e77c649bf3668467058ae071bb875"><td class="memTemplParams" colspan="2">template&lt;typename InputTy , typename ParentTy &gt; </td></tr>
<tr class="memitem:afd8e77c649bf3668467058ae071bb875"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> (const char *msg, const InputTy &amp;a, const InputTy &amp;b, const ParentTy *parent, const <a class="el" href="structglow_1_1_compare_with_name.html">CompareWithName</a>&lt; InputTy &gt; &amp;comp=<a class="el" href="structglow_1_1_compare_operator_equal.html">CompareOperatorEqual</a>&lt; InputTy &gt;())</td></tr>
<tr class="separator:afd8e77c649bf3668467058ae071bb875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a6fef6be3a014626580088a1a72842"><td class="memTemplParams" colspan="2">template&lt;typename InputTy &gt; </td></tr>
<tr class="memitem:a77a6fef6be3a014626580088a1a72842"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a77a6fef6be3a014626580088a1a72842">expectCompareTrue</a> (const char *msg, const InputTy &amp;a, llvm::ArrayRef&lt; InputTy &gt; b, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent, const <a class="el" href="structglow_1_1_compare_with_name.html">CompareWithName</a>&lt; InputTy &gt; &amp;comp=<a class="el" href="structglow_1_1_compare_operator_equal.html">CompareOperatorEqual</a>&lt; InputTy &gt;())</td></tr>
<tr class="separator:a77a6fef6be3a014626580088a1a72842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1963e99917ffdb1fdd70911811002792"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a1963e99917ffdb1fdd70911811002792">checkSameType</a> (<a class="el" href="structglow_1_1_node_value.html">NodeValue</a> A, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> B, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:a1963e99917ffdb1fdd70911811002792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ad0f896240c6ccea6cb9472e57e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ae06ad0f896240c6ccea6cb9472e57e2a">checkSameShape</a> (<a class="el" href="structglow_1_1_node_value.html">NodeValue</a> A, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> B, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:ae06ad0f896240c6ccea6cb9472e57e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5321bd4a40acf901a0d9b8eb2e25f4ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5321bd4a40acf901a0d9b8eb2e25f4ae">checkType</a> (<a class="el" href="structglow_1_1_node_value.html">NodeValue</a> A, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> expectedType, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:a5321bd4a40acf901a0d9b8eb2e25f4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06107a1368ca70c82884f7a7863a0599"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a06107a1368ca70c82884f7a7863a0599">checkType</a> (<a class="el" href="structglow_1_1_node_value.html">NodeValue</a> A, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> &gt; expectedTypes, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:a06107a1368ca70c82884f7a7863a0599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3dd221c6d43bfa4d2e54ff8640604b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a9d3dd221c6d43bfa4d2e54ff8640604b">checkSameIsQuantized</a> (const <a class="el" href="structglow_1_1_type.html">TypeRef</a> A, const <a class="el" href="structglow_1_1_type.html">TypeRef</a> B, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:a9d3dd221c6d43bfa4d2e54ff8640604b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b41db469b7a600c65a7e57665a72474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4b41db469b7a600c65a7e57665a72474">checkNotQuantizedOrSameParams</a> (const <a class="el" href="structglow_1_1_type.html">TypeRef</a> A, float scale, int32_t offset, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:a4b41db469b7a600c65a7e57665a72474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b27e9f4187aa476d1a4f3414b4f5dcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a3b27e9f4187aa476d1a4f3414b4f5dcb">checkNotQuantizedOrSameParams</a> (const <a class="el" href="structglow_1_1_type.html">TypeRef</a> A, const <a class="el" href="structglow_1_1_type.html">TypeRef</a> B, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:a3b27e9f4187aa476d1a4f3414b4f5dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfafc7403160bca58a7672d68c2d944d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#abfafc7403160bca58a7672d68c2d944d">checkTypeIgnoreShape</a> (<a class="el" href="structglow_1_1_node_value.html">NodeValue</a> A, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> B, const <a class="el" href="classglow_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="separator:abfafc7403160bca58a7672d68c2d944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a18c587cbe10ce4663291671b3c14a"><td class="memItemLeft" align="right" valign="top"><a id="a55a18c587cbe10ce4663291671b3c14a"></a>
<a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a55a18c587cbe10ce4663291671b3c14a">loadTensor</a> (const ONNX_NAMESPACE::TensorProto &amp;in, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *T)</td></tr>
<tr class="memdesc:a55a18c587cbe10ce4663291671b3c14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads tensor <code>T</code> from the input <code>in</code>. <br /></td></tr>
<tr class="separator:a55a18c587cbe10ce4663291671b3c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78b8ac2f8153ff363a1a6d85d4546cd"><td class="memItemLeft" align="right" valign="top"><a id="ab78b8ac2f8153ff363a1a6d85d4546cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab78b8ac2f8153ff363a1a6d85d4546cd">setConstantFoldLoaderOpsFlag</a> (bool flag)</td></tr>
<tr class="memdesc:ab78b8ac2f8153ff363a1a6d85d4546cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables constant-folding of <a class="el" href="classglow_1_1_loader.html">Loader</a> Ops with <code>flag</code>. <br /></td></tr>
<tr class="separator:ab78b8ac2f8153ff363a1a6d85d4546cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66faefdb52d7d51fa930bf0b04d45b7e"><td class="memItemLeft" align="right" valign="top"><a id="a66faefdb52d7d51fa930bf0b04d45b7e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a66faefdb52d7d51fa930bf0b04d45b7e">getConstantFoldLoaderOpsFlag</a> ()</td></tr>
<tr class="memdesc:a66faefdb52d7d51fa930bf0b04d45b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if constant-folding for loader Ops is enabled. <br /></td></tr>
<tr class="separator:a66faefdb52d7d51fa930bf0b04d45b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea47c0e13dc7e7a9938412b4b56cdf9"><td class="memItemLeft" align="right" valign="top"><a id="a8ea47c0e13dc7e7a9938412b4b56cdf9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a8ea47c0e13dc7e7a9938412b4b56cdf9">isArrayConstant</a> (const llvm::ArrayRef&lt; size_t &gt; a)</td></tr>
<tr class="memdesc:a8ea47c0e13dc7e7a9938412b4b56cdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff all elements of <code>a</code> are the same. <br /></td></tr>
<tr class="separator:a8ea47c0e13dc7e7a9938412b4b56cdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad735d6bafe7a0cb3ffb5482656235b2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad735d6bafe7a0cb3ffb5482656235b2e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad735d6bafe7a0cb3ffb5482656235b2e">unexpectedNodeErrorMessage</a> (const T &amp;node, llvm::StringRef message)</td></tr>
<tr class="separator:ad735d6bafe7a0cb3ffb5482656235b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae369f3c48005ee720d64611cfd152ef"><td class="memTemplParams" colspan="2"><a id="aae369f3c48005ee720d64611cfd152ef"></a>
template&lt;typename ElemTy  = size_t, typename AttrType &gt; </td></tr>
<tr class="memitem:aae369f3c48005ee720d64611cfd152ef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ElemTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aae369f3c48005ee720d64611cfd152ef">getShape</a> (const AttrType *arg)</td></tr>
<tr class="memdesc:aae369f3c48005ee720d64611cfd152ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the 'shape' record into a vector of sizes. <br /></td></tr>
<tr class="separator:aae369f3c48005ee720d64611cfd152ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cf5d13b978aa755ff9b01edad65466"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:ad9cf5d13b978aa755ff9b01edad65466"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad9cf5d13b978aa755ff9b01edad65466">getFloats</a> (const AttrType *arg)</td></tr>
<tr class="separator:ad9cf5d13b978aa755ff9b01edad65466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbe04791f94ae9ed38fa4c0166e6709"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fbe04791f94ae9ed38fa4c0166e6709"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a7fbe04791f94ae9ed38fa4c0166e6709">loadOperatorName</a> (const T &amp;op)</td></tr>
<tr class="separator:a7fbe04791f94ae9ed38fa4c0166e6709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f10f8f52d528b3ceb40892376bc1fb9"><td class="memTemplParams" colspan="2">template&lt;class LoaderType , class OpType &gt; </td></tr>
<tr class="memitem:a6f10f8f52d528b3ceb40892376bc1fb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a6f10f8f52d528b3ceb40892376bc1fb9">constantFoldInLoader</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, LoaderType &amp;tmpLoader, LoaderType *loader, const OpType &amp;op)</td></tr>
<tr class="separator:a6f10f8f52d528b3ceb40892376bc1fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b5eaed4bae1f27356fcac28824077d"><td class="memItemLeft" align="right" valign="top"><a id="a35b5eaed4bae1f27356fcac28824077d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getOperandKindStr</b> (OperandKind CC)</td></tr>
<tr class="separator:a35b5eaed4bae1f27356fcac28824077d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867c5c159e56b6fef437144cfb4e82b6"><td class="memItemLeft" align="right" valign="top"><a id="a867c5c159e56b6fef437144cfb4e82b6"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_value.html">Value</a> &amp;V)</td></tr>
<tr class="separator:a867c5c159e56b6fef437144cfb4e82b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5980fcd2be554da44ec79f3a5a873ecd"><td class="memItemLeft" align="right" valign="top"><a id="a5980fcd2be554da44ec79f3a5a873ecd"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_value.html">Value</a> *V)</td></tr>
<tr class="separator:a5980fcd2be554da44ec79f3a5a873ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5720dde6a04852e0bdef39ba68ee76"><td class="memItemLeft" align="right" valign="top"><a id="a5f5720dde6a04852e0bdef39ba68ee76"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &amp;irf)</td></tr>
<tr class="separator:a5f5720dde6a04852e0bdef39ba68ee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d048d8c4d0955710c23ffb035a16d04"><td class="memItemLeft" align="right" valign="top"><a id="a1d048d8c4d0955710c23ffb035a16d04"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> *irf)</td></tr>
<tr class="separator:a1d048d8c4d0955710c23ffb035a16d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa588b030c2f1fbed648b8477d7b444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aafa588b030c2f1fbed648b8477d7b444">isTensorView</a> (<a class="el" href="classglow_1_1_value.html">Value</a> *v)</td></tr>
<tr class="separator:aafa588b030c2f1fbed648b8477d7b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32aaca1a37daa0543ca953df2110b63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab32aaca1a37daa0543ca953df2110b63">getAllocationOrigin</a> (<a class="el" href="classglow_1_1_value.html">Value</a> *V)</td></tr>
<tr class="separator:ab32aaca1a37daa0543ca953df2110b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ad0b5511a75c369f14b06c1de37fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a455ad0b5511a75c369f14b06c1de37fd">getOrigin</a> (<a class="el" href="classglow_1_1_value.html">Value</a> *V)</td></tr>
<tr class="separator:a455ad0b5511a75c369f14b06c1de37fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec2658c25c6fddc1b6788888a930d71"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a7ec2658c25c6fddc1b6788888a930d71">getOriginOffset</a> (<a class="el" href="classglow_1_1_value.html">Value</a> *V)</td></tr>
<tr class="separator:a7ec2658c25c6fddc1b6788888a930d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582b647d0167e2bd46758cf24a691ac3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a582b647d0167e2bd46758cf24a691ac3">getOrigin</a> (const <a class="el" href="classglow_1_1_value.html">Value</a> *V)</td></tr>
<tr class="separator:a582b647d0167e2bd46758cf24a691ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f32741a0e156b7bd043992d6eedc6c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classglow_1_1_function_pass.html">FunctionPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a77f32741a0e156b7bd043992d6eedc6c">createFunctionPass</a> (<a class="el" href="namespaceglow.html#a3157945b92abd634c79fa9d4724472eb">FunctionPassID</a> passID)</td></tr>
<tr class="memdesc:a77f32741a0e156b7bd043992d6eedc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that creates and.  <a href="#a77f32741a0e156b7bd043992d6eedc6c">More...</a><br /></td></tr>
<tr class="separator:a77f32741a0e156b7bd043992d6eedc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902cda054ebe738e9395e218ae09f291"><td class="memItemLeft" align="right" valign="top"><a id="a902cda054ebe738e9395e218ae09f291"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a902cda054ebe738e9395e218ae09f291">optimize</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx)</td></tr>
<tr class="memdesc:a902cda054ebe738e9395e218ae09f291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform optimizations on the graph representation. <br /></td></tr>
<tr class="separator:a902cda054ebe738e9395e218ae09f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b890b671b9e9a2e7cb5f3b45f6b5d9"><td class="memItemLeft" align="right" valign="top"><a id="aa4b890b671b9e9a2e7cb5f3b45f6b5d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html#a92efb87746c0edf7756b84fdcd87014a">CompilationMode</a> mode)</td></tr>
<tr class="separator:aa4b890b671b9e9a2e7cb5f3b45f6b5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b05ee22e66e0ac0c56f9623b1038bdd"><td class="memItemLeft" align="right" valign="top"><a id="a3b05ee22e66e0ac0c56f9623b1038bdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx, const <a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;B)</td></tr>
<tr class="separator:a3b05ee22e66e0ac0c56f9623b1038bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af90308823b5fb36b860a8a73aaa923"><td class="memItemLeft" align="right" valign="top"><a id="a1af90308823b5fb36b860a8a73aaa923"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a1af90308823b5fb36b860a8a73aaa923">fold</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx)</td></tr>
<tr class="memdesc:a1af90308823b5fb36b860a8a73aaa923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold nodes that were expressed lowered in the input model. <br /></td></tr>
<tr class="separator:a1af90308823b5fb36b860a8a73aaa923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e16dd4467be5a31fb8647f8199d4d5a"><td class="memItemLeft" align="right" valign="top"><a id="a8e16dd4467be5a31fb8647f8199d4d5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fold</b> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html#a92efb87746c0edf7756b84fdcd87014a">CompilationMode</a> mode)</td></tr>
<tr class="separator:a8e16dd4467be5a31fb8647f8199d4d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0069e8261c2e2ddf94d4697de80150ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a0069e8261c2e2ddf94d4697de80150ad">lower</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx, const <a class="el" href="classglow_1_1_backend.html">Backend</a> *B=nullptr, const KindSet &amp;doNotLowerKinds={})</td></tr>
<tr class="separator:a0069e8261c2e2ddf94d4697de80150ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4fddd8b31e37460f88d44f076a2863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a7c4fddd8b31e37460f88d44f076a2863">convertPlaceholdersToConstants</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, const <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt; vars)</td></tr>
<tr class="separator:a7c4fddd8b31e37460f88d44f076a2863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9d4a9dc79cc3c3010bc99e93b08fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a8e9d4a9dc79cc3c3010bc99e93b08fc7">profileQuantization</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:a8e9d4a9dc79cc3c3010bc99e93b08fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b48e8310d02c29962b5469885b3a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af6b48e8310d02c29962b5469885b3a75">optimizeFunction</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, const <a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;B, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx)</td></tr>
<tr class="separator:af6b48e8310d02c29962b5469885b3a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc58f10ed9c082dab795b43217a2d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a2bc58f10ed9c082dab795b43217a2d51">optimizeFunctionBeforeLowering</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx)</td></tr>
<tr class="separator:a2bc58f10ed9c082dab795b43217a2d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e523cb23b972dda0c52eb9c841a1d33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classglow_1_1_constant.html">Constant</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a0e523cb23b972dda0c52eb9c841a1d33">constantFold</a> (<a class="el" href="classglow_1_1_node.html">Node</a> *N)</td></tr>
<tr class="separator:a0e523cb23b972dda0c52eb9c841a1d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf1f1f5a7c61022904299bfeee07b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a6bf1f1f5a7c61022904299bfeee07b34">executeConstantFunction</a> (<a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;backend, <a class="el" href="classglow_1_1_function.html">Function</a> &amp;F, <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx)</td></tr>
<tr class="separator:a6bf1f1f5a7c61022904299bfeee07b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130f47cd21711d9244adfb418ffbe9f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a130f47cd21711d9244adfb418ffbe9f7">executeVerticalFCWeightsSplit</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, unsigned numOfChunks, unsigned minKToSplit)</td></tr>
<tr class="separator:a130f47cd21711d9244adfb418ffbe9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f636287069c1f7f97e401c440ae580"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a70f636287069c1f7f97e401c440ae580">runDCEPass</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;cctx)</td></tr>
<tr class="memdesc:a70f636287069c1f7f97e401c440ae580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to run a DCE pass on <code>F</code> given <code>cctx</code>.  <a href="#a70f636287069c1f7f97e401c440ae580">More...</a><br /></td></tr>
<tr class="separator:a70f636287069c1f7f97e401c440ae580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4919335ab33be32c994fc590a146f819"><td class="memItemLeft" align="right" valign="top"><a id="a4919335ab33be32c994fc590a146f819"></a>
<a class="el" href="namespaceglow.html#a32fc0e338408955f80a23cc7e0c0c82e">TensorInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4919335ab33be32c994fc590a146f819">getDefaultTensorInitializer</a> ()</td></tr>
<tr class="memdesc:a4919335ab33be32c994fc590a146f819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method generates and returns the default tensor initializer. <br /></td></tr>
<tr class="separator:a4919335ab33be32c994fc590a146f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab8032d084eac6febc76e522aec8564"><td class="memItemLeft" align="right" valign="top"><a id="afab8032d084eac6febc76e522aec8564"></a>
<a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afab8032d084eac6febc76e522aec8564">prepareFunctionForTraining</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&amp;selected, <a class="el" href="namespaceglow.html#a32fc0e338408955f80a23cc7e0c0c82e">TensorInitializer</a> &amp;&amp;initializer=<a class="el" href="namespaceglow.html#a4919335ab33be32c994fc590a146f819">getDefaultTensorInitializer</a>())</td></tr>
<tr class="memdesc:afab8032d084eac6febc76e522aec8564"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> takes <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">glow::Function</a> <code>F</code>, <code>bindings</code>, <code>selected</code> placeholder,. <br /></td></tr>
<tr class="separator:afab8032d084eac6febc76e522aec8564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7544cbea4219b8f3c720d6a4e19481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#afd7544cbea4219b8f3c720d6a4e19481">createDefaultGraphOptimizationPassPipeline</a> ()</td></tr>
<tr class="separator:afd7544cbea4219b8f3c720d6a4e19481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cba8b151906d972e63ced04b7e02242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a2cba8b151906d972e63ced04b7e02242">createFP16GraphOptimizationPassPipeline</a> ()</td></tr>
<tr class="separator:a2cba8b151906d972e63ced04b7e02242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0b594543fb42b8b6ad0cc556ee9829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a9e0b594543fb42b8b6ad0cc556ee9829">createDefaultFoldPassPipeline</a> ()</td></tr>
<tr class="separator:a9e0b594543fb42b8b6ad0cc556ee9829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fef74193703ceb204297b6993af8081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_function_pass_config.html">FunctionPassConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4fef74193703ceb204297b6993af8081">getDCEPassConfig</a> ()</td></tr>
<tr class="separator:a4fef74193703ceb204297b6993af8081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6195ce22fbeafd894c0ce148bb7a8a9a"><td class="memItemLeft" align="right" valign="top">llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a6195ce22fbeafd894c0ce148bb7a8a9a">getNameOfPass</a> (<a class="el" href="namespaceglow.html#a3157945b92abd634c79fa9d4724472eb">FunctionPassID</a> passID)</td></tr>
<tr class="separator:a6195ce22fbeafd894c0ce148bb7a8a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26012881301f2ecb24de4db2c87acf1"><td class="memItemLeft" align="right" valign="top"><a id="ac26012881301f2ecb24de4db2c87acf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ac26012881301f2ecb24de4db2c87acf1">optimize</a> (<a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &amp;M, bool shouldShareBuffers)</td></tr>
<tr class="memdesc:ac26012881301f2ecb24de4db2c87acf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform optimizations on the IR representation. <br /></td></tr>
<tr class="separator:ac26012881301f2ecb24de4db2c87acf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100064cb8d6d8c2aae54f4a114cf48f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a100064cb8d6d8c2aae54f4a114cf48f4">generateAndOptimizeIR</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F, const <a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;B, bool shouldShareBuffers)</td></tr>
<tr class="separator:a100064cb8d6d8c2aae54f4a114cf48f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bee061556f83b0349d96ad196f0faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a07bee061556f83b0349d96ad196f0faf">optimizeCommunicationCost</a> (<a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;partitions, FunctionToNodesMap &amp;nodesSet, <a class="el" href="classglow_1_1_module.html">Module</a> *mod, uint64_t availableMemory)</td></tr>
<tr class="separator:a07bee061556f83b0349d96ad196f0faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6afbd888776074c6bd9285aa3d9fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aab6afbd888776074c6bd9285aa3d9fd8">partitionsCombine</a> (<a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;partitions, FunctionToNodesMap &amp;nodesSet, <a class="el" href="classglow_1_1_module.html">Module</a> *mod, uint64_t availableMemory)</td></tr>
<tr class="separator:aab6afbd888776074c6bd9285aa3d9fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce5a7edd1093d119dbed94a5dce5cdf"><td class="memItemLeft" align="right" valign="top">DeviceIDTy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#adce5a7edd1093d119dbed94a5dce5cdf">assignLogicalDeviceID</a> (<a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;mapping, const std::map&lt; std::string, <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &gt; &amp;backendMap)</td></tr>
<tr class="separator:adce5a7edd1093d119dbed94a5dce5cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fba690abc1f8a3660e73f6e6c9959bd"><td class="memItemLeft" align="right" valign="top"><a id="a6fba690abc1f8a3660e73f6e6c9959bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a> &amp;LHS, const <a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a> &amp;RHS)</td></tr>
<tr class="separator:a6fba690abc1f8a3660e73f6e6c9959bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7d1d30cd1420a7a651fa3d63b33e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#a03e8d2f34b0b5876fd4f7abaf0a0d73d">BFSLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#acfa7d1d30cd1420a7a651fa3d63b33e6">getBFSLevel</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:acfa7d1d30cd1420a7a651fa3d63b33e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2ce9f3fea11d339cd0605fe8ece061"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classglow_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ace2ce9f3fea11d339cd0605fe8ece061">getOutUsers</a> (const NodesSet &amp;nodes)</td></tr>
<tr class="memdesc:ace2ce9f3fea11d339cd0605fe8ece061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>nodes</code>, return a list of nodes who use any node in this set.  <a href="#ace2ce9f3fea11d339cd0605fe8ece061">More...</a><br /></td></tr>
<tr class="separator:ace2ce9f3fea11d339cd0605fe8ece061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ec64282f28b5487a23bf2d805a528"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classglow_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a352ec64282f28b5487a23bf2d805a528">getOutUsersWithOnePredecessor</a> (const NodesSet &amp;nodes)</td></tr>
<tr class="separator:a352ec64282f28b5487a23bf2d805a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ea6df70770cd2ccf2bbfb85077539"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a4c7ea6df70770cd2ccf2bbfb85077539">getOutMemPerNode</a> (const NodesSet &amp;nodes, const <a class="el" href="classglow_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:a4c7ea6df70770cd2ccf2bbfb85077539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589ee9d58bb8726a5e764b1dd74f8070"><td class="memItemLeft" align="right" valign="top">NodesSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a589ee9d58bb8726a5e764b1dd74f8070">getInputs</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a589ee9d58bb8726a5e764b1dd74f8070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node,.  <a href="#a589ee9d58bb8726a5e764b1dd74f8070">More...</a><br /></td></tr>
<tr class="separator:a589ee9d58bb8726a5e764b1dd74f8070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126aa14fbeafec59916bb142ecac0541"><td class="memItemLeft" align="right" valign="top"><a id="a126aa14fbeafec59916bb142ecac0541"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a126aa14fbeafec59916bb142ecac0541">getNodeComputeTime</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> *node, const <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &amp;backendInfo)</td></tr>
<tr class="memdesc:a126aa14fbeafec59916bb142ecac0541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the estimated op computation time based on <code>backendInfo</code>. <br /></td></tr>
<tr class="separator:a126aa14fbeafec59916bb142ecac0541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d8826ffac432ffcebc8dcd11a85816"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a59d8826ffac432ffcebc8dcd11a85816">getNodeMemUsage</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a59d8826ffac432ffcebc8dcd11a85816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node,.  <a href="#a59d8826ffac432ffcebc8dcd11a85816">More...</a><br /></td></tr>
<tr class="separator:a59d8826ffac432ffcebc8dcd11a85816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54619319c88d7ceb184f4dd70af8ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aa54619319c88d7ceb184f4dd70af8ccf">updateGraphMemInfoByAddingNode</a> (const NodesSet &amp;currNodes, const <a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a> &amp;info, <a class="el" href="classglow_1_1_node.html">Node</a> *newNode)</td></tr>
<tr class="separator:aa54619319c88d7ceb184f4dd70af8ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21f64a0aca1ada898039dbe69053bfd"><td class="memItemLeft" align="right" valign="top"><a id="af21f64a0aca1ada898039dbe69053bfd"></a>
<a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af21f64a0aca1ada898039dbe69053bfd">getGraphMemInfo</a> (const NodesSet &amp;nodes)</td></tr>
<tr class="memdesc:af21f64a0aca1ada898039dbe69053bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory usage of a given nodes set. <br /></td></tr>
<tr class="separator:af21f64a0aca1ada898039dbe69053bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d06550bdaa17730cb67e8a086db767c"><td class="memItemLeft" align="right" valign="top">std::set&lt; Kinded::Kind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a9d06550bdaa17730cb67e8a086db767c">generateNodeKindsSet</a> (llvm::StringRef names)</td></tr>
<tr class="separator:a9d06550bdaa17730cb67e8a086db767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52aab7cde0b8f39f6420e1c47c57ff34"><td class="memItemLeft" align="right" valign="top"><a id="a52aab7cde0b8f39f6420e1c47c57ff34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a52aab7cde0b8f39f6420e1c47c57ff34">logPartitionInfo</a> (const <a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;partitions)</td></tr>
<tr class="memdesc:a52aab7cde0b8f39f6420e1c47c57ff34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the info of current partition <code>partitions</code>. <br /></td></tr>
<tr class="separator:a52aab7cde0b8f39f6420e1c47c57ff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a9500a329d096bf03201016353f1dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a85a9500a329d096bf03201016353f1dd">logicalDevicesValidation</a> (const <a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;partitions, const std::map&lt; std::string, <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &gt; &amp;backendMap)</td></tr>
<tr class="separator:a85a9500a329d096bf03201016353f1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0a4dcd72e491d512294eec2ba422a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a07a0a4dcd72e491d512294eec2ba422a">memoryUsageValidation</a> (const <a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;partitions, const std::map&lt; std::string, <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &gt; &amp;backendMap)</td></tr>
<tr class="separator:a07a0a4dcd72e491d512294eec2ba422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40999bf88c854e1ca4bcbfa9efbd119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad40999bf88c854e1ca4bcbfa9efbd119">dagValidation</a> (const <a class="el" href="structglow_1_1runtime_1_1_d_a_g.html">DAG</a> &amp;dag)</td></tr>
<tr class="separator:ad40999bf88c854e1ca4bcbfa9efbd119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a23dd0c029682e58c8634f5866539"><td class="memItemLeft" align="right" valign="top"><a id="a159a23dd0c029682e58c8634f5866539"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a159a23dd0c029682e58c8634f5866539">operator&lt;</a> (const <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> &amp;x, const <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> &amp;y)</td></tr>
<tr class="memdesc:a159a23dd0c029682e58c8634f5866539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload &lt; operator for <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> to allow for usage with std::set. <br /></td></tr>
<tr class="separator:a159a23dd0c029682e58c8634f5866539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb55fda5495f592ea57c2a223c4e0a7"><td class="memItemLeft" align="right" valign="top"><a id="a3bb55fda5495f592ea57c2a223c4e0a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a3bb55fda5495f592ea57c2a223c4e0a7">operator==</a> (const <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> &amp;x, const <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> &amp;y)</td></tr>
<tr class="memdesc:a3bb55fda5495f592ea57c2a223c4e0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload == operator for <a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a> to allow for usage with std::set. <br /></td></tr>
<tr class="separator:a3bb55fda5495f592ea57c2a223c4e0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c38c04977c3b94eec8b306c5a01bea1"><td class="memItemLeft" align="right" valign="top"><a id="a5c38c04977c3b94eec8b306c5a01bea1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5c38c04977c3b94eec8b306c5a01bea1">serializeToYaml</a> (llvm::StringRef fileName, llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_quantization_info.html">NodeQuantizationInfo</a> &gt; quantizationInfos)</td></tr>
<tr class="memdesc:a5c38c04977c3b94eec8b306c5a01bea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize <code>quantizationInfos</code> into the file named <code>fileName</code>. <br /></td></tr>
<tr class="separator:a5c38c04977c3b94eec8b306c5a01bea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c0a9d395ccc24594fbc8935d24fd0d"><td class="memItemLeft" align="right" valign="top"><a id="a40c0a9d395ccc24594fbc8935d24fd0d"></a>
std::vector&lt; <a class="el" href="structglow_1_1_node_quantization_info.html">NodeQuantizationInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a40c0a9d395ccc24594fbc8935d24fd0d">deserializeFromYaml</a> (llvm::StringRef fileName)</td></tr>
<tr class="memdesc:a40c0a9d395ccc24594fbc8935d24fd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize quantization infos from the file <code>fileName</code>. <br /></td></tr>
<tr class="separator:a40c0a9d395ccc24594fbc8935d24fd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba68dabd93fccc2d7c95db1688338f48"><td class="memItemLeft" align="right" valign="top"><a id="aba68dabd93fccc2d7c95db1688338f48"></a>
<a class="el" href="classglow_1_1_stats_exporter_registry.html">StatsExporterRegistry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aba68dabd93fccc2d7c95db1688338f48">Stats</a> ()</td></tr>
<tr class="memdesc:aba68dabd93fccc2d7c95db1688338f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global singleton <a class="el" href="classglow_1_1_stats_exporter.html">StatsExporter</a>. <br /></td></tr>
<tr class="separator:aba68dabd93fccc2d7c95db1688338f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5192591d333ee1a71b03325bb3d9f80a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a5192591d333ee1a71b03325bb3d9f80a">isCurrentDebugType</a> (const char *type)</td></tr>
<tr class="separator:a5192591d333ee1a71b03325bb3d9f80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebce7475aa5021b9b6c5092b14f96e22"><td class="memItemLeft" align="right" valign="top"><a id="aebce7475aa5021b9b6c5092b14f96e22"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aebce7475aa5021b9b6c5092b14f96e22">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classglow_1_1float16.html">float16</a> &amp;b)</td></tr>
<tr class="memdesc:aebce7475aa5021b9b6c5092b14f96e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow float16_t to be passed to an ostream. <br /></td></tr>
<tr class="separator:aebce7475aa5021b9b6c5092b14f96e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac962e2d08e102e7eb14c728068067e71"><td class="memItemLeft" align="right" valign="top"><a id="ac962e2d08e102e7eb14c728068067e71"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ac962e2d08e102e7eb14c728068067e71">alignedAlloc</a> (size_t size, size_t align)</td></tr>
<tr class="memdesc:ac962e2d08e102e7eb14c728068067e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <code>size</code> bytes of memory aligned to <code>align</code> bytes. <br /></td></tr>
<tr class="separator:ac962e2d08e102e7eb14c728068067e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1285b944f655c06ff1accf71d3ea9a5"><td class="memItemLeft" align="right" valign="top"><a id="aa1285b944f655c06ff1accf71d3ea9a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aa1285b944f655c06ff1accf71d3ea9a5">alignedFree</a> (void *p)</td></tr>
<tr class="memdesc:aa1285b944f655c06ff1accf71d3ea9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free aligned memory. <br /></td></tr>
<tr class="separator:aa1285b944f655c06ff1accf71d3ea9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4bd0099a5796fa484ffce3d628bdea"><td class="memItemLeft" align="right" valign="top"><a id="abd4bd0099a5796fa484ffce3d628bdea"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#abd4bd0099a5796fa484ffce3d628bdea">alignedSize</a> (size_t size, size_t alignment)</td></tr>
<tr class="memdesc:abd4bd0099a5796fa484ffce3d628bdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up <code>size</code> to the nearest <code>alignment</code>. <br /></td></tr>
<tr class="separator:abd4bd0099a5796fa484ffce3d628bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cc5003864817f305e3351f82dbef78"><td class="memItemLeft" align="right" valign="top"><a id="af4cc5003864817f305e3351f82dbef78"></a>
llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#af4cc5003864817f305e3351f82dbef78">operator&lt;&lt;</a> (llvm::raw_ostream &amp;os, void *ptr)</td></tr>
<tr class="memdesc:af4cc5003864817f305e3351f82dbef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the ptr <code>ptr</code> into an ascii representation in the format "0xFFF...". <br /></td></tr>
<tr class="separator:af4cc5003864817f305e3351f82dbef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae095c93d366edde27fb624fe8963e2d7"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ae095c93d366edde27fb624fe8963e2d7">outs</a> ()</td></tr>
<tr class="separator:ae095c93d366edde27fb624fe8963e2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5afe057375ea161648698052cdeef25"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad5afe057375ea161648698052cdeef25">errs</a> ()</td></tr>
<tr class="separator:ad5afe057375ea161648698052cdeef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64763ac9b2b790fea832124d0b2d401a"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a64763ac9b2b790fea832124d0b2d401a">dbgs</a> ()</td></tr>
<tr class="separator:a64763ac9b2b790fea832124d0b2d401a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3149373d4dc6e9cf35f07ce89806adb2"><td class="memTemplParams" colspan="2"><a id="a3149373d4dc6e9cf35f07ce89806adb2"></a>
template&lt;typename Stream , typename E &gt; </td></tr>
<tr class="memitem:a3149373d4dc6e9cf35f07ce89806adb2"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a3149373d4dc6e9cf35f07ce89806adb2">operator&lt;&lt;</a> (Stream &amp;os, const llvm::ArrayRef&lt; E &gt; list)</td></tr>
<tr class="memdesc:a3149373d4dc6e9cf35f07ce89806adb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream LLVM's ArrayRef into the given output stream. <br /></td></tr>
<tr class="separator:a3149373d4dc6e9cf35f07ce89806adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9f98855ca17db059deb4688e051e61"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a0c9f98855ca17db059deb4688e051e61">escapeDottyString</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a0c9f98855ca17db059deb4688e051e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdedf715e997af0b1a4ad4b1882bed49"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#abdedf715e997af0b1a4ad4b1882bed49">getDotFileNodeColor</a> (size_t index)</td></tr>
<tr class="separator:abdedf715e997af0b1a4ad4b1882bed49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321c329e831eeefea18601ae9ce56f00"><td class="memItemLeft" align="right" valign="top"><a id="a321c329e831eeefea18601ae9ce56f00"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a321c329e831eeefea18601ae9ce56f00">quote</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a321c329e831eeefea18601ae9ce56f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add quotes to the string <code>in</code>. <br /></td></tr>
<tr class="separator:a321c329e831eeefea18601ae9ce56f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697c3d30b72e51fbe7d1a027a77f530c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a697c3d30b72e51fbe7d1a027a77f530c">tolower</a> (const std::string &amp;in)</td></tr>
<tr class="separator:a697c3d30b72e51fbe7d1a027a77f530c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d164b45d9fb735f448cd7985bcdf203"><td class="memItemLeft" align="right" valign="top"><a id="a9d164b45d9fb735f448cd7985bcdf203"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a9d164b45d9fb735f448cd7985bcdf203">report</a> (const char *msg)</td></tr>
<tr class="memdesc:a9d164b45d9fb735f448cd7985bcdf203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <code>msg</code> on the error stream. <br /></td></tr>
<tr class="separator:a9d164b45d9fb735f448cd7985bcdf203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b24dfac70824545414756a61885717"><td class="memItemLeft" align="right" valign="top"><a id="ab1b24dfac70824545414756a61885717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>report</b> (const std::string &amp;str)</td></tr>
<tr class="separator:ab1b24dfac70824545414756a61885717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9318e385e95e64e916620a62ee3310d3"><td class="memItemLeft" align="right" valign="top"><a id="a9318e385e95e64e916620a62ee3310d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>report</b> (llvm::StringRef str)</td></tr>
<tr class="separator:a9318e385e95e64e916620a62ee3310d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2799bdee5e14247b8699a8dfd8f6ae9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aa2799bdee5e14247b8699a8dfd8f6ae9">legalizeName</a> (llvm::StringRef name)</td></tr>
<tr class="separator:aa2799bdee5e14247b8699a8dfd8f6ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab661c0cc5604b2acbbf8194bae5979ed"><td class="memItemLeft" align="right" valign="top"><a id="ab661c0cc5604b2acbbf8194bae5979ed"></a>
std::vector&lt; <a class="el" href="structglow_1_1_device_config_helper.html">DeviceConfigHelper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab661c0cc5604b2acbbf8194bae5979ed">deserializeDeviceConfigFromYaml</a> (llvm::StringRef fileName)</td></tr>
<tr class="memdesc:ab661c0cc5604b2acbbf8194bae5979ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize quantization infos from the file <code>fileName</code>. <br /></td></tr>
<tr class="separator:ab661c0cc5604b2acbbf8194bae5979ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ec6a162752e477489d4c5cbff6be28"><td class="memItemLeft" align="right" valign="top"><a id="a38ec6a162752e477489d4c5cbff6be28"></a>
std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a38ec6a162752e477489d4c5cbff6be28">deserializeStrStrMapFromYaml</a> (llvm::StringRef fileName)</td></tr>
<tr class="memdesc:a38ec6a162752e477489d4c5cbff6be28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize string to string map from the file <code>fileName</code>. <br /></td></tr>
<tr class="separator:a38ec6a162752e477489d4c5cbff6be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8dd211016444e5c6014f63452c1a8a"><td class="memItemLeft" align="right" valign="top"><a id="a6d8dd211016444e5c6014f63452c1a8a"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a6d8dd211016444e5c6014f63452c1a8a">strFormat</a> (const char *format,...) __attribute__((__format__(__printf__</td></tr>
<tr class="memdesc:a6d8dd211016444e5c6014f63452c1a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printf-like formatting for std::string. <br /></td></tr>
<tr class="separator:a6d8dd211016444e5c6014f63452c1a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2669a16ac3c54145c294457d6554cb4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab2669a16ac3c54145c294457d6554cb4"><td class="memTemplItemLeft" align="right" valign="top">const std::string constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab2669a16ac3c54145c294457d6554cb4">convertEnumToUnsigned</a> (T e)</td></tr>
<tr class="separator:ab2669a16ac3c54145c294457d6554cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c36fb4023b57b7f2ea10ac4fe9c459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ab3c36fb4023b57b7f2ea10ac4fe9c459">isOutput</a> (const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH, const std::vector&lt; const <a class="el" href="classglow_1_1_function.html">Function</a> *&gt; &amp;funcs)</td></tr>
<tr class="separator:ab3c36fb4023b57b7f2ea10ac4fe9c459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac10131240fff18a61a4f525541fe765"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aac10131240fff18a61a4f525541fe765">isInput</a> (const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH, const std::vector&lt; const <a class="el" href="classglow_1_1_function.html">Function</a> *&gt; &amp;funcs)</td></tr>
<tr class="separator:aac10131240fff18a61a4f525541fe765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57baaa229ed26f9593c1310e626b39d3"><td class="memItemLeft" align="right" valign="top"><a id="a57baaa229ed26f9593c1310e626b39d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GLOW_BACKEND_FACTORY</b> (CPUFactory, <a class="el" href="classglow_1_1_c_p_u_backend.html">CPUBackend</a>)</td></tr>
<tr class="separator:a57baaa229ed26f9593c1310e626b39d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150442fd9a79c89605e8e0a723fad58"><td class="memItemLeft" align="right" valign="top"><a id="a6150442fd9a79c89605e8e0a723fad58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GLOW_BACKEND_FACTORY</b> (HabanaFactory, <a class="el" href="classglow_1_1_habana_backend.html">HabanaBackend</a>)</td></tr>
<tr class="separator:a6150442fd9a79c89605e8e0a723fad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd862f2c2d0fa00b3d1bd9a3fdf35e4"><td class="memItemLeft" align="right" valign="top"><a id="a8dd862f2c2d0fa00b3d1bd9a3fdf35e4"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>statusStr</b> (synStatus status)</td></tr>
<tr class="separator:a8dd862f2c2d0fa00b3d1bd9a3fdf35e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9052142cd801c37c1dd49a3b139682d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a9052142cd801c37c1dd49a3b139682d9">allows64To32Downcast</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> *src, const <a class="el" href="classglow_1_1_node.html">Node</a> *dst)</td></tr>
<tr class="separator:a9052142cd801c37c1dd49a3b139682d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c06e353dbcd4a5d2af024633fdaadb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ac2c06e353dbcd4a5d2af024633fdaadb">allows64To32Downcast</a> (const <a class="el" href="classglow_1_1_storage.html">Storage</a> *V, const <a class="el" href="classglow_1_1_function.html">Function</a> *F)</td></tr>
<tr class="separator:ac2c06e353dbcd4a5d2af024633fdaadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627577fc0d983b88da24a4b104fd3c96"><td class="memItemLeft" align="right" valign="top"><a id="a627577fc0d983b88da24a4b104fd3c96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GLOW_BACKEND_FACTORY</b> (InterpreterFactory, <a class="el" href="classglow_1_1_interpreter.html">Interpreter</a>)</td></tr>
<tr class="separator:a627577fc0d983b88da24a4b104fd3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35623fe1e4a06a0b10087a66fbed8df"><td class="memItemLeft" align="right" valign="top"><a id="aa35623fe1e4a06a0b10087a66fbed8df"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ICETFilename</b> ()</td></tr>
<tr class="separator:aa35623fe1e4a06a0b10087a66fbed8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9490be40b9bc4366d81159a7745126"><td class="memItemLeft" align="right" valign="top"><a id="a9d9490be40b9bc4366d81159a7745126"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>UseIceT</b> ()</td></tr>
<tr class="separator:a9d9490be40b9bc4366d81159a7745126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0df717153aee9e88b3b93b9e7b1f20"><td class="memItemLeft" align="right" valign="top"><a id="a4e0df717153aee9e88b3b93b9e7b1f20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>UseInferenceAPI</b> ()</td></tr>
<tr class="separator:a4e0df717153aee9e88b3b93b9e7b1f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce26479e4fabd44848f6189a24ebd83"><td class="memItemLeft" align="right" valign="top"><a id="a3ce26479e4fabd44848f6189a24ebd83"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>EnvDeviceVersion</b> ()</td></tr>
<tr class="separator:a3ce26479e4fabd44848f6189a24ebd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fe70fd305c5fefdd6cda83473d6c0e"><td class="memItemLeft" align="right" valign="top"><a id="aa1fe70fd305c5fefdd6cda83473d6c0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SymlowpWA</b> ()</td></tr>
<tr class="separator:aa1fe70fd305c5fefdd6cda83473d6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab301723a3318bf652b369645666612a8"><td class="memItemLeft" align="right" valign="top"><a id="ab301723a3318bf652b369645666612a8"></a>
<a class="el" href="classglow_1_1_backend.html">Backend</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createNNPIBackend</b> (const <a class="el" href="structglow_1_1runtime_1_1_device_config.html">runtime::DeviceConfig</a> &amp;deviceConfig)</td></tr>
<tr class="separator:ab301723a3318bf652b369645666612a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ccf066abc84dfe97555dd2602d8724"><td class="memItemLeft" align="right" valign="top"><a id="a74ccf066abc84dfe97555dd2602d8724"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GLOW_BACKEND_FACTORY</b> (NNPIFactory, <a class="el" href="classglow_1_1_n_n_p_i_backend.html">NNPIBackend</a>)</td></tr>
<tr class="separator:a74ccf066abc84dfe97555dd2602d8724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40768582ed3a9a8a7d8f826d4b9cd372"><td class="memItemLeft" align="right" valign="top"><a id="a40768582ed3a9a8a7d8f826d4b9cd372"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GLOW_BACKEND_FACTORY</b> (OpenCLFactory, <a class="el" href="classglow_1_1_o_c_l_backend.html">OCLBackend</a>)</td></tr>
<tr class="separator:a40768582ed3a9a8a7d8f826d4b9cd372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b3c359f0cbd0285d9f94acc95a152"><td class="memItemLeft" align="right" valign="top"><a id="a1c5b3c359f0cbd0285d9f94acc95a152"></a>
llvm::cl::OptionCategory&#160;</td><td class="memItemRight" valign="bottom"><b>imageCat</b> (&quot;Image Processing Options&quot;)</td></tr>
<tr class="separator:a1c5b3c359f0cbd0285d9f94acc95a152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bb2533645823cd73d1ed421e90de3a"><td class="memItemLeft" align="right" valign="top"><a id="ad8bb2533645823cd73d1ed421e90de3a"></a>
llvm::cl::list&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>meanValues</b> (&quot;mean&quot;, llvm::cl::desc(&quot;Mean values m1,m2,m3...&quot; &quot;Count must be equal to number of input channels.&quot;), llvm::cl::value_desc(&quot;float&quot;), llvm::cl::ZeroOrMore, llvm::cl::CommaSeparated, llvm::cl::cat(imageCat))</td></tr>
<tr class="separator:ad8bb2533645823cd73d1ed421e90de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab005bac048df0db93a0b0b245db7a379"><td class="memItemLeft" align="right" valign="top"><a id="ab005bac048df0db93a0b0b245db7a379"></a>
llvm::cl::list&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stddevValues</b> (&quot;stddev&quot;, llvm::cl::desc(&quot;Standard deviation values s1,s2,s3...&quot; &quot;Count must be equal to number of input channels.&quot;), llvm::cl::value_desc(&quot;float&quot;), llvm::cl::ZeroOrMore, llvm::cl::CommaSeparated, llvm::cl::cat(imageCat))</td></tr>
<tr class="separator:ab005bac048df0db93a0b0b245db7a379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfb8efde0ba1a6d79ba47862d4262f7"><td class="memItemLeft" align="right" valign="top"><a id="aabfb8efde0ba1a6d79ba47862d4262f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeMetadataHelper</b> (llvm::raw_fd_ostream &amp;file, llvm::StringRef type, int id, llvm::StringRef name)</td></tr>
<tr class="separator:aabfb8efde0ba1a6d79ba47862d4262f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137433bcd25bd8810ab15790e0122d52"><td class="memTemplParams" colspan="2"><a id="a137433bcd25bd8810ab15790e0122d52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a137433bcd25bd8810ab15790e0122d52"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a137433bcd25bd8810ab15790e0122d52">loadOperatorName&lt; caffe2::OperatorDef &gt;</a> (const caffe2::OperatorDef &amp;op)</td></tr>
<tr class="memdesc:a137433bcd25bd8810ab15790e0122d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of loadOperatorName for <a class="el" href="namespacecaffe2.html">caffe2</a>. <br /></td></tr>
<tr class="separator:a137433bcd25bd8810ab15790e0122d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bd78e6895c5d8403fb158dfcfdc3e1"><td class="memItemLeft" align="right" valign="top"><a id="a66bd78e6895c5d8403fb158dfcfdc3e1"></a>
llvm::cl::OptionCategory&#160;</td><td class="memItemRight" valign="bottom"><b>loaderOptCat</b> (&quot;Model <a class="el" href="classglow_1_1_loader.html">Loader</a> Options&quot;)</td></tr>
<tr class="separator:a66bd78e6895c5d8403fb158dfcfdc3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f58b65e79d719f8f99b784bc475ab9"><td class="memItemLeft" align="right" valign="top"><a id="a96f58b65e79d719f8f99b784bc475ab9"></a>
<a class="el" href="classglow_1_1_scheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createScheduler</b> (<a class="el" href="namespaceglow.html#af5b11a9c44f948717d6a886891a58b11">SchedulerKind</a> schedulerKind, <a class="el" href="classglow_1_1_function.html">Function</a> &amp;G, <a class="el" href="namespaceglow.html#a40ec79a2f9c485bfa999ed31fd0854dd">NodesPtrList</a> &amp;scheduled)</td></tr>
<tr class="separator:a96f58b65e79d719f8f99b784bc475ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c8b77b4e7f8471121f521d2440a8fb"><td class="memItemLeft" align="right" valign="top"><a id="aa9c8b77b4e7f8471121f521d2440a8fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortMinMemory</b> (const std::pair&lt; <a class="el" href="classglow_1_1_function.html">Function</a> *, uint64_t &gt; &amp;a, const std::pair&lt; <a class="el" href="classglow_1_1_function.html">Function</a> *, uint64_t &gt; &amp;b)</td></tr>
<tr class="separator:aa9c8b77b4e7f8471121f521d2440a8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e729945d88b4bfa527188a544be28ae"><td class="memItemLeft" align="right" valign="top"><a id="a4e729945d88b4bfa527188a544be28ae"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>istreamReadFunc</b> (void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)</td></tr>
<tr class="separator:a4e729945d88b4bfa527188a544be28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3117c43e5a5db4bb0b77626d02db0e1c"><td class="memItemLeft" align="right" valign="top"><a id="a3117c43e5a5db4bb0b77626d02db0e1c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ostreamWriteFunc</b> (void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)</td></tr>
<tr class="separator:a3117c43e5a5db4bb0b77626d02db0e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b45dc331a5845df9ca8e95503c09b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a2f4b45dc331a5845df9ca8e95503c09b">emittingBundle</a> ()</td></tr>
<tr class="separator:a2f4b45dc331a5845df9ca8e95503c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1945e52546b506e9c6692b42e6ff78bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a1945e52546b506e9c6692b42e6ff78bd">profilingGraph</a> ()</td></tr>
<tr class="separator:a1945e52546b506e9c6692b42e6ff78bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc23c570ca5e61718fee9c00d1c49ee"><td class="memItemLeft" align="right" valign="top"><a id="aefc23c570ca5e61718fee9c00d1c49ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aefc23c570ca5e61718fee9c00d1c49ee">parseCommandLine</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:aefc23c570ca5e61718fee9c00d1c49ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse/verify command line parameters. <br /></td></tr>
<tr class="separator:aefc23c570ca5e61718fee9c00d1c49ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aead878efec317164091814dc580e53bf"><td class="memItemLeft" align="right" valign="top"><a id="aead878efec317164091814dc580e53bf"></a>
constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#aead878efec317164091814dc580e53bf">profilingBackend</a> = &quot;Interpreter&quot;</td></tr>
<tr class="memdesc:aead878efec317164091814dc580e53bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The backend name used in Glow quantization profiling. <br /></td></tr>
<tr class="separator:aead878efec317164091814dc580e53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1aa614344d723c1b14942f55e0a92b4"><td class="memItemLeft" align="right" valign="top"><a id="ad1aa614344d723c1b14942f55e0a92b4"></a>
<a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad1aa614344d723c1b14942f55e0a92b4">imageNormMode</a></td></tr>
<tr class="memdesc:ad1aa614344d723c1b14942f55e0a92b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">-image-mode flag. <br /></td></tr>
<tr class="separator:ad1aa614344d723c1b14942f55e0a92b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89e6d465a90abbf0dd62935035c1de"><td class="memItemLeft" align="right" valign="top"><a id="a3f89e6d465a90abbf0dd62935035c1de"></a>
<a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a3f89e6d465a90abbf0dd62935035c1de">imageChannelOrder</a></td></tr>
<tr class="memdesc:a3f89e6d465a90abbf0dd62935035c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">-image-channel-order flag. <br /></td></tr>
<tr class="separator:a3f89e6d465a90abbf0dd62935035c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53107002ac2c9f4c49145ee80843a1da"><td class="memItemLeft" align="right" valign="top"><a id="a53107002ac2c9f4c49145ee80843a1da"></a>
<a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#a53107002ac2c9f4c49145ee80843a1da">imageLayout</a></td></tr>
<tr class="memdesc:a53107002ac2c9f4c49145ee80843a1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">-image-layout flag. <br /></td></tr>
<tr class="separator:a53107002ac2c9f4c49145ee80843a1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2953fbb5442af152c75ab1643f856d6"><td class="memItemLeft" align="right" valign="top"><a id="ae2953fbb5442af152c75ab1643f856d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ae2953fbb5442af152c75ab1643f856d6">useImagenetNormalization</a></td></tr>
<tr class="memdesc:ae2953fbb5442af152c75ab1643f856d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">-use-imagenet-normalization flag. <br /></td></tr>
<tr class="separator:ae2953fbb5442af152c75ab1643f856d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3510e99ab11ddcc872188167c4df8f4f"><td class="memItemLeft" align="right" valign="top"><a id="a3510e99ab11ddcc872188167c4df8f4f"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_DUMP_ELEMS</b> = 100</td></tr>
<tr class="separator:a3510e99ab11ddcc872188167c4df8f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f08a2140a5cc78d31a81f4562f89af5"><td class="memItemLeft" align="right" valign="top"><a id="a7f08a2140a5cc78d31a81f4562f89af5"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>max_tensor_dimensions</b> = 6</td></tr>
<tr class="separator:a7f08a2140a5cc78d31a81f4562f89af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad352d0b626337dc5b2e9ef7593268075"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad352d0b626337dc5b2e9ef7593268075">DebugFlag</a> = false</td></tr>
<tr class="memdesc:ad352d0b626337dc5b2e9ef7593268075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if '-debug-glow' command line option is specified.  <a href="#ad352d0b626337dc5b2e9ef7593268075">More...</a><br /></td></tr>
<tr class="separator:ad352d0b626337dc5b2e9ef7593268075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e03f233498b5c733d2c0a68ffe2d57"><td class="memItemLeft" align="right" valign="top"><a id="ad1e03f233498b5c733d2c0a68ffe2d57"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceglow.html#ad1e03f233498b5c733d2c0a68ffe2d57">TensorAlignment</a> = 64</td></tr>
<tr class="memdesc:ad1e03f233498b5c733d2c0a68ffe2d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor payload is allocated to be aligned to this value. <br /></td></tr>
<tr class="separator:ad1e03f233498b5c733d2c0a68ffe2d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9609dfd219f56d45c74ba38656f8dca"><td class="memItemLeft" align="right" valign="top"><a id="af9609dfd219f56d45c74ba38656f8dca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GlowEnableLoadBalancedPartitioning</b> = false</td></tr>
<tr class="separator:af9609dfd219f56d45c74ba38656f8dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (c) Glow Contributors. See CONTRIBUTORS file.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Copyright (c) Glow Contributors. See CONTRIBUTORS file.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License."); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Copyright (c) Glow Contributors. See CONTRIBUTORS file.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.This file describes the API used for graph verification. These are mainly helper class/functions for printing errors and the related context and doing checks.</p>
<p>Copyright (c) Glow Contributors. See CONTRIBUTORS file.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.NOTE: please only use code and macros that resides outside of the detail namespace in <a class="el" href="_error_8h_source.html">Error.h</a> and Error.cpp so as to preserve a layer of abstraction between Error/Expected types and the specific classes that implement them.</p>
<p>These hash functions are required for using llvm::hash_combine. hash_value functions should be defined in the same namespace as the types they apply to. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a419aca63ca48becda137d774dd06493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419aca63ca48becda137d774dd06493c">&#9670;&nbsp;</a></span>LoweredInfoMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceglow.html#a419aca63ca48becda137d774dd06493c">glow::LoweredInfoMap</a> = typedef llvm::StringMap&lt;std::set&lt;<a class="el" href="structglow_1_1_node_name_and_kind.html">NodeNameAndKind</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to keep track of the origin of lowered Nodes via output names as determined by <a class="el" href="structglow_1_1_node_quantization_info.html#a95eecb61266bd5b736d50b7904a6c95d">NodeQuantizationInfo::generateNodeOutputName()</a>. For example if some <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> X is lowered from some <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Y, then the output name of X is a key which maps to a set of names which contains the output name of Y. </p>

</div>
</div>
<a id="a32fc0e338408955f80a23cc7e0c0c82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fc0e338408955f80a23cc7e0c0c82e">&#9670;&nbsp;</a></span>TensorInitializer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceglow.html#a32fc0e338408955f80a23cc7e0c0c82e">glow::TensorInitializer</a> = typedef std::function&lt;void( <a class="el" href="classglow_1_1_function.html">Function</a> *F, <a class="el" href="classglow_1_1_node.html">Node</a> *node, unsigned inputIdx, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *tensor)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> for <code>tensor</code> initialization. Method gets following parameters Glow <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code>, current <code>node</code>, <code>inputIdx</code>, and fills out <code>tensor</code>. </p>

</div>
</div>
<a id="a0ca574644e1e42ef193a9947fb4d8911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca574644e1e42ef193a9947fb4d8911">&#9670;&nbsp;</a></span>unsigned_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">glow::unsigned_t</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is used to implement the <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> and <a class="el" href="classglow_1_1_instruction.html" title="This represents an instruction in our IR. ">Instruction</a> builder's MemberType::Unsigned and MemberType::VectorUnsigned. Thus it should be used when handling members of these classes, e.g. a convolution Node/Instr's getGroup() (Unsigned), or getKernels() (UnsignedVector). </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a56845b9c860fa69d01d2084361d7c1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56845b9c860fa69d01d2084361d7c1f0">&#9670;&nbsp;</a></span>ConvergenceMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#a56845b9c860fa69d01d2084361d7c1f0">glow::ConvergenceMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies convergence mode for a <a class="el" href="classglow_1_1_function_pass.html">FunctionPass</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a56845b9c860fa69d01d2084361d7c1f0accd4cef52fe08da3eeac0e4396a2aca2"></a>OnePass&#160;</td><td class="fielddoc"><p>Run a single pass over the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a56845b9c860fa69d01d2084361d7c1f0a1a3fe1603e0a452b098a101b7d833f87"></a>UntilFixedPoint&#160;</td><td class="fielddoc"><p>Run the pass over the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> until a fixed point is reached. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6b85539f22b3e3292adf202254f0da1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b85539f22b3e3292adf202254f0da1e">&#9670;&nbsp;</a></span>DCERequiredMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#a6b85539f22b3e3292adf202254f0da1e">glow::DCERequiredMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the pass requires DCE. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6b85539f22b3e3292adf202254f0da1eaff7ad7af6ac42e36a5d538e74cde072d"></a>BeforePass&#160;</td><td class="fielddoc"><p>Require that DCE is run before the pass. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6b85539f22b3e3292adf202254f0da1ea6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Signify the pass has no requirement/dependence on DCE. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab92e14a94329daf4083db670e95fbcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92e14a94329daf4083db670e95fbcdf">&#9670;&nbsp;</a></span>ElemKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">glow::ElemKind</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enum representing the type used by the elements of a tensor. The types of Handles for these tensors should match the element kind. When adding new type, note that this enum definition must match with ElemKind definition in Glow/lib/Backends/CPU/libjit/libjit.cpp </p>

</div>
</div>
<a id="a3157945b92abd634c79fa9d4724472eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3157945b92abd634c79fa9d4724472eb">&#9670;&nbsp;</a></span>FunctionPassID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#a3157945b92abd634c79fa9d4724472eb">glow::FunctionPassID</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define an enum to identify all FunctionPasses, used to declare inside a <a class="el" href="classglow_1_1_function_pass_config.html">FunctionPassConfig</a> for a Pipeline. </p>

</div>
</div>
<a id="a1c98da7214165b41c7d6b255503d4062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c98da7214165b41c7d6b255503d4062">&#9670;&nbsp;</a></span>FunctionState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#a1c98da7214165b41c7d6b255503d4062">glow::FunctionState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State of a function. This can be used to control optimizations which depend on the state of the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. This is a temporary workaround until GH Issue #3213 is complete. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c98da7214165b41c7d6b255503d4062a3c96962620eddda2836d6203cf7ecfa0"></a>FuncCreated&#160;</td><td class="fielddoc"><p>Indicates that the function has been created but not completely loaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c98da7214165b41c7d6b255503d4062ae25a0b7e15a925b8bf4d8016db8d27ac"></a>FuncLoaded&#160;</td><td class="fielddoc"><p>Indicates that the function has been completely loaded. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab04a18d4367765236e5de54c47379e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04a18d4367765236e5de54c47379e66">&#9670;&nbsp;</a></span>MemoryAreaKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#ab04a18d4367765236e5de54c47379e66">glow::MemoryAreaKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Different kinds of memory areas used by the emitted LLVM function. The order is important. It should match the order of base addresses arguments passed to "main". </p>

</div>
</div>
<a id="af5b11a9c44f948717d6a886891a58b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b11a9c44f948717d6a886891a58b11">&#9670;&nbsp;</a></span>SchedulerKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceglow.html#af5b11a9c44f948717d6a886891a58b11">glow::SchedulerKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the kind of graph scheduling to perform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af5b11a9c44f948717d6a886891a58b11aca8f7fd5d3a60fdbaaa2f584621c7759"></a>ChildMemSizeBased&#160;</td><td class="fielddoc"><p>This is a heuristics that tries to minimize memory usage. </p>
</td></tr>
<tr><td class="fieldname"><a id="af5b11a9c44f948717d6a886891a58b11afc2c746e636936c8ce50270012da3147"></a>TopologicalSortBased&#160;</td><td class="fielddoc"><p>Performs a standard topological search. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9052142cd801c37c1dd49a3b139682d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9052142cd801c37c1dd49a3b139682d9">&#9670;&nbsp;</a></span>allows64To32Downcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::allows64To32Downcast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>dst</code> allows <code>src</code> to be converted from 64 to 32 bits. </dd></dl>

</div>
</div>
<a id="ac2c06e353dbcd4a5d2af024633fdaadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c06e353dbcd4a5d2af024633fdaadb">&#9670;&nbsp;</a></span>allows64To32Downcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::allows64To32Downcast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_storage.html">Storage</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>V</code> can be converted from a 64 to 32 bit value at runtime. </dd></dl>

</div>
</div>
<a id="adce5a7edd1093d119dbed94a5dce5cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce5a7edd1093d119dbed94a5dce5cdf">&#9670;&nbsp;</a></span>assignLogicalDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeviceIDTy glow::assignLogicalDeviceID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>backendMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign the logicalDevice ID to each partition. The partitions with the same logicalDevice ID will be assigned on the same physical devices. E.g: there are 3 partitions node1(6GB) -&gt; node2(14GB) -&gt; node3(6GB). But we only have 2 devices with 16GB memory. The logicalDevice ID assigning rules are:</p><ol type="1">
<li>For each type of backend, if the number of available physical devices is equal or larger than the number of partitions, different partitions are assigned with a different logicalDevice ID(i.e. each partition will be put on a different physical device for execution). E.g. we have 3 partitions node1-&gt;node2-&gt;node3, and 3 devices, the logicalDevice ID for each partition with be (node1, 0), (node2, 1), and (node3, 2).</li>
<li>For each type of backend, if the number of available physical devices is smaller than the number of partitions, and we can find a way to put all partitions on those pysical devices, this assignment will be applied and the partitions on the same physical devices will be assigned the same logicalDevice ID. E.g: there are 3 partitions node1(6GB) -&gt; node2(14GB) -&gt; node3(6GB). But we only have 2 devices with 16GB memory. The assignment will be : (node1, 0), (node2, 1), (node3, 0).</li>
<li>For each type of backend, if the number of available physical devices is smaller than the number of partitions, and we can not find a way to put all partitions on those pysical devices, we assign defferent partitions with different logicalDevice ID. E.g: there are 3 partitions node1(6GB) -&gt; node2(14GB) -&gt; node3(6GB). But we only have 1 device with 16GB memory. The assignment will be : (node1, 0), (node2, 1), (node3, 2). That is, even we can put node1 and node3 on the same device, we won't do it. </li>
</ol>

</div>
</div>
<a id="a110f6a4f4c9801ecca0c96826b3888ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110f6a4f4c9801ecca0c96826b3888ff">&#9670;&nbsp;</a></span>calculate3DConvPoolOutputDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structglow_1_1_shape_h_w_d.html">ShapeHWD</a> glow::calculate3DConvPoolOutputDims </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the size of the output tensor based on the 3D convolution/pooling parameters <code>inH</code> <code>inW</code>, <code>inT</code> which are the input's height, width, and depth respectively. </p>

</div>
</div>
<a id="a3623979e9cf3437802bf2f23d15b425e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3623979e9cf3437802bf2f23d15b425e">&#9670;&nbsp;</a></span>calculateConvPoolOutputDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t, size_t&gt; glow::calculateConvPoolOutputDims </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the size of the output tensor based on the convolution/pooling parameters. </p>

</div>
</div>
<a id="ab310f352073eee80ddb68b3cfaa14e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab310f352073eee80ddb68b3cfaa14e12">&#9670;&nbsp;</a></span>checkNoFusion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt;!has_getFusedActivation&lt; T, FusedActivation &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkNoFusion </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>N</code> does not have fused activation. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="a740e326204223c25d80b8b07e99dac18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740e326204223c25d80b8b07e99dac18">&#9670;&nbsp;</a></span>checkNoFusionForInstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkNoFusionForInstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>I</code> does not have fused activation. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="ad4ca93d79211ec0bc67ed8524634e69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ca93d79211ec0bc67ed8524634e69a">&#9670;&nbsp;</a></span>checkNoFusionForNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkNoFusionForNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>N</code> does not have fused activation. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="a4b41db469b7a600c65a7e57665a72474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b41db469b7a600c65a7e57665a72474">&#9670;&nbsp;</a></span>checkNotQuantizedOrSameParams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkNotQuantizedOrSameParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if <code>A</code> is not quantized or has its quantization parameters match <code>scale</code> and <code>offset</code>. False otherwise. <code>parent</code> is used to print the context of that check in case the it fails. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="a3b27e9f4187aa476d1a4f3414b4f5dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b27e9f4187aa476d1a4f3414b4f5dcb">&#9670;&nbsp;</a></span>checkNotQuantizedOrSameParams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkNotQuantizedOrSameParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if <code>A</code> is not quantized or matches <code>B</code> quantization parameters. False otherwise. In particular, this returns false if <code>A</code> is quantized and <code>B</code> is not. The opposite is not true. <code>parent</code> is used to print the context of that check in case the it fails. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="a9d3dd221c6d43bfa4d2e54ff8640604b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3dd221c6d43bfa4d2e54ff8640604b">&#9670;&nbsp;</a></span>checkSameIsQuantized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkSameIsQuantized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if <code>A</code> and <code>B</code> have the same value for isQuantized. <code>parent</code> is used to print the context of that check in case the it fails. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="ae06ad0f896240c6ccea6cb9472e57e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06ad0f896240c6ccea6cb9472e57e2a">&#9670;&nbsp;</a></span>checkSameShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkSameShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the shape of the first operand <code>A</code> matches the shape of the second operand <code>B</code>. <code>parent</code> is used to print the context of that check in case the it fails. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="a1963e99917ffdb1fdd70911811002792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1963e99917ffdb1fdd70911811002792">&#9670;&nbsp;</a></span>checkSameType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkSameType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the type of the first operand <code>A</code> matches the type of the second operand <code>B</code>. <code>parent</code> is used to print the context of that check in case the it fails. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="a5321bd4a40acf901a0d9b8eb2e25f4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5321bd4a40acf901a0d9b8eb2e25f4ae">&#9670;&nbsp;</a></span>checkType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>expectedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the element type of the operand <code>A</code> matches expected type <code>expectedType</code>. <code>parent</code> is used to print the context of that check in case the it fails. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="a06107a1368ca70c82884f7a7863a0599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06107a1368ca70c82884f7a7863a0599">&#9670;&nbsp;</a></span>checkType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> &gt;&#160;</td>
          <td class="paramname"><em>expectedTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the element type of the operand <code>A</code> matches any of the expected types <code>expectedTypes</code>. <code>parent</code> is used to print the context of that check in case the it fails. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="abfafc7403160bca58a7672d68c2d944d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfafc7403160bca58a7672d68c2d944d">&#9670;&nbsp;</a></span>checkTypeIgnoreShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::checkTypeIgnoreShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the type of the first operand <code>A</code> matches the type of the second operand <code>B</code> but ignore the actual shape. <a class="el" href="structglow_1_1_use.html">Use</a> only element type and quantization parameters in comparison. <code>parent</code> is used to print the context of that check in case the it fails. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceglow.html#afd8e77c649bf3668467058ae071bb875">expectCompareTrue</a> for more details. </dd></dl>

</div>
</div>
<a id="a0e523cb23b972dda0c52eb9c841a1d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e523cb23b972dda0c52eb9c841a1d33">&#9670;&nbsp;</a></span>constantFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classglow_1_1_constant.html">Constant</a> * &gt; glow::constantFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a compile-time constant folding of the node <code>N</code>. </p><dl class="section return"><dt>Returns</dt><dd>list of constants which are the result of the constant-folding. These constants correspond to results of the node. If no constant folding was possible an empty vector will be returned. </dd></dl>

</div>
</div>
<a id="a6f10f8f52d528b3ceb40892376bc1fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f10f8f52d528b3ceb40892376bc1fb9">&#9670;&nbsp;</a></span>constantFoldInLoader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LoaderType , class OpType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::constantFoldInLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderType &amp;&#160;</td>
          <td class="paramname"><em>tmpLoader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderType *&#160;</td>
          <td class="paramname"><em>loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpType &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>success if the folding of operator <code>op</code> in the loader <code>loader</code> is successful. The folding utility uses temporary loader <code>tmpLoader</code>, and associated temporary function <code>F</code>. </dd></dl>

</div>
</div>
<a id="a277fade8bad1b16fc8c084ce52ba6f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277fade8bad1b16fc8c084ce52ba6f92">&#9670;&nbsp;</a></span>convertConvGradToNCHWConvGrad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="structglow_1_1_node_value.html">NodeValue</a>, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&gt; glow::convertConvGradToNCHWConvGrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_convolution_grad_node.html">ConvolutionGradNode</a> *&#160;</td>
          <td class="paramname"><em>CGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert regular <a class="el" href="classglow_1_1_convolution_grad_node.html">ConvolutionGradNode</a> that uses NHWC into a <a class="el" href="classglow_1_1_convolution_grad_node.html">ConvolutionGradNode</a> that uses NCHW. </p>

</div>
</div>
<a id="aeac40bd989fd3bcb403ecfbf8c120600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac40bd989fd3bcb403ecfbf8c120600">&#9670;&nbsp;</a></span>convertConvToNCHWConv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a>* glow::convertConvToNCHWConv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> *&#160;</td>
          <td class="paramname"><em>CN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert regular convolution nodes (that use NHWC) into a backend-specific convolution nodes using NCHW. </p>

</div>
</div>
<a id="ab2669a16ac3c54145c294457d6554cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2669a16ac3c54145c294457d6554cb4">&#9670;&nbsp;</a></span>convertEnumToUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string constexpr unsigned glow::convertEnumToUnsigned </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper that converts and </p><dl class="section return"><dt>Returns</dt><dd>an enum class to an unsigned. Useful when using an enum class in a bitset. </dd></dl>

</div>
</div>
<a id="aef265ed4d4604e471d8b5662c3f5a423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef265ed4d4604e471d8b5662c3f5a423">&#9670;&nbsp;</a></span>convertFunctionToFloat16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::convertFunctionToFloat16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_precision_configuration.html">PrecisionConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>precConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts all inputs and outputs of a function <code>F</code> from Float to Float16, and from UInt8FusedQTy to UInt8FusedFP16QTy, based on <code>precConfig</code>. </p>

</div>
</div>
<a id="a67b90e6ec31547354c4e796d906cebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b90e6ec31547354c4e796d906cebd0">&#9670;&nbsp;</a></span>convertMaxPoolToNCHWPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classglow_1_1_node.html">Node</a> *, <a class="el" href="classglow_1_1_node.html">Node</a> *&gt; glow::convertMaxPoolToNCHWPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_max_pool_node.html">MaxPoolNode</a> *&#160;</td>
          <td class="paramname"><em>PN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert regular max pool nodes (that use NHWC) into backend-specific nodes using NCHW. </p><dl class="section return"><dt>Returns</dt><dd>a pair containing the new MaxPool result and argmax that the result and argmax of the original MaxPool should be replaced with. </dd></dl>

</div>
</div>
<a id="a7c4fddd8b31e37460f88d44f076a2863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4fddd8b31e37460f88d44f076a2863">&#9670;&nbsp;</a></span>convertPlaceholdersToConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::convertPlaceholdersToConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert placeholders in <a class="el" href="classglow_1_1_module.html">Module</a> <code>M</code> to constants based on the values in <code>bindings</code>. Do not convert any placeholders explicitly listed in <code>vars</code>. </p>

</div>
</div>
<a id="a9e0b594543fb42b8b6ad0cc556ee9829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0b594543fb42b8b6ad0cc556ee9829">&#9670;&nbsp;</a></span>createDefaultFoldPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a> glow::createDefaultFoldPassPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the default fold pipeline. </dd></dl>

</div>
</div>
<a id="afd7544cbea4219b8f3c720d6a4e19481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7544cbea4219b8f3c720d6a4e19481">&#9670;&nbsp;</a></span>createDefaultGraphOptimizationPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a> glow::createDefaultGraphOptimizationPassPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the default, target-independent graph optimization pipeline </dd></dl>

</div>
</div>
<a id="a2cba8b151906d972e63ced04b7e02242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cba8b151906d972e63ced04b7e02242">&#9670;&nbsp;</a></span>createFP16GraphOptimizationPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_function_pass_pipeline.html">FunctionPassPipeline</a> glow::createFP16GraphOptimizationPassPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the fp16 specific optimization pipeline </dd></dl>

</div>
</div>
<a id="a77f32741a0e156b7bd043992d6eedc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f32741a0e156b7bd043992d6eedc6c">&#9670;&nbsp;</a></span>createFunctionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classglow_1_1_function_pass.html">FunctionPass</a>&gt; glow::createFunctionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a3157945b92abd634c79fa9d4724472eb">FunctionPassID</a>&#160;</td>
          <td class="paramname"><em>passID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper that creates and. </p>
<p>Copyright (c) Glow Contributors. See CONTRIBUTORS file.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_function_pass.html">FunctionPass</a> given a provided <code>passID</code>. </dd></dl>

</div>
</div>
<a id="ad40999bf88c854e1ca4bcbfa9efbd119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40999bf88c854e1ca4bcbfa9efbd119">&#9670;&nbsp;</a></span>dagValidation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::dagValidation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structglow_1_1runtime_1_1_d_a_g.html">DAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the current partition is a valid DAG. This check can only be called after a real partition is created and the DAG is generated. </p>

</div>
</div>
<a id="a64763ac9b2b790fea832124d0b2d401a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64763ac9b2b790fea832124d0b2d401a">&#9670;&nbsp;</a></span>dbgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; glow::dbgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>output stream for debug messages. </dd></dl>

</div>
</div>
<a id="a8d2a21b045e4c1595f1da56d34750169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2a21b045e4c1595f1da56d34750169">&#9670;&nbsp;</a></span>differentiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_function.html">Function</a> * glow::differentiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_training_config.html">TrainingConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>newFuncName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableGradientsList *&#160;</td>
          <td class="paramname"><em>varGrads</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> that 'trains' the input <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. We differentiate the nodes and insert code to update the weights based on the <code>config</code> parameters. If <code>varGrads</code> is set then instead of inserting code to update the weights, the procedure adds code to record the last gradient value: a list of (var, grad_var) pairs associating variables with their gradient variables. This feature is used by the gradient-check unit tests. </p><dl class="section return"><dt>Returns</dt><dd>a new function with the name <code>newFuncName</code>. </dd></dl>

</div>
</div>
<a id="a2f4b45dc331a5845df9ca8e95503c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b45dc331a5845df9ca8e95503c09b">&#9670;&nbsp;</a></span>emittingBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::emittingBundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if emit bundle mode is enabled. </dd></dl>

</div>
</div>
<a id="ad5afe057375ea161648698052cdeef25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5afe057375ea161648698052cdeef25">&#9670;&nbsp;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; glow::errs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>output stream for stderr. </dd></dl>

</div>
</div>
<a id="a0c9f98855ca17db059deb4688e051e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9f98855ca17db059deb4688e051e61">&#9670;&nbsp;</a></span>escapeDottyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string glow::escapeDottyString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the escaped content of string <code>str</code>. The char '<br />
' becomes '\'+'n' and quotes are handled correctly. </dd></dl>

</div>
</div>
<a id="ad7385d41afaa1bd063dfa1b74e693ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7385d41afaa1bd063dfa1b74e693ad1">&#9670;&nbsp;</a></span>evalBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::evalBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_execution_engine.html">ExecutionEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>EE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numMinibatchRuns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>sampleCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>inputPH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>outputPH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>samplesInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>labelsInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;sampleIn, const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;sampleOut, const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;label, size_t sampleIndex)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs <code>numMinibatchRuns</code> iterations of the compiled function called <code>name</code>. The method updates a global counter and future invocations of this method continue running iterations of the batch at the next available slice. The provided callback function <code>cb</code> is invoked on each sample. </p>

</div>
</div>
<a id="a6bf1f1f5a7c61022904299bfeee07b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf1f1f5a7c61022904299bfeee07b34">&#9670;&nbsp;</a></span>executeConstantFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::executeConstantFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;&#160;</td>
          <td class="paramname"><em>cctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute function <code>F</code> by the <code>backend</code> using the provided <code>bindings</code> and the compilation context <code>cctx</code>. </p><dl class="section return"><dt>Returns</dt><dd>error if function is not a constant function. </dd></dl>

</div>
</div>
<a id="a130f47cd21711d9244adfb418ffbe9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130f47cd21711d9244adfb418ffbe9f7">&#9670;&nbsp;</a></span>executeVerticalFCWeightsSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::executeVerticalFCWeightsSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numOfChunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minKToSplit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform vertical split of FC weights in a given function. Optimization could facilitate parallel execution of FCs on multiple device cores. </p><dl class="section return"><dt>Returns</dt><dd>true in case split took place. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>function to optimize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfChunks</td><td>number of chunks to split weights and bias into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minKToSplit</td><td>minimum size of the second dimension of weights when the split is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a384dccb23b7bc3ade84b8f5c64b1f136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384dccb23b7bc3ade84b8f5c64b1f136">&#9670;&nbsp;</a></span>expandDimsToMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShapeVector glow::expandDimsToMax </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>currDims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function that </p><dl class="section return"><dt>Returns</dt><dd>a ShapeVector of those dimensions in <code>currDims</code> expanded with dimension = 1 until the maximum tensor dimension is reached. The number of elements in the input dims is the same as in the returned dims. For example, input {2,1,4} would result in {2,1,4,1,1,1}. </dd></dl>

</div>
</div>
<a id="afd8e77c649bf3668467058ae071bb875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8e77c649bf3668467058ae071bb875">&#9670;&nbsp;</a></span>expectCompareTrue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputTy , typename ParentTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool glow::expectCompareTrue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputTy &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputTy &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParentTy *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_compare_with_name.html">CompareWithName</a>&lt; InputTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code><a class="el" href="structglow_1_1_compare_operator_equal.html">CompareOperatorEqual</a>&lt;InputTy&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main API of the verifier. Check whether <code>comp</code>(<code>a</code>, <code>b</code>) is true. If that check fails, <code>msg</code> is printed out using <a class="el" href="namespaceglow.html#a9d164b45d9fb735f448cd7985bcdf203" title="Print msg on the error stream. ">glow::report</a> and <code>parent</code> (if not nullptr), <code>a</code>, and <code>b</code> are printed out using <a class="el" href="namespaceglow.html#a5efbd9d8157489eb3b55e5c9fafb5fb7">glow::reportContext</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>comp</code>(<code>a</code>, <code>b</code>). </dd></dl>

</div>
</div>
<a id="a77a6fef6be3a014626580088a1a72842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a6fef6be3a014626580088a1a72842">&#9670;&nbsp;</a></span>expectCompareTrue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool glow::expectCompareTrue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputTy &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; InputTy &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_compare_with_name.html">CompareWithName</a>&lt; InputTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code><a class="el" href="structglow_1_1_compare_operator_equal.html">CompareOperatorEqual</a>&lt;InputTy&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether $V_{0,n}{comp(<code>a</code>, <code>b_i</code>)}$ is true. If that check fails, <code>msg</code> is printed out using <a class="el" href="namespaceglow.html#a9d164b45d9fb735f448cd7985bcdf203" title="Print msg on the error stream. ">glow::report</a> and <code>parent</code> (if not nullptr), <code>a</code>, and <code>b</code> are printed out using <a class="el" href="namespaceglow.html#a5efbd9d8157489eb3b55e5c9fafb5fb7">glow::reportContext</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>comp</code>(<code>a</code>, <code>b_0</code>) v ... v comp(<code>a</code>, <code>b_i</code>). </dd></dl>

</div>
</div>
<a id="a47d2c5f23a3db76b44bbf76e2d41f60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d2c5f23a3db76b44bbf76e2d41f60d">&#9670;&nbsp;</a></span>flattenCdr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t, size_t&gt; glow::flattenCdr </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collapse a tensor shape into two sizes: the first n dimensions and the size of the rest of the dimensions. For example, ([7, 3, 4, 2], 1) -&gt; [7, 24] </p>

</div>
</div>
<a id="a100064cb8d6d8c2aae54f4a114cf48f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100064cb8d6d8c2aae54f4a114cf48f4">&#9670;&nbsp;</a></span>generateAndOptimizeIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &gt; glow::generateAndOptimizeIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldShareBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper to generate and optimize IR from given <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code>. <code>shouldShareBuffers</code> signifies whether to use the share buffers optimization. <a class="el" href="classglow_1_1_backend.html">Backend</a> /p B is used to allow for custom lowering from <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> to <a class="el" href="classglow_1_1_instruction.html" title="This represents an instruction in our IR. ">Instruction</a> IR. </p>

</div>
</div>
<a id="a9d06550bdaa17730cb67e8a086db767c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d06550bdaa17730cb67e8a086db767c">&#9670;&nbsp;</a></span>generateNodeKindsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; Kinded::Kind &gt; glow::generateNodeKindsSet </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a node name string (e.g. "Div,Add") <code>names</code>, </p><dl class="section return"><dt>Returns</dt><dd>a set of NodeKinds corresponding to the names in the string. </dd></dl>

</div>
</div>
<a id="a44d3450f4f150909deaf8e5939537d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d3450f4f150909deaf8e5939537d51">&#9670;&nbsp;</a></span>genericTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::genericTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>shuffle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump a textual representation of a specific number of elements in the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> to std::string. </p>

</div>
</div>
<a id="ab32aaca1a37daa0543ca953df2110b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32aaca1a37daa0543ca953df2110b63">&#9670;&nbsp;</a></span>getAllocationOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_value.html">Value</a> * glow::getAllocationOrigin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the allocation corrsponding to th value <code>V</code>. It can look through tensorview instructions. </p><dl class="section return"><dt>Returns</dt><dd>found allocation or nullptr. </dd></dl>

</div>
</div>
<a id="acfa7d1d30cd1420a7a651fa3d63b33e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa7d1d30cd1420a7a651fa3d63b33e6">&#9670;&nbsp;</a></span>getBFSLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#a03e8d2f34b0b5876fd4f7abaf0a0d73d">BFSLevel</a> glow::getBFSLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit nodes if <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code> in BFS order and return the nodes by levels (the longest distance between one node and the root).</p>
<p>The nodes in function <code>F</code> which be grouped into levels based on how far (the longest distance) they are from the roots. </p>

</div>
</div>
<a id="ac81027b5844dd48c60ba42e8169f19c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81027b5844dd48c60ba42e8169f19c2">&#9670;&nbsp;</a></span>getContiguousPlaceHolder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FUN , typename ARR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ContiguousPlaceholders glow::getContiguousPlaceHolder </td>
          <td>(</td>
          <td class="paramtype">const ARR &amp;&#160;</td>
          <td class="paramname"><em>holders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FUN &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert placeholders to be ordered as input|inputOutput|output|neither. Packed into {<a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *, isInput, isOutput} as <a class="el" href="structglow_1_1_placeholder_input_output_info.html" title="Contains information for placeholder during allocation. ">PlaceholderInputOutputInfo</a>. FUN could be <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> or <a class="el" href="classglow_1_1_i_r_function.html" title="A function that represents the compilation unit. ">IRFunction</a>. ARR could be std::list&lt;Placeholder *&gt; or std::vector&lt;const Placeholder *&gt; </p>

</div>
</div>
<a id="a4fef74193703ceb204297b6993af8081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fef74193703ceb204297b6993af8081">&#9670;&nbsp;</a></span>getDCEPassConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_function_pass_config.html">FunctionPassConfig</a> glow::getDCEPassConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_function_pass_config.html">FunctionPassConfig</a> for performing DCE. </dd></dl>

</div>
</div>
<a id="abdedf715e997af0b1a4ad4b1882bed49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdedf715e997af0b1a4ad4b1882bed49">&#9670;&nbsp;</a></span>getDotFileNodeColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * glow::getDotFileNodeColor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the node color based on <code>index</code> which is used in dot file.</dd>
<dd>
the color based on <code>index</code> which is used in dot file. </dd></dl>

</div>
</div>
<a id="ad9cf5d13b978aa755ff9b01edad65466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cf5d13b978aa755ff9b01edad65466">&#9670;&nbsp;</a></span>getFloats()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; glow::getFloats </td>
          <td>(</td>
          <td class="paramtype">const AttrType *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a floating record vector from <code>arg</code>. </p><dl class="section return"><dt>Returns</dt><dd>a standard vector of floats. </dd></dl>

</div>
</div>
<a id="a589ee9d58bb8726a5e764b1dd74f8070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589ee9d58bb8726a5e764b1dd74f8070">&#9670;&nbsp;</a></span>getInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodesSet glow::getInputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a node,. </p>
<dl class="section return"><dt>Returns</dt><dd>the NodeSet of inputs of this node.</dd></dl>
<p>Given a node, </p><dl class="section return"><dt>Returns</dt><dd>the NodeSet of all nodes that create the results for any of the inputs of this node (i.e. input of inputs) </dd></dl>

</div>
</div>
<a id="af5d8953e310c3650356892fa4e866ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d8953e310c3650356892fa4e866ce3">&#9670;&nbsp;</a></span>getKindFromNodeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kinded::Kind glow::getKindFromNodeName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to get the Kind of a <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> (e.g. Kinded::Kind::AddNodeKind) given its <code>nodeName</code> (e.g. Add). </p>

</div>
</div>
<a id="a6195ce22fbeafd894c0ce148bb7a8a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6195ce22fbeafd894c0ce148bb7a8a9a">&#9670;&nbsp;</a></span>getNameOfPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StringRef glow::getNameOfPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a3157945b92abd634c79fa9d4724472eb">FunctionPassID</a>&#160;</td>
          <td class="paramname"><em>passID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of a <a class="el" href="classglow_1_1_function_pass.html">FunctionPass</a> given its <code>passID</code>. </dd></dl>

</div>
</div>
<a id="a59d8826ffac432ffcebc8dcd11a85816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d8826ffac432ffcebc8dcd11a85816">&#9670;&nbsp;</a></span>getNodeMemUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t glow::getNodeMemUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a node,. </p>
<dl class="section return"><dt>Returns</dt><dd>the memory usage of its inputs (i.e. <a class="el" href="classglow_1_1_storage.html">Storage</a> input). </dd></dl>

</div>
</div>
<a id="a455ad0b5511a75c369f14b06c1de37fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455ad0b5511a75c369f14b06c1de37fd">&#9670;&nbsp;</a></span>getOrigin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_value.html">Value</a> * glow::getOrigin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>peels off the layers of tensorviews from a value <code>V</code>. </dd></dl>

</div>
</div>
<a id="a582b647d0167e2bd46758cf24a691ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582b647d0167e2bd46758cf24a691ac3">&#9670;&nbsp;</a></span>getOrigin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglow_1_1_value.html">Value</a> * glow::getOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>peels off the layers of tensorviews from a value <code>V</code>. </dd></dl>

</div>
</div>
<a id="a7ec2658c25c6fddc1b6788888a930d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec2658c25c6fddc1b6788888a930d71">&#9670;&nbsp;</a></span>getOriginOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t glow::getOriginOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the offset into the <a class="el" href="classglow_1_1_value.html">Value</a> returned by getOrigin. </dd></dl>

</div>
</div>
<a id="a4c7ea6df70770cd2ccf2bbfb85077539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7ea6df70770cd2ccf2bbfb85077539">&#9670;&nbsp;</a></span>getOutMemPerNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t glow::getOutMemPerNode </td>
          <td>(</td>
          <td class="paramtype">const NodesSet &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the memory usage of the output caused by <code>node</code> who has users not in the set <code>nodes</code>. </dd></dl>

</div>
</div>
<a id="a493b517e027e3c2689248c644f3747b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493b517e027e3c2689248c644f3747b5">&#9670;&nbsp;</a></span>getOutputSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_save_node.html">SaveNode</a> * glow::getOutputSave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the first <a class="el" href="classglow_1_1_save_node.html" title="Specifies a node whose Input will be copied to Output.This node prevents graph optimizations from eli...">SaveNode</a> user of the placeholder <code>PH</code> or nullptr if none are found. </dd></dl>

</div>
</div>
<a id="ace2ce9f3fea11d339cd0605fe8ece061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2ce9f3fea11d339cd0605fe8ece061">&#9670;&nbsp;</a></span>getOutUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classglow_1_1_node.html">Node</a> * &gt; glow::getOutUsers </td>
          <td>(</td>
          <td class="paramtype">const NodesSet &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>nodes</code>, return a list of nodes who use any node in this set. </p>
<p>Given <code>nodes</code>, return a list of nodes who are not in this set but use any node in this set. </p>

</div>
</div>
<a id="a352ec64282f28b5487a23bf2d805a528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352ec64282f28b5487a23bf2d805a528">&#9670;&nbsp;</a></span>getOutUsersWithOnePredecessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classglow_1_1_node.html">Node</a> * &gt; glow::getOutUsersWithOnePredecessor </td>
          <td>(</td>
          <td class="paramtype">const NodesSet &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>nodes</code>, return a list of nodes who use only the nodes in this set or constant.</p>
<p>Given <code>nodes</code>, return a list of nodes who are not in this set but use only the nodes in this set or constant. </p>

</div>
</div>
<a id="a8a01d4f862cb83ad8979bfa1c5794930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a01d4f862cb83ad8979bfa1c5794930">&#9670;&nbsp;</a></span>getPngInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; size_t, size_t, bool &gt; glow::getPngInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a png image header from png file <code>filename</code> and </p><dl class="section return"><dt>Returns</dt><dd>a tuple containing height, width, and a bool if it is grayscale or not. </dd></dl>

</div>
</div>
<a id="aaee7b49ad6e84bdb1a42ac3e5bff797e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee7b49ad6e84bdb1a42ac3e5bff797e">&#9670;&nbsp;</a></span>getScaleOffsetElemKindFromFused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> glow::getScaleOffsetElemKindFromFused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the scale and offset ElemKind used by the fused ElemKind <code>e</code>. </dd></dl>

</div>
</div>
<a id="a5192591d333ee1a71b03325bb3d9f80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5192591d333ee1a71b03325bb3d9f80a">&#9670;&nbsp;</a></span>isCurrentDebugType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isCurrentDebugType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>type</code> matches the activated debug type. </dd></dl>

</div>
</div>
<a id="aeea823a4b44883f04b3cd7ba5eebb9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea823a4b44883f04b3cd7ba5eebb9ef">&#9670;&nbsp;</a></span>isFusedQuantizedElemKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isFusedQuantizedElemKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>e</code> is a fused quantized ElemKind. </dd></dl>

</div>
</div>
<a id="afbc28cae078d0b91e0bda921554f3ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc28cae078d0b91e0bda921554f3ae6">&#9670;&nbsp;</a></span>isInput() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>PH</code> is an input placeholder,. </p>
<p>If <code>PH</code> is an input placeholderin the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code>, </p><dl class="section return"><dt>Returns</dt><dd>true. This is determined by checking if the PH is the input to a saveNode or is used by a non saveNode.</dd>
<dd>
true. </dd></dl>

</div>
</div>
<a id="acb98192dd9bfc2315759db1806f01ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb98192dd9bfc2315759db1806f01ad1">&#9670;&nbsp;</a></span>isInput() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>PH</code> is an input placeholder in the function <code>F</code>,. </p>
<p>If <code>PH</code> is an input placeholder in the <a class="el" href="classglow_1_1_i_r_function.html" title="A function that represents the compilation unit. ">IRFunction</a> <code>F</code>, </p><dl class="section return"><dt>Returns</dt><dd>true. This is determined by checking if the PH is always used as an  parameter by the current function.</dd>
<dd>
true. </dd></dl>

</div>
</div>
<a id="aac10131240fff18a61a4f525541fe765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac10131240fff18a61a4f525541fe765">&#9670;&nbsp;</a></span>isInput() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classglow_1_1_function.html">Function</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>PH</code> is an input <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> for any function in <code>funcs</code>. </dd></dl>

</div>
</div>
<a id="af18ed78d6c309a7061f1b1318b9d8aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18ed78d6c309a7061f1b1318b9d8aca">&#9670;&nbsp;</a></span>isOutput() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structglow_1_1_use.html">Use</a> template meta-programming to check if typename ClassName contains getFusedActivation() method. Below generates a struct named has_getFusedActivation that looks for said method. If <code>PH</code> is an output placeholder in the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code>, </p><dl class="section return"><dt>Returns</dt><dd>true. This is determined by checking if the PH has a user which uses the PH as an overwritten input.</dd></dl>
<p>If <code>PH</code> is an output placeholder, </p><dl class="section return"><dt>Returns</dt><dd>true. This is determined by checking if the PH has a user which uses the PH as an overwritten input. </dd></dl>

</div>
</div>
<a id="a5a7a54e3291e2de0fa2c08e14cf1f36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7a54e3291e2de0fa2c08e14cf1f36b">&#9670;&nbsp;</a></span>isOutput() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>PH</code> is an output placeholder in the <a class="el" href="classglow_1_1_i_r_function.html" title="A function that represents the compilation unit. ">IRFunction</a> <code>F</code>, </p><dl class="section return"><dt>Returns</dt><dd>true. This is determined by checking if the PH has weights which are referenced by other Instructions as OperandKind::InOut or OperandKind::Out.</dd></dl>
<p>If <code>PH</code> is an output placeholder in the function <code>F</code>, </p><dl class="section return"><dt>Returns</dt><dd>true. This is determined by checking if the PH has a user which uses the PH as an overwritten input. </dd></dl>

</div>
</div>
<a id="ab3c36fb4023b57b7f2ea10ac4fe9c459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c36fb4023b57b7f2ea10ac4fe9c459">&#9670;&nbsp;</a></span>isOutput() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&#160;</td>
          <td class="paramname"><em>PH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classglow_1_1_function.html">Function</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>PH</code> is an output <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> for any function in <code>funcs</code>. </dd></dl>

</div>
</div>
<a id="a67fc7f0b501763e06363d035e472238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fc7f0b501763e06363d035e472238c">&#9670;&nbsp;</a></span>isQuantizedElemKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isQuantizedElemKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>e</code> is a quantized ElemKind. </dd></dl>

</div>
</div>
<a id="aafa588b030c2f1fbed648b8477d7b444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa588b030c2f1fbed648b8477d7b444">&#9670;&nbsp;</a></span>isTensorView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::isTensorView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_value.html">glow::Value</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the value  is a tensor view. </dd></dl>

</div>
</div>
<a id="aa2799bdee5e14247b8699a8dfd8f6ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2799bdee5e14247b8699a8dfd8f6ae9">&#9670;&nbsp;</a></span>legalizeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string glow::legalizeName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Legalize <code>name</code> used in <a class="el" href="classglow_1_1_module.html">Module</a>. In Glow module, the name of placeholders and constants should look like valid C identifiers. Therefore, those symbols can be inspected under debugger. </p>

</div>
</div>
<a id="ae5f1717e58e71e730005473efae8c91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f1717e58e71e730005473efae8c91a">&#9670;&nbsp;</a></span>loadImagesAndPreprocess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::loadImagesAndPreprocess </td>
          <td>(</td>
          <td class="paramtype">const llvm::ArrayRef&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>inputImageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a>&#160;</td>
          <td class="paramname"><em>imageNormMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a>&#160;</td>
          <td class="paramname"><em>imageChannelOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a>&#160;</td>
          <td class="paramname"><em>imageLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads and normalizes all PNGs into a tensor in the NHWC format with the requested channel ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filenames</td><td>list of filenames to read. </td></tr>
    <tr><td class="paramname">inputImageData</td><td><a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> to save the resulting output. </td></tr>
    <tr><td class="paramname">imageNormMode</td><td>normalize values to this range. </td></tr>
    <tr><td class="paramname">imageChannelOrder</td><td>the order of color channels. </td></tr>
    <tr><td class="paramname">imageLayout</td><td>the order of dimensions (channel, height, and width). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fbe04791f94ae9ed38fa4c0166e6709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbe04791f94ae9ed38fa4c0166e6709">&#9670;&nbsp;</a></span>loadOperatorName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string glow::loadOperatorName </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns canonical name for a given operator: either <code>name()</code> from proto, or its type name. </p>

</div>
</div>
<a id="a85a9500a329d096bf03201016353f1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a9500a329d096bf03201016353f1dd">&#9670;&nbsp;</a></span>logicalDevicesValidation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::logicalDevicesValidation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>backendMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if <code>partitions</code> satisfies number of physical devices restriction. I.e. check if the number of logical devices is less than the given physical devices. </p>

</div>
</div>
<a id="a0069e8261c2e2ddf94d4697de80150ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0069e8261c2e2ddf94d4697de80150ad">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_backend.html">Backend</a> *&#160;</td>
          <td class="paramname"><em>B</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KindSet &amp;&#160;</td>
          <td class="paramname"><em>doNotLowerKinds</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lower the high-level neural network nodes found in <code>F</code> into low-level linear algebra operators. If <code>B</code> is not a nullptr then it can prevent lowering of a node via <a class="el" href="classglow_1_1_backend.html#aba5bec08f5e60626bcc5238f410d632a">Backend::shouldLower()</a>; otherwise everything will be lowered. <code>cctx</code> will contain a mapping of loweredMap from output names of the nodes found and lowered in <code>F</code> to the output names of the nodes they were lowered from along with the NodeKind. <code>doNotLowerKinds</code> is a set of NodeKinds which represents all Nodes that should not be lowered. </p>

</div>
</div>
<a id="a07a0a4dcd72e491d512294eec2ba422a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0a4dcd72e491d512294eec2ba422a">&#9670;&nbsp;</a></span>memoryUsageValidation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::memoryUsageValidation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="structglow_1_1_backend_info.html">BackendInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>backendMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the memory usage of each partition meets the physical device memory restriction. </p>

</div>
</div>
<a id="a300f3c7eeb3e5ee04d177a2acc6ac4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300f3c7eeb3e5ee04d177a2acc6ac4db">&#9670;&nbsp;</a></span>normModeToRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; float, float &gt; glow::normModeToRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the normalization to numeric floating poing ranges. </p>
<dl class="section return"><dt>Returns</dt><dd>the floating-point range corresponding to enum value <code>mode</code>. </dd></dl>

</div>
</div>
<a id="a07bee061556f83b0349d96ad196f0faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bee061556f83b0349d96ad196f0faf">&#9670;&nbsp;</a></span>optimizeCommunicationCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::optimizeCommunicationCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionToNodesMap &amp;&#160;</td>
          <td class="paramname"><em>nodesSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>availableMemory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By using heuristic algorithm to move nodes among <code>partitions</code>, optimize the total communication cost of running a module and keep the memory usage of each partition within <code>availableMemory</code>. </p>

</div>
</div>
<a id="af6b48e8310d02c29962b5469885b3a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b48e8310d02c29962b5469885b3a75">&#9670;&nbsp;</a></span>optimizeFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::optimizeFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_backend.html">Backend</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;&#160;</td>
          <td class="paramname"><em>cctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code> given compilation options <code>cctx</code> for <a class="el" href="classglow_1_1_backend.html">Backend</a> . </p><dl class="section return"><dt>Returns</dt><dd>success if all nodes in the final resulting optimized <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> are supported by <code>B</code>; if not, this represents a compiler error. </dd></dl>

</div>
</div>
<a id="a2bc58f10ed9c082dab795b43217a2d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc58f10ed9c082dab795b43217a2d51">&#9670;&nbsp;</a></span>optimizeFunctionBeforeLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#afdb176c3a672ef66db0ecfc19a8d39bf">Error</a> glow::optimizeFunctionBeforeLowering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;&#160;</td>
          <td class="paramname"><em>cctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> <code>F</code> given compilation options <code>cctx</code> performing backend-independent optimizations that can be done before lowering. </p><dl class="section return"><dt>Returns</dt><dd>success if there were no compiler errors; if not, this represents a compiler error. </dd></dl>

</div>
</div>
<a id="ae095c93d366edde27fb624fe8963e2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae095c93d366edde27fb624fe8963e2d7">&#9670;&nbsp;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; glow::outs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>output stream for stdout. </dd></dl>

</div>
</div>
<a id="aab6afbd888776074c6bd9285aa3d9fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6afbd888776074c6bd9285aa3d9fd8">&#9670;&nbsp;</a></span>partitionsCombine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::partitionsCombine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node_to_function_map.html">NodeToFunctionMap</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionToNodesMap &amp;&#160;</td>
          <td class="paramname"><em>nodesSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>availableMemory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combine partitions according to the following rules: Rule 1 :if all outside uses of the nodes in partition1 is in partition2, and the sum of memory consumption of partition1 and partition2 is less than availableMemory, combine partition1 and partition2. </p>

</div>
</div>
<a id="a8e9d4a9dc79cc3c3010bc99e93b08fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9d4a9dc79cc3c3010bc99e93b08fc7">&#9670;&nbsp;</a></span>profileQuantization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::profileQuantization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instrument function <code>F</code> by inserting quantization profile nodes for capturing stats for quantization. The nodes will refer to tensors allocate in context <code>bindings</code>. </p>
<p>Don't profile output nodes. </p>

</div>
</div>
<a id="a1945e52546b506e9c6692b42e6ff78bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1945e52546b506e9c6692b42e6ff78bd">&#9670;&nbsp;</a></span>profilingGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::profilingGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if profiling the graph. </dd></dl>

</div>
</div>
<a id="a327fb998231805cf69b6753e763e683f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327fb998231805cf69b6753e763e683f">&#9670;&nbsp;</a></span>readFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::readFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> data <code>T</code> from a file named <code>filename</code>.</p>
<p>NB: This function is primarily a debugging aid, not a serialization format. It reads only the binary data of the tensor (the dimensions must be known through other means), and reads tensors assuming host endianness. </p>

</div>
</div>
<a id="a23bf5dcbdf3e69fcee124d73bc4ecace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bf5dcbdf3e69fcee124d73bc4ecace">&#9670;&nbsp;</a></span>readPngImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::readPngImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; float, float &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>mean</em> = <code>zeroMean</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>stddev</em> = <code>oneStd</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a png image. </p><dl class="section return"><dt>Returns</dt><dd>True if an error occurred. The values of the image are in the range <code>range</code>. </dd></dl>

</div>
</div>
<a id="aa05ae0a1df66d2a01e935bcfa21e1874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05ae0a1df66d2a01e935bcfa21e1874">&#9670;&nbsp;</a></span>readPngImageAndPreprocess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> glow::readPngImageAndPreprocess </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a>&#160;</td>
          <td class="paramname"><em>imageNormMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a>&#160;</td>
          <td class="paramname"><em>imageChannelOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a>&#160;</td>
          <td class="paramname"><em>imageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>mean</em> = <code>zeroMean</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>stddev</em> = <code>oneStd</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a png image and preprocess it according to several parameters. Create a tensor and store the preprocessed image data into this tensor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the png file to read. </td></tr>
    <tr><td class="paramname">imageNormMode</td><td>normalize values to this range. </td></tr>
    <tr><td class="paramname">imageChannelOrder</td><td>the order of color channels. </td></tr>
    <tr><td class="paramname">imageLayout</td><td>the order of dimensions (channel, height, and width). </td></tr>
    <tr><td class="paramname">mean</td><td>use special mean to normalize. </td></tr>
    <tr><td class="paramname">stdev</td><td>use special stddev to normalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4355b249e26c8744ca54250df4d12f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4355b249e26c8744ca54250df4d12f89">&#9670;&nbsp;</a></span>readPngImageAndPreprocess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::readPngImageAndPreprocess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#af836699afb1d36a88df0d50d74fde931">ImageNormalizationMode</a>&#160;</td>
          <td class="paramname"><em>imageNormMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a2747942676633510584a944637b8eb59">ImageChannelOrder</a>&#160;</td>
          <td class="paramname"><em>imageChannelOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a06c384b9844d09e4dd277eb509728dce">ImageLayout</a>&#160;</td>
          <td class="paramname"><em>imageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>mean</em> = <code>zeroMean</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>stddev</em> = <code>oneStd</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a png image and preprocess it according to several parameters. Take a tensor as a parameter and store the preprocessed image data into this tensor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageData</td><td>the tensor into which the preprocessed image data will be stored. </td></tr>
    <tr><td class="paramname">filename</td><td>the png file to read. </td></tr>
    <tr><td class="paramname">imageNormMode</td><td>normalize values to this range. </td></tr>
    <tr><td class="paramname">imageChannelOrder</td><td>the order of color channels. </td></tr>
    <tr><td class="paramname">imageLayout</td><td>the order of dimensions (channel, height, and width). </td></tr>
    <tr><td class="paramname">mean</td><td>use special mean to normalize. </td></tr>
    <tr><td class="paramname">stdev</td><td>use special stddev to normalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4089f87152e44934daec43bb106d9858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4089f87152e44934daec43bb106d9858">&#9670;&nbsp;</a></span>recursiveClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * glow::recursiveClone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>newF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#afe305f16778f20f331d6b2016221a756">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>currToNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clone <code>node</code> and its sources into <code>newF</code> using old-to-new mapping <code>currToNew</code>. </p>

</div>
</div>
<a id="a5efbd9d8157489eb3b55e5c9fafb5fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efbd9d8157489eb3b55e5c9fafb5fb7">&#9670;&nbsp;</a></span>reportContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void glow::reportContext </td>
          <td>(</td>
          <td class="paramtype">const Ty &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default reportContext function used to print <code>a</code>. The default implementation relies on operator&lt;&lt; being available. The actual printing is done calling <a class="el" href="namespaceglow.html#a9d164b45d9fb735f448cd7985bcdf203" title="Print msg on the error stream. ">glow::report</a>. </p>

</div>
</div>
<a id="a2d7264d309f534807df9015c8bccda87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7264d309f534807df9015c8bccda87">&#9670;&nbsp;</a></span>runBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::runBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_execution_engine.html">ExecutionEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>EE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>sampleCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt;&#160;</td>
          <td class="paramname"><em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs <code>iterations</code> iterations of the compiled function. The method updates a global counter and future invocations of this method continue running iterations of the batch at the next available slice.</p>
<p>The method updates the placeholder in <code>ph</code> with the tensors <code>inputs</code>. The shape of the slice has to be identical to the shape of slices in the batch. All dimensions, except for the first (batch) dimension must be identical.</p>
<p>The variable <code>sampleCounter</code> is consumed and updated by the function. This variable records the number of samples that were consumed by the network in previous iterations. The next input to be loaded is (sampleCounter % batchsize). If there is more than one compiledFunction <code>name</code> must be provided to specify the desired function. </p>

</div>
</div>
<a id="a70f636287069c1f7f97e401c440ae580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f636287069c1f7f97e401c440ae580">&#9670;&nbsp;</a></span>runDCEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::runDCEPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_compilation_context.html">CompilationContext</a> &amp;&#160;</td>
          <td class="paramname"><em>cctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to run a DCE pass on <code>F</code> given <code>cctx</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>if <code>was</code> modified. </dd></dl>

</div>
</div>
<a id="a81686f1483028ad3045a94ef9760a3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81686f1483028ad3045a94ef9760a3b6">&#9670;&nbsp;</a></span>toBinary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t glow::toBinary </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a float into an unsigned integer binary representation. </p>
<p>Convert a float into an unsigned integer binary representation. FIXME: This is a workaround, because defining the hash_code hash_value(float) does not work for some reason. </p>

</div>
</div>
<a id="a13cf69ac6cea3abdeffaf975e3f9f02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cf69ac6cea3abdeffaf975e3f9f02d">&#9670;&nbsp;</a></span>toBinary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; glow::toBinary </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a collection of floats into a vector of unsigned integer binary representation. FIXME: This is a workaround, because defining the hash_code hash_value(float) does not work for some reason.</p>
<p>Convert a collection of floats into a vector of unsigned integer binary representation. </p>

</div>
</div>
<a id="a697c3d30b72e51fbe7d1a027a77f530c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697c3d30b72e51fbe7d1a027a77f530c">&#9670;&nbsp;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string glow::tolower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the content of the string <code>in</code> after conversion to lower case. </dd></dl>

</div>
</div>
<a id="ad735d6bafe7a0cb3ffb5482656235b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad735d6bafe7a0cb3ffb5482656235b2e">&#9670;&nbsp;</a></span>unexpectedNodeErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string glow::unexpectedNodeErrorMessage </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a single serialized protocol buffer node. This method is useful for debugging the network and printing errors. </p>

</div>
</div>
<a id="aa54619319c88d7ceb184f4dd70af8ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54619319c88d7ceb184f4dd70af8ccf">&#9670;&nbsp;</a></span>updateGraphMemInfoByAddingNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a> glow::updateGraphMemInfoByAddingNode </td>
          <td>(</td>
          <td class="paramtype">const NodesSet &amp;&#160;</td>
          <td class="paramname"><em>currNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structglow_1_1_graph_mem_info.html">GraphMemInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>newNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given nodes set <code>currNodes</code> and its memory usage info <code>info</code>, </p><dl class="section return"><dt>Returns</dt><dd>the new memory usage if <code>newNode</code> is added into <code>currNodes</code>. </dd></dl>

</div>
</div>
<a id="a24661dfe4d11f5c1cf0db592389a43fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24661dfe4d11f5c1cf0db592389a43fc">&#9670;&nbsp;</a></span>updateInputPlaceholders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::updateInputPlaceholders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *&gt;&#160;</td>
          <td class="paramname"><em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&gt;&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method updates the placeholders in <code>ph</code> with the tensor content values <code>inputs</code>, in <code>bindings</code>. </p>

</div>
</div>
<a id="afe843dcf46487faf7eecfb58d8e15c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe843dcf46487faf7eecfb58d8e15c04">&#9670;&nbsp;</a></span>updateInputPlaceholdersByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::updateInputPlaceholdersByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::StringRef &gt;&#160;</td>
          <td class="paramname"><em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&gt;&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method updates the placeholders in the module. The placeholders are found by name in <code>ph</code> with the tensor content values <code>inputs</code>. </p>

</div>
</div>
<a id="acfb0a7a5b75a41f5ba57843e7f242338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb0a7a5b75a41f5ba57843e7f242338">&#9670;&nbsp;</a></span>writePngImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::writePngImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; float, float &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>mean</em> = <code>zeroMean</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>stddev</em> = <code>oneStd</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a png image. </p><dl class="section return"><dt>Returns</dt><dd>True if an error occurred. The values of the image are in the range <code>range</code>. </dd></dl>

</div>
</div>
<a id="a5605652aaef5081976134120c3dcd4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5605652aaef5081976134120c3dcd4d5">&#9670;&nbsp;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glow::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> data <code>T</code> to a file named <code>filename</code>.</p>
<p>NB: This function is primarily a debugging aid, not a serialization format. It stores only the binary data of the tensor (not the dimensions), and writes tensors assuming host endianness. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad352d0b626337dc5b2e9ef7593268075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad352d0b626337dc5b2e9ef7593268075">&#9670;&nbsp;</a></span>DebugFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::DebugFlag = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set to true if '-debug-glow' command line option is specified. </p>
<p>Exported boolean set by -debug-glow option. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
