<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: Design of the Glow Intermediate Representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design of the Glow Intermediate Representation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h3>Introduction</h3>
<p>This document describes the motivation behind the Glow intermediate representation (IR) and some implementation details.</p>
<p>Glow is a retargetable compiler that supports a number of different backends. This means that the first few layers of the compiler are target-independent, but as you get closer to the different backends things start to diverge. The first two levels of IR are shared between all targets. Different backends may have additional layers of IR.</p>
<h3>High-level IR</h3>
<p>The high-level IR is a dataflow node-based graph representation that is similar to a graph that you may find inside Caffe or in ONNX format. When we load a neural network model from some file we construct this graph with a direct translation of one operator to one or more nodes. The high-level IR is a simple graph that allows basic transformations such as replacing all uses of some node with another node and modifying the content of constant nodes. The graph is strongly typed, which means that inputs and output have a known tensor type (consisting of the tensor's shape and element type), and that the types of nodes are verified by the compiler. For example, the element-wise add instruction must operate on operands of the same type.</p>
<p>The Glow graph is structured as a module that contains multiple functions that contain multiple nodes. Placeholders and Constants, which are similar to global variables in C programs, are nodes that are shared between the functions. Nodes inside functions are able to reference Placeholders and Constants which are owned by the module. A module may have multiple functions. For example, one module could contain both an inference function and the gradient of that inference function. The gradient function could perform training of the placeholder weights, and the inference function could read from those same weights.</p>
<div class="image">
<img src="module.png" alt="module.png"/>
</div>
<p>Glow functions contain nodes that represent the different operations of a neural network. The function owns the nodes and has access to the placeholders and constants in the module. The image below depicts the compute graph that represents the expression "A / B". The graph is automatically differentiated by Glow, and the value of variable A is updated with the gradient of the expression. Glow lowers the nodes that compute the gradient of the expression and the stochastic gradient descent (SGD) node into a sequence of low-level operators (Div, Mul, Add and Save). The different compiler backends do not need to implement support for the DivGrad, ReLUGrad or SGD nodes.</p>
<div class="image">
<img src="nodes.png" width="420"/>
</div>
 <p>The compiler has a debug method for dumping a graphical representation of the graph into a dotty file. The method is called 'dumpDAG'. The images above were generated with this method. The textual representation of the graph is less informative and it looks like this:</p>
<div class="fragment"><div class="line">pool</div><div class="line">name : &quot;pool&quot;</div><div class="line">input : float&lt;8 x 28 x 28 x 16&gt;</div><div class="line">output : float&lt;8 x 9 x 9 x 16&gt;</div><div class="line">kernel : 3</div><div class="line">stride : 3</div><div class="line">pads : [0, 0, 0, 0]</div><div class="line">kind : max</div><div class="line"></div><div class="line">convolution</div><div class="line">name : &quot;conv&quot;</div><div class="line">input : float&lt;8 x 9 x 9 x 16&gt;</div><div class="line">output : float&lt;8 x 9 x 9 x 16&gt;</div><div class="line">filter : float&lt;16 x 5 x 5 x 16&gt;</div><div class="line">bias : float&lt;16&gt;</div><div class="line">kernel : 5</div><div class="line">stride : 1</div><div class="line">pads : [2, 2, 2, 2]</div><div class="line">depth : 16</div><div class="line"></div><div class="line">relu</div><div class="line">name : &quot;conv&quot;</div><div class="line">input : float&lt;8 x 9 x 9 x 16&gt;</div></div><!-- fragment --><p>After optimizing the graph with target-independent optimizations the code is lowered into the mid-level IR in a phase that's called "IRGen" (stands for IR generation). This is a one-to-many translation where each operator is translated into one or more instructions.</p>
<h3>Constants</h3>
<p>Constants are special nodes that represent tensors that are a part of the graph. These nodes can be used to represent things like the weights of neural networks. Constants are immutable during the execution of the program, but graph optimizations can access the constants and modify them. This feature is useful for transformations that prepare the weights by transposing them or quantizing them before the execution of the program.</p>
<h3>Placeholders</h3>
<p>Placeholders are symbolic nodes that are not backed by a concrete tensor during the compilation of the program. Inputs and outputs of Glow programs should be modeled using Placeholder nodes. Concrete tensors are attached to placeholder nodes during the compilation of the program, and not before. This means that unlike constants, the optimizer can't inspect or mutate the content of Placeholder nodes. The same program could be compiled using different bound tensors without changing the semantics of the program.</p>
<h3>Variable Mutability</h3>
<p>During IRGen, constants and placeholders are converted into WeightVars. These WeightVars are annotated with Mutable or Constant labels, depending on the source and whether the weights are modified during the execution of the program.</p>
<h3>Predicates</h3>
<p>Predication is a well-known technique to control the execution of some node or instruction by means of a boolean flag. If the value of the flag at runtime is set to 'false' then the predicated node or instructions may return any value.</p>
<p>Glow's approach to predication is to support it as an optimization. In other words, if honoring the predicates does not give a performance boost, then a backend is free to ignore them. As such predication <b>cannot</b> be used to model control flow, since potentially the last write could win. Therefore input graphs must correctly execute with predicates ignored. For instance, when ignoring predicates, a program should be free of divisions by zero and other things that would lead to an abnormal termination of the program. Another example would be, in training mode, the memory used in predicated training nodes should be initialized to zero to make sure the program will not use uninitialized memory to update the weights, if the predicates get ignored.</p>
<p>The type of the flag must be a boolean value or a vector of booleans that matches the batch size. Predicates could accelerate the performance of some networks by avoiding some computation. It can particularly be useful when applied to Recurrent Neural Networks, because different elements of the batch may have different lengths and do not need to perform the same amount of computation.</p>
<div class="image">
<img src="pred.png" alt="pred.png"/>
</div>
<h3>Node Lowering</h3>
<p>Instead of compiling high-level operators directly, Glow performs "node
lowering". In this phase, the compiler breaks the high-level operator nodes into low-level linear algebra operator nodes. For example, the FullyConnected layer is represented as a matrix multiplication followed by broadcasted add. Different compiler backends do not have to implement the FullyConnected layer and a dozen other high-level opcodes, just the low-level matrix multiplication.</p>
<p>This lowering phase drives many of the design decisions of the compiler. In Glow, lowering is performed as part of the high-level graph as described above, prior to moving to low-level IR. This is due to a number of reasons. First, the new lowered graph may allow for additional graph-level optimizations. Second, the new graph structure may affect the decisions of the instruction scheduler. And third, after lowering we allow the backends to perform additional target-specific optimizations on the lowered graph.</p>
<p>The lowering phase comes after the graph is differentiated. Because the lowering transformation does not preserve the semantics of the graph, it is not possible to differentiate the graph for certain operators. For example, the Regression node (which produces gradient when optimizing total squared error) becomes a no-op for the inference case, but is translated into an element-wise subtract for the training case. Performing the lowering before differentiation would prevent us from performing the correct lowering of the Regression node.</p>
<h3>Low-Level IR</h3>
<p>After optimizing the graph with target-independent optimizations, and lowering from high-level operator nodes to linear algebra operator nodes, the code is further lowered into the low-level IR in a phase that is called "IRGen" (which stands for IR generation). This is a one-to-many translation where each high-level node is translated into one or more instructions.</p>
<p>The low-level IR enables a different kind of target independent optimizations that are not possible with the high-level graph format. This is an instruction-based representation that operates on tensors that are referenced by address. This gives the compiler the ability to perform low-level memory optimizations that are not possible at the high-level, because memory is not represented directly. An example of such a transformation is the optimization that allows certain operations to transform some buffers in-place, such as element-wise arithmetic.</p>
<p>In the context of hardware acceleration, the low-level instruction-based representation allows the compiler to represent device-specific operations such as asynchronous DMA operations. Hiding the latency of memory operations is important for utilizing the execution units of the hardware effectively, and the instruction-based representation allows the compiler to create a schedule that hides the latency of the memory operations.</p>
<p>The IR is strongly typed and each instruction operand kind has known parameter types. The IR is not Static Single Assignment (SSA) based representation, because the IR does not support control flow. The IR is strongly typed and each instruction operand kind has known parameter types. It is designed to be used as an in-memory form, though can be dumped to human readable assembly-like format.</p>
<p>A function in IR form contains two sections: 'declare' and 'program'. In the first section of the IR we declare a number of memory regions that live throughout the lifetime of the program. This is similar to global variables in C. The second part of the IR is a list of instructions. Each variable is annotated with the kind of initialization that the program should do.</p>
<p>There are two kinds of memory regions which correspond to these two sections: global memory regions (found in 'declare') and locally allocated regions (found in 'program'). The locally allocated memory regions are similar to 'alloca' in LLVM IR. Memory regions are strongly typed, which means that the kind of type of tensor that the region represents is known.</p>
<p>Instructions operate on either global variables or locally allocated buffers. Each operand is annotated with one of the qualifiers ''/''/''. '' means that the buffer is read from. '' means that the buffer is written into. And '' means that the instruction may read and write into the buffer. These operand qualifiers help the optimizer decide when it is legal to perform certain optimizations, such as copy elimination or buffer sharing. Instructions may have other attributes that specify the legality of some optimizations. For example, some instructions require that the data from the forward pass would be kept around for the backward pass, so if the program is not optimized for inference-only mode then certain memory optimizations cannot happen.</p>
<p>Below is an example of unoptimized Glow IR. Note that the 'alloc' instruction does not allocate memory; it just marks the lifetime of the activation. The low-level memory allocator is responsible for allocating all of the buffers into a single coalesced region.</p>
<div class="fragment"><div class="line">declare {</div><div class="line">  %input = weight float&lt;8 x 28 x 28 x 1&gt;, broadcast, 0.0</div><div class="line">  %filter = weight float&lt;16 x 5 x 5 x 1&gt;, xavier, 25.0</div><div class="line">  %filter0 = weight float&lt;16&gt;, broadcast, 0.100</div><div class="line">  %weights = weight float&lt;10 x 144&gt;, xavier, 144.0</div><div class="line">  %bias = weight float&lt;10&gt;, broadcast, 0.100</div><div class="line">  %selected = weight index&lt;8 x 1&gt;</div><div class="line">  ...</div><div class="line">  %result = weight float&lt;8 x 10&gt;</div><div class="line">}</div><div class="line"></div><div class="line">program {</div><div class="line">  %allo = alloc float&lt;8 x 28 x 28 x 16&gt;</div><div class="line">  %conv = convolution [5 1 2 16] @out %allo, @in %input, @in %filter3, @in %bias0</div><div class="line">  %allo0 = alloc float&lt;8 x 28 x 28 x 16&gt;</div><div class="line">  %relu = relu @out %allo0, @in %allo</div><div class="line">  %allo1 = alloc index&lt;8 x 9 x 9 x 16 x 2&gt;</div><div class="line">  %allo2 = alloc float&lt;8 x 9 x 9 x 16&gt;</div><div class="line">  %pool = pool max [3 3 0] @out %allo2, @in %allo0, @inout %allo1</div><div class="line">  ...</div><div class="line">  %deal6 = dealloc @out %allo6</div><div class="line">  %deal7 = dealloc @out %allo7</div><div class="line">  %deal8 = dealloc @out %allo8</div><div class="line">  %deal9 = dealloc @out %allo9</div><div class="line">}</div></div><!-- fragment --><h3>The Lifetime of a Glow Instruction</h3>
<p>This is a high-level overview of the compilation process:</p>
<ol type="1">
<li>The graph is either loaded via the graph loader (from ONNX or Caffe2 format), or constructed via the C++ interface.</li>
<li>The graph is differentiated if needed.</li>
<li>The graph is optimized.</li>
<li>Linear algebra node lowering takes place.</li>
<li>Additional rounds of optimizations occur, both target independent and target specific.</li>
<li>The graph is scheduled into a linear sequence of nodes that minimizes memory usage.</li>
<li>IRGen converts the low-level graph into instructions.</li>
<li>Low-level IR optimizations are performed.</li>
<li>Backend-specific optimizations and code generation are performed. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
