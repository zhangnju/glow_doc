<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow::Function Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglow.html">glow</a></li><li class="navelem"><a class="el" href="classglow_1_1_function.html">Function</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classglow_1_1_function-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">glow::Function Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the compute graph.  
 <a href="classglow_1_1_function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for glow::Function:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classglow_1_1_function.png" usemap="#glow::Function_map" alt=""/>
  <map id="glow::Function_map" name="glow::Function_map">
<area href="classglow_1_1_named.html" title="This add the capability to name subclasses. " alt="glow::Named" shape="rect" coords="0,0,93,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d93675aea23aef06971152d96ef9ce3"><td class="memItemLeft" align="right" valign="top"><a id="a3d93675aea23aef06971152d96ef9ce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Function</b> (<a class="el" href="classglow_1_1_module.html">Module</a> *parent, llvm::StringRef Name={})</td></tr>
<tr class="separator:a3d93675aea23aef06971152d96ef9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5dc1e1b10a595f5c2ceeb59e38226c"><td class="memItemLeft" align="right" valign="top"><a id="a0e5dc1e1b10a595f5c2ceeb59e38226c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0e5dc1e1b10a595f5c2ceeb59e38226c">setState</a> (<a class="el" href="namespaceglow.html#a1c98da7214165b41c7d6b255503d4062">FunctionState</a> state)</td></tr>
<tr class="memdesc:a0e5dc1e1b10a595f5c2ceeb59e38226c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of the function. <br /></td></tr>
<tr class="separator:a0e5dc1e1b10a595f5c2ceeb59e38226c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e85c7a5cd8e4986ec861ae0ebd58fe8"><td class="memItemLeft" align="right" valign="top"><a id="a9e85c7a5cd8e4986ec861ae0ebd58fe8"></a>
<a class="el" href="namespaceglow.html#a1c98da7214165b41c7d6b255503d4062">FunctionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a9e85c7a5cd8e4986ec861ae0ebd58fe8">getState</a> ()</td></tr>
<tr class="memdesc:a9e85c7a5cd8e4986ec861ae0ebd58fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the function. <br /></td></tr>
<tr class="separator:a9e85c7a5cd8e4986ec861ae0ebd58fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6019209226269eb42b5f27fc99d615"><td class="memItemLeft" align="right" valign="top"><a id="aae6019209226269eb42b5f27fc99d615"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getFilename</b> ()</td></tr>
<tr class="separator:aae6019209226269eb42b5f27fc99d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a16c8f354d8ba2316e47fc472d5305"><td class="memItemLeft" align="right" valign="top"><a id="ad6a16c8f354d8ba2316e47fc472d5305"></a>
std::shared_ptr&lt; <a class="el" href="classglow_1_1_log_context.html">LogContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad6a16c8f354d8ba2316e47fc472d5305">getLogContext</a> ()</td></tr>
<tr class="memdesc:ad6a16c8f354d8ba2316e47fc472d5305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log context. <br /></td></tr>
<tr class="separator:ad6a16c8f354d8ba2316e47fc472d5305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabd268f7c23b3a67401f2df9a5a2540"><td class="memItemLeft" align="right" valign="top"><a id="acabd268f7c23b3a67401f2df9a5a2540"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#acabd268f7c23b3a67401f2df9a5a2540">addMetadataPlaceholder</a> (<a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *PH)</td></tr>
<tr class="memdesc:acabd268f7c23b3a67401f2df9a5a2540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add placeholder for metadata such as profiling. <br /></td></tr>
<tr class="separator:acabd268f7c23b3a67401f2df9a5a2540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e182d5e7ce0b7722236423caeeda6f"><td class="memItemLeft" align="right" valign="top"><a id="a65e182d5e7ce0b7722236423caeeda6f"></a>
const std::vector&lt; <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a65e182d5e7ce0b7722236423caeeda6f">getMetadataPlaceholders</a> () const</td></tr>
<tr class="memdesc:a65e182d5e7ce0b7722236423caeeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of metadata placeholders. <br /></td></tr>
<tr class="separator:a65e182d5e7ce0b7722236423caeeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4385a62022dd1a9dd993f4b3b21a5c"><td class="memItemLeft" align="right" valign="top"><a id="ade4385a62022dd1a9dd993f4b3b21a5c"></a>
<a class="el" href="classglow_1_1_module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParent</b> ()</td></tr>
<tr class="separator:ade4385a62022dd1a9dd993f4b3b21a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dabb8d94895004268410f672079f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ab1dabb8d94895004268410f672079f1a">orderNodes</a> ()</td></tr>
<tr class="separator:ab1dabb8d94895004268410f672079f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc73d2632bdeaaa7a2ec029196608ab7"><td class="memItemLeft" align="right" valign="top">PlaceholderList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#abc73d2632bdeaaa7a2ec029196608ab7">findPlaceholders</a> ()</td></tr>
<tr class="separator:abc73d2632bdeaaa7a2ec029196608ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650818e9aa23fa39d25853456c8df56e"><td class="memItemLeft" align="right" valign="top"><a id="a650818e9aa23fa39d25853456c8df56e"></a>
PlaceholderList&#160;</td><td class="memItemRight" valign="bottom"><b>findPlaceholders</b> () const</td></tr>
<tr class="separator:a650818e9aa23fa39d25853456c8df56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0668c5170eedf2b84a292367cfb4fbac"><td class="memItemLeft" align="right" valign="top">ConstList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0668c5170eedf2b84a292367cfb4fbac">findConstants</a> ()</td></tr>
<tr class="separator:a0668c5170eedf2b84a292367cfb4fbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7a59dca6b535e94ffaa5d0e72d2d1e"><td class="memItemLeft" align="right" valign="top"><a id="a0c7a59dca6b535e94ffaa5d0e72d2d1e"></a>
ConstList&#160;</td><td class="memItemRight" valign="bottom"><b>findConstants</b> () const</td></tr>
<tr class="separator:a0c7a59dca6b535e94ffaa5d0e72d2d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f187ac21a2f08073a24b75c13817b4e"><td class="memItemLeft" align="right" valign="top"><a id="a5f187ac21a2f08073a24b75c13817b4e"></a>
const <a class="el" href="classglow_1_1_module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParent</b> () const</td></tr>
<tr class="separator:a5f187ac21a2f08073a24b75c13817b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0abc2117e80f3253aa91122a7c786e9"><td class="memTemplParams" colspan="2"><a id="aa0abc2117e80f3253aa91122a7c786e9"></a>
template&lt;class NodeTy &gt; </td></tr>
<tr class="memitem:aa0abc2117e80f3253aa91122a7c786e9"><td class="memTemplItemLeft" align="right" valign="top">NodeTy *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aa0abc2117e80f3253aa91122a7c786e9">addNode</a> (NodeTy *N)</td></tr>
<tr class="memdesc:aa0abc2117e80f3253aa91122a7c786e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the node <code>N</code> to the list of nodes, and returns the inserted node. <br /></td></tr>
<tr class="separator:aa0abc2117e80f3253aa91122a7c786e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74703c0bb968ca968b65dbc20653940c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a74703c0bb968ca968b65dbc20653940c">takeOwnershipOfNode</a> (<a class="el" href="classglow_1_1_node.html">Node</a> *N)</td></tr>
<tr class="separator:a74703c0bb968ca968b65dbc20653940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb654422d9a79453aa67d0dc1e565ae"><td class="memItemLeft" align="right" valign="top"><a id="afeb654422d9a79453aa67d0dc1e565ae"></a>
<a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#afeb654422d9a79453aa67d0dc1e565ae">getPRNG</a> ()</td></tr>
<tr class="memdesc:afeb654422d9a79453aa67d0dc1e565ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pseudo-random number generator used by this module. <br /></td></tr>
<tr class="separator:afeb654422d9a79453aa67d0dc1e565ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bff46320d22692796a98c44c785d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_trace_event_node.html">TraceEventNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a85bff46320d22692796a98c44c785d36">createTraceEvent</a> (llvm::StringRef eventName, llvm::StringRef eventType, <a class="el" href="classglow_1_1_node.html">Node</a> *data, unsigned index)</td></tr>
<tr class="separator:a85bff46320d22692796a98c44c785d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb693d81eaa8052223079ae79d16c65b"><td class="memItemLeft" align="right" valign="top"><a id="adb693d81eaa8052223079ae79d16c65b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#adb693d81eaa8052223079ae79d16c65b">eraseNode</a> (<a class="el" href="classglow_1_1_node.html">Node</a> *N)</td></tr>
<tr class="memdesc:adb693d81eaa8052223079ae79d16c65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the node <code>N</code> from the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. <br /></td></tr>
<tr class="separator:adb693d81eaa8052223079ae79d16c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c817ad84187e6237fe2e3b6da41c37"><td class="memItemLeft" align="right" valign="top"><a id="ad0c817ad84187e6237fe2e3b6da41c37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad0c817ad84187e6237fe2e3b6da41c37">eraseNode</a> (NodesList::iterator I)</td></tr>
<tr class="memdesc:ad0c817ad84187e6237fe2e3b6da41c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the node <code>I</code> from the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. <br /></td></tr>
<tr class="separator:ad0c817ad84187e6237fe2e3b6da41c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb076e6a99804a4349e1cb3b54291f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a52bb076e6a99804a4349e1cb3b54291f">clone</a> (llvm::StringRef newName, llvm::DenseMap&lt; <a class="el" href="classglow_1_1_node.html">Node</a> *, <a class="el" href="classglow_1_1_node.html">Node</a> *&gt; *map=nullptr)</td></tr>
<tr class="separator:a52bb076e6a99804a4349e1cb3b54291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73897a61138cf69eacb41357839815df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a73897a61138cf69eacb41357839815df">verify</a> () const</td></tr>
<tr class="separator:a73897a61138cf69eacb41357839815df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d47fdde36a323d732b9f74e18fca55"><td class="memItemLeft" align="right" valign="top"><a id="a61d47fdde36a323d732b9f74e18fca55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a61d47fdde36a323d732b9f74e18fca55">dump</a> () const</td></tr>
<tr class="memdesc:a61d47fdde36a323d732b9f74e18fca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> into provided output stream. <br /></td></tr>
<tr class="separator:a61d47fdde36a323d732b9f74e18fca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2478eeed56907e1b9fb0bed6d8bd2a"><td class="memItemLeft" align="right" valign="top"><a id="a7f2478eeed56907e1b9fb0bed6d8bd2a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a7f2478eeed56907e1b9fb0bed6d8bd2a">toString</a> () const</td></tr>
<tr class="memdesc:a7f2478eeed56907e1b9fb0bed6d8bd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> to std::string. <br /></td></tr>
<tr class="separator:a7f2478eeed56907e1b9fb0bed6d8bd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59478d0dd1e2b501de0e71ab508a4f6"><td class="memItemLeft" align="right" valign="top"><a id="ae59478d0dd1e2b501de0e71ab508a4f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ae59478d0dd1e2b501de0e71ab508a4f6">dump</a> (llvm::raw_ostream &amp;os) const</td></tr>
<tr class="memdesc:ae59478d0dd1e2b501de0e71ab508a4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> into default output stream. <br /></td></tr>
<tr class="separator:ae59478d0dd1e2b501de0e71ab508a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f5f7d84157c8c3c20faeb82c083c2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a25f5f7d84157c8c3c20faeb82c083c2d">dumpDAG</a> ()</td></tr>
<tr class="separator:a25f5f7d84157c8c3c20faeb82c083c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8e3a9043edf5869ee13618fb04b731"><td class="memItemLeft" align="right" valign="top"><a id="a3e8e3a9043edf5869ee13618fb04b731"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a3e8e3a9043edf5869ee13618fb04b731">dumpDAG</a> (llvm::StringRef dotFilename)</td></tr>
<tr class="memdesc:a3e8e3a9043edf5869ee13618fb04b731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a dotty graph that depicts the function. <br /></td></tr>
<tr class="separator:a3e8e3a9043edf5869ee13618fb04b731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524c4964b448c3b9a9b15b2a26faa8c3"><td class="memItemLeft" align="right" valign="top"><a id="a524c4964b448c3b9a9b15b2a26faa8c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a524c4964b448c3b9a9b15b2a26faa8c3">dumpDAG</a> (const char *dotFilename)</td></tr>
<tr class="memdesc:a524c4964b448c3b9a9b15b2a26faa8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a dotty graph that depicts the function. <br /></td></tr>
<tr class="separator:a524c4964b448c3b9a9b15b2a26faa8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79bc51bcabb426b1f64e8a0700fba2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#a4919b7ef01548e927f0a5acb3a7400b9">NodesList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad79bc51bcabb426b1f64e8a0700fba2d">getNodes</a> ()</td></tr>
<tr class="separator:ad79bc51bcabb426b1f64e8a0700fba2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cfda31e823d1499173f1bd23f2d86c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a26cfda31e823d1499173f1bd23f2d86c">getNodeByName</a> (llvm::StringRef name)</td></tr>
<tr class="separator:a26cfda31e823d1499173f1bd23f2d86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c94ce2d752b75a9912369402f4cc5f"><td class="memItemLeft" align="right" valign="top"><a id="ad8c94ce2d752b75a9912369402f4cc5f"></a>
const <a class="el" href="namespaceglow.html#a4919b7ef01548e927f0a5acb3a7400b9">NodesList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNodes</b> () const</td></tr>
<tr class="separator:ad8c94ce2d752b75a9912369402f4cc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">The builder functions below are identical to the builder functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>above except that they create nodes that use <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> instead of Variables. The methods create and initialize the tensors in the <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a>. As soon as we finish the <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> migration we'll delete these methods and merge them with the builder methods above. See issue #1334. </p>
</div></td></tr>
<tr class="memitem:a7ecd6f8406787c42d7fe75370acae397"><td class="memItemLeft" align="right" valign="top"><a id="a7ecd6f8406787c42d7fe75370acae397"></a>
<a class="el" href="classglow_1_1_batch_normalization_node.html">BatchNormalizationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createBatchNormalization</b> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> channelIdx=0, float epsilon=1e-5, float momentum=0.9)</td></tr>
<tr class="separator:a7ecd6f8406787c42d7fe75370acae397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878cada26ba13b88d149d7a631f5ae10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a878cada26ba13b88d149d7a631f5ae10">createConv</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, size_t outChannels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dilation=1, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a878cada26ba13b88d149d7a631f5ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fce0de99a46d774b0f9bd9aa04b1498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a9fce0de99a46d774b0f9bd9aa04b1498">createConv</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, size_t outChannels, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> kernel, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> stride, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> pad, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dilation=1, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a9fce0de99a46d774b0f9bd9aa04b1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad3ec8a2afa0bcfcb21a55719f3df4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aaad3ec8a2afa0bcfcb21a55719f3df4f">createConv3D</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, size_t outChannels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group)</td></tr>
<tr class="separator:aaad3ec8a2afa0bcfcb21a55719f3df4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99742506dcf9c372bb92cf74e8160de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a99742506dcf9c372bb92cf74e8160de2">createConv3D</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, size_t outChannels, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> kernel, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> stride, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> pad, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group)</td></tr>
<tr class="separator:a99742506dcf9c372bb92cf74e8160de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9306e5e5d5665e16fc64dcf8df3e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ade9306e5e5d5665e16fc64dcf8df3e94">createFullyConnected</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, size_t outDepth, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis=1)</td></tr>
<tr class="separator:ade9306e5e5d5665e16fc64dcf8df3e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa2b425049f5e2868062da4ca7c438e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5aa2b425049f5e2868062da4ca7c438e">createSimpleRNN</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef namePrefix, const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs, unsigned batchSize, unsigned hiddenSize, unsigned outputSize, std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:a5aa2b425049f5e2868062da4ca7c438e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38073ffa1c63421716ee236d56178738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a38073ffa1c63421716ee236d56178738">createGRU</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef namePrefix, const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs, unsigned batchSize, unsigned hiddenSize, unsigned outputSize, std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:a38073ffa1c63421716ee236d56178738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031dffcebc9798d481beaefaa927db61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a031dffcebc9798d481beaefaa927db61">createLSTM</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef namePrefix, const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs, unsigned batchSize, unsigned hiddenSize, unsigned outputSize, std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:a031dffcebc9798d481beaefaa927db61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classglow_1_1_named"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classglow_1_1_named')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classglow_1_1_named.html">glow::Named</a></td></tr>
<tr class="memitem:ac406265dc7c227a235ef0967c1ca3b78 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top"><a id="ac406265dc7c227a235ef0967c1ca3b78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Named</b> (llvm::StringRef name)</td></tr>
<tr class="separator:ac406265dc7c227a235ef0967c1ca3b78 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953e8bbe0c565edf52e374d461579c4e inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top">llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#a953e8bbe0c565edf52e374d461579c4e">getName</a> () const</td></tr>
<tr class="separator:a953e8bbe0c565edf52e374d461579c4e inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdd13e8cd2d61adbbc9cb6fedd0acd4 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#aafdd13e8cd2d61adbbc9cb6fedd0acd4">hasName</a> () const</td></tr>
<tr class="separator:aafdd13e8cd2d61adbbc9cb6fedd0acd4 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99fea3a80a29c8177bbba36232ba850 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top"><a id="ac99fea3a80a29c8177bbba36232ba850"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#ac99fea3a80a29c8177bbba36232ba850">setName</a> (llvm::StringRef name)</td></tr>
<tr class="memdesc:ac99fea3a80a29c8177bbba36232ba850 inherit pub_methods_classglow_1_1_named"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the instruction to <code>name</code>. <br /></td></tr>
<tr class="separator:ac99fea3a80a29c8177bbba36232ba850 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199b7443a774b5268848a783ef6cb186 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#a199b7443a774b5268848a783ef6cb186">compareByName</a> (const <a class="el" href="classglow_1_1_named.html">Named</a> &amp;x) const</td></tr>
<tr class="memdesc:a199b7443a774b5268848a783ef6cb186 inherit pub_methods_classglow_1_1_named"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares by names,.  <a href="classglow_1_1_named.html#a199b7443a774b5268848a783ef6cb186">More...</a><br /></td></tr>
<tr class="separator:a199b7443a774b5268848a783ef6cb186 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa766431c358524e3dfeafc66d1cdcb4f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceglow.html#a4919b7ef01548e927f0a5acb3a7400b9">NodesList</a> Function::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aa766431c358524e3dfeafc66d1cdcb4f">getNodesMemberPtr</a> ()</td></tr>
<tr class="separator:aa766431c358524e3dfeafc66d1cdcb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
High-level, operation-level IRBuilder.</h2></td></tr>
<tr class="memitem:a1a8656058a9f271299328ad88644d5fc"><td class="memTemplParams" colspan="2"><a id="a1a8656058a9f271299328ad88644d5fc"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1a8656058a9f271299328ad88644d5fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_same_t</b> = std::enable_if&lt; std::is_same&lt; T, U &gt;::value, U &gt;</td></tr>
<tr class="separator:a1a8656058a9f271299328ad88644d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cf464c45ccbcae923056644b444ce8"><td class="memItemLeft" align="right" valign="top"><a id="a15cf464c45ccbcae923056644b444ce8"></a>
<a class="el" href="classglow_1_1_pad_node.html">PadNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createPad</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> mode, llvm::ArrayRef&lt; int &gt; pads, float value)</td></tr>
<tr class="separator:a15cf464c45ccbcae923056644b444ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b28c191e7dbb0c0c83165a7c7107313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0b28c191e7dbb0c0c83165a7c7107313">createConv</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> filter, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> bias, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dilation=1, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=ConvolutionLayout::NHWC)</td></tr>
<tr class="separator:a0b28c191e7dbb0c0c83165a7c7107313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16bccb2690886aa72ad02131f9caf2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad16bccb2690886aa72ad02131f9caf2c">createConv</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> filter, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> bias, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> kernel, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> stride, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> pad, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dilation=1, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=ConvolutionLayout::NHWC)</td></tr>
<tr class="separator:ad16bccb2690886aa72ad02131f9caf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec756ea2779f3768102cd496cce846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5eec756ea2779f3768102cd496cce846">createConv3D</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> filter, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> bias, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group)</td></tr>
<tr class="separator:a5eec756ea2779f3768102cd496cce846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c34498d91c08a88e7f503bcb55646d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a29c34498d91c08a88e7f503bcb55646d">createConv3D</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> filter, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> bias, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> kernel, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> stride, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> pad, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group)</td></tr>
<tr class="separator:a29c34498d91c08a88e7f503bcb55646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c1fee1a3b4e7779c7a1cee21592f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_channelwise_quantized_convolution_node.html">ChannelwiseQuantizedConvolutionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a94c1fee1a3b4e7779c7a1cee21592f0f">createChannelwiseQuantizedConv</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="classglow_1_1_constant.html">Constant</a> *filter, <a class="el" href="classglow_1_1_constant.html">Constant</a> *bias, <a class="el" href="classglow_1_1_constant.html">Constant</a> *scales, <a class="el" href="classglow_1_1_constant.html">Constant</a> *offsets, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> group)</td></tr>
<tr class="separator:a94c1fee1a3b4e7779c7a1cee21592f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb186d99df71f01dc37871b7a91fe207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convert_to_node.html">ConvertToNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#afb186d99df71f01dc37871b7a91fe207">createConvertTo</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:afb186d99df71f01dc37871b7a91fe207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad00b9f260eb7c5c21f5c59ebd0089b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_convert_to_node.html">ConvertToNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aad00b9f260eb7c5c21f5c59ebd0089b3">createConvertTo</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> k)</td></tr>
<tr class="separator:aad00b9f260eb7c5c21f5c59ebd0089b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81424770e89904f98f677caf5d494997"><td class="memItemLeft" align="right" valign="top"><a id="a81424770e89904f98f677caf5d494997"></a>
<a class="el" href="classglow_1_1_max_pool_node.html">MaxPoolNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createMaxPool</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a81424770e89904f98f677caf5d494997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3494f53b040eec329effdeca0373a19d"><td class="memItemLeft" align="right" valign="top"><a id="a3494f53b040eec329effdeca0373a19d"></a>
<a class="el" href="classglow_1_1_max_pool_node.html">MaxPoolNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createMaxPool</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> kernel, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> stride, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> pad, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a3494f53b040eec329effdeca0373a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cfd29adbc1ac732b8e54729cc9fc15"><td class="memItemLeft" align="right" valign="top"><a id="a34cfd29adbc1ac732b8e54729cc9fc15"></a>
<a class="el" href="classglow_1_1_avg_pool_node.html">AvgPoolNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createAvgPool</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a34cfd29adbc1ac732b8e54729cc9fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732922d9ff497ae3bbbcaa44403b23a"><td class="memItemLeft" align="right" valign="top"><a id="a9732922d9ff497ae3bbbcaa44403b23a"></a>
<a class="el" href="classglow_1_1_avg_pool_node.html">AvgPoolNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createAvgPool</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; kernels, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; strides, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; pads, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a9732922d9ff497ae3bbbcaa44403b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cf51e276c58cbefba50f01a24c1e09"><td class="memItemLeft" align="right" valign="top"><a id="a76cf51e276c58cbefba50f01a24c1e09"></a>
<a class="el" href="classglow_1_1_avg_pool_node.html">AvgPoolNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createAvgPool</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> kernel, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> stride, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> pad, <a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a> layout=NHWC)</td></tr>
<tr class="separator:a76cf51e276c58cbefba50f01a24c1e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5145a97eddf1d1dd26ae7a9de37b341b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_adaptive_avg_pool_node.html">AdaptiveAvgPoolNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5145a97eddf1d1dd26ae7a9de37b341b">createAdaptiveAvgPool</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:a5145a97eddf1d1dd26ae7a9de37b341b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369fe971f7e75ca38ff5d6bb0928be89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a369fe971f7e75ca38ff5d6bb0928be89">createFullyConnected</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="classglow_1_1_storage.html">Storage</a> *W, <a class="el" href="classglow_1_1_storage.html">Storage</a> *B, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis=1)</td></tr>
<tr class="separator:a369fe971f7e75ca38ff5d6bb0928be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38b3e6dd3052c286126ab1239d97aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad38b3e6dd3052c286126ab1239d97aa8">createFullyConnected</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> W, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> B, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis=1)</td></tr>
<tr class="separator:ad38b3e6dd3052c286126ab1239d97aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b45584a08282fd6b027ce972c5f74d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_rowwise_quantized_fully_connected_node.html">RowwiseQuantizedFullyConnectedNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aa4b45584a08282fd6b027ce972c5f74d">createRowwiseQuantizedFullyConnected</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="classglow_1_1_constant.html">Constant</a> *W, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> B, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, quantization::Schema schema, bool transposeWeight=false)</td></tr>
<tr class="separator:aa4b45584a08282fd6b027ce972c5f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf9b83116497dd0ac4c3bb730be5153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#accf9b83116497dd0ac4c3bb730be5153">createDotProduct</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> X, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Y)</td></tr>
<tr class="separator:accf9b83116497dd0ac4c3bb730be5153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc00c1542599ab75332a236d1aee6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aefc00c1542599ab75332a236d1aee6a3">createElementwiseLinear</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> X, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> w, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> b, unsigned axis)</td></tr>
<tr class="separator:aefc00c1542599ab75332a236d1aee6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1e5e0678dc0af5c17835ffea6c3367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_relu_node.html">ReluNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ada1e5e0678dc0af5c17835ffea6c3367">createRELU</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:ada1e5e0678dc0af5c17835ffea6c3367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31145d8863286195749705d53a93b9b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_relu_node.html">ReluNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a31145d8863286195749705d53a93b9b0">createRELU</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:a31145d8863286195749705d53a93b9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f705eed37efbbb40cc644c36dd16e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_p_relu_node.html">PReluNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a128f705eed37efbbb40cc644c36dd16e">createPRELU</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> slope)</td></tr>
<tr class="separator:a128f705eed37efbbb40cc644c36dd16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87131023c229abbfbc109c06485106a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_p_relu_node.html">PReluNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a87131023c229abbfbc109c06485106a7">createPRELU</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> slope, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:a87131023c229abbfbc109c06485106a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e62024d3d2033210f189b8f0fb19b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sigmoid_node.html">SigmoidNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a8e62024d3d2033210f189b8f0fb19b04">createSigmoid</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:a8e62024d3d2033210f189b8f0fb19b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5493f61de698fa74ca152bbb52b212aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sigmoid_node.html">SigmoidNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5493f61de698fa74ca152bbb52b212aa">createSigmoid</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:a5493f61de698fa74ca152bbb52b212aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859e8e441d4479750853cca69c357803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tanh_node.html">TanhNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a859e8e441d4479750853cca69c357803">createTanh</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:a859e8e441d4479750853cca69c357803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e1981e013129cef4882a2598c36f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tanh_node.html">TanhNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a311e1981e013129cef4882a2598c36f4">createTanh</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:a311e1981e013129cef4882a2598c36f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32483c4b5aff8743513d9eeec6d26fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_exp_node.html">ExpNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#af32483c4b5aff8743513d9eeec6d26fe">createExp</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:af32483c4b5aff8743513d9eeec6d26fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd96b3007929f8a2c534e72311cd6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_log_node.html">LogNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a4fd96b3007929f8a2c534e72311cd6e8">createLog</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy=nullptr)</td></tr>
<tr class="separator:a4fd96b3007929f8a2c534e72311cd6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e3b70fd3322cc3ae6f733c7c818ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a81e3b70fd3322cc3ae6f733c7c818ff2">createLogit</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, float eps)</td></tr>
<tr class="separator:a81e3b70fd3322cc3ae6f733c7c818ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecf62f58de6964e28f495bd3595e813"><td class="memItemLeft" align="right" valign="top"><a id="a2ecf62f58de6964e28f495bd3595e813"></a>
<a class="el" href="classglow_1_1_soft_max_node.html">SoftMaxNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSoftMax</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> selected, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy=nullptr)</td></tr>
<tr class="separator:a2ecf62f58de6964e28f495bd3595e813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a9399b85f89421ef812a7b05f16966"><td class="memItemLeft" align="right" valign="top"><a id="a58a9399b85f89421ef812a7b05f16966"></a>
<a class="el" href="classglow_1_1_cross_entropy_loss_node.html">CrossEntropyLossNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createCrossEntropyLoss</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> labels)</td></tr>
<tr class="separator:a58a9399b85f89421ef812a7b05f16966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34682d96ea79254986f7026a0d53398"><td class="memItemLeft" align="right" valign="top"><a id="ae34682d96ea79254986f7026a0d53398"></a>
<a class="el" href="classglow_1_1_regression_node.html">RegressionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createRegression</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> expected)</td></tr>
<tr class="separator:ae34682d96ea79254986f7026a0d53398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0a2bb490c6973c7986c635c10f3a60"><td class="memItemLeft" align="right" valign="top"><a id="aba0a2bb490c6973c7986c635c10f3a60"></a>
<a class="el" href="classglow_1_1_sigmoid_cross_entropy_with_logits_node.html">SigmoidCrossEntropyWithLogitsNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aba0a2bb490c6973c7986c635c10f3a60">createSigmoidCrossEntropyWithLogits</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> logits, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> targets)</td></tr>
<tr class="memdesc:aba0a2bb490c6973c7986c635c10f3a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node, which computes sigmoid cross entropy between two inputs. <br /></td></tr>
<tr class="separator:aba0a2bb490c6973c7986c635c10f3a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5761ec0e5f1d4ef24a00ed2b8e97e1b2"><td class="memItemLeft" align="right" valign="top"><a id="a5761ec0e5f1d4ef24a00ed2b8e97e1b2"></a>
<a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createReshape</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, UnsignedArrayRef shape)</td></tr>
<tr class="separator:a5761ec0e5f1d4ef24a00ed2b8e97e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95baf74375150ab5f302ff9996278bf2"><td class="memItemLeft" align="right" valign="top"><a id="a95baf74375150ab5f302ff9996278bf2"></a>
<a class="el" href="classglow_1_1_transpose_node.html">TransposeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createTranspose</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; shuffle)</td></tr>
<tr class="separator:a95baf74375150ab5f302ff9996278bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757d71d8785b075edcc6f0e9b9bc12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a757d71d8785b075edcc6f0e9b9bc12ac">createBroadcast</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, UnsignedArrayRef newShape, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis)</td></tr>
<tr class="separator:a757d71d8785b075edcc6f0e9b9bc12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b2d59133de2a5fa8d4858758841b0"><td class="memItemLeft" align="right" valign="top"><a id="af67b2d59133de2a5fa8d4858758841b0"></a>
<a class="el" href="classglow_1_1_concat_node.html">ConcatNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#af67b2d59133de2a5fa8d4858758841b0">createConcat</a> (llvm::StringRef name, llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dimension)</td></tr>
<tr class="memdesc:af67b2d59133de2a5fa8d4858758841b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create concat node which concatenates input tensors along <code>dimension</code>. <br /></td></tr>
<tr class="separator:af67b2d59133de2a5fa8d4858758841b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac904da4288552dd4146ea199a04a072d"><td class="memItemLeft" align="right" valign="top"><a id="ac904da4288552dd4146ea199a04a072d"></a>
<a class="el" href="classglow_1_1_concat_node.html">ConcatNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ac904da4288552dd4146ea199a04a072d">createConcat</a> (llvm::StringRef name, llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> dimension, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="memdesc:ac904da4288552dd4146ea199a04a072d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create concat node with the given return type <code>outTy</code>. <br /></td></tr>
<tr class="separator:ac904da4288552dd4146ea199a04a072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea101a646a4e71c0b513608587127217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tile_node.html">TileNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aea101a646a4e71c0b513608587127217">createTile</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> tiles, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy=nullptr)</td></tr>
<tr class="separator:aea101a646a4e71c0b513608587127217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacd10cc5da0f12caa196897ce7a6141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_insert_tensor_node.html">InsertTensorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aeacd10cc5da0f12caa196897ce7a6141">createInsertTensor</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> big, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> small, llvm::ArrayRef&lt; size_t &gt; start, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> count=1, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis=0)</td></tr>
<tr class="separator:aeacd10cc5da0f12caa196897ce7a6141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b8477dbfb921800443064c03a7ac50"><td class="memItemLeft" align="right" valign="top"><a id="a05b8477dbfb921800443064c03a7ac50"></a>
<a class="el" href="classglow_1_1_slice_node.html">SliceNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSlice</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, UnsignedArrayRef begin, UnsignedArrayRef end)</td></tr>
<tr class="separator:a05b8477dbfb921800443064c03a7ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff3f5f232d5db7d7b7529516053964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_slice_node.html">SliceNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#abdff3f5f232d5db7d7b7529516053964">createSlice</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; size_t &gt; start, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:abdff3f5f232d5db7d7b7529516053964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a16974812ba2aaadd2ec5cf521ef1a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0a16974812ba2aaadd2ec5cf521ef1a0">createChannelShuffle</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, size_t group, size_t kernel)</td></tr>
<tr class="separator:a0a16974812ba2aaadd2ec5cf521ef1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dffc1674d4a1654cb7206a4d7752b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_arg_max_node.html">ArgMaxNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0dffc1674d4a1654cb7206a4d7752b1e">createArgMax</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis, bool keepDims)</td></tr>
<tr class="separator:a0dffc1674d4a1654cb7206a4d7752b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa046629fa2f742a28a49966c67e947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5fa046629fa2f742a28a49966c67e947">createSqueeze</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; size_t &gt; axes)</td></tr>
<tr class="separator:a5fa046629fa2f742a28a49966c67e947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05272c5de8896a7f0110b620ae8ee3d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a05272c5de8896a7f0110b620ae8ee3d9">createExpandDims</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; size_t &gt; axes)</td></tr>
<tr class="separator:a05272c5de8896a7f0110b620ae8ee3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978750e2f05e9c022756e49e2591830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5978750e2f05e9c022756e49e2591830">createFlatten</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis)</td></tr>
<tr class="separator:a5978750e2f05e9c022756e49e2591830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f77fd01d257c12ce44d64ee25c9a65f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a9f77fd01d257c12ce44d64ee25c9a65f">createSplit</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> outputNum, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> axis, llvm::ArrayRef&lt; size_t &gt; split, std::vector&lt; <a class="el" href="classglow_1_1_slice_node.html">SliceNode</a> *&gt; &amp;outputs)</td></tr>
<tr class="separator:a9f77fd01d257c12ce44d64ee25c9a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2008070c63095bd8d5a2923253d91875"><td class="memItemLeft" align="right" valign="top"><a id="a2008070c63095bd8d5a2923253d91875"></a>
<a class="el" href="classglow_1_1_batch_normalization_node.html">BatchNormalizationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createBatchNormalization</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> beta, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> scale, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> mean, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> var, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> channelIdx=0, float epsilon=1e-5, float momentum=0.9)</td></tr>
<tr class="separator:a2008070c63095bd8d5a2923253d91875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6412c6acdbc1e9c6ec002c841e071f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_bucketize_node.html">BucketizeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aa6412c6acdbc1e9c6ec002c841e071f7">createBucketizeNode</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; float &gt; boundaries)</td></tr>
<tr class="separator:aa6412c6acdbc1e9c6ec002c841e071f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544aa71f28b5c4bd7c890febdc36b95a"><td class="memItemLeft" align="right" valign="top"><a id="a544aa71f28b5c4bd7c890febdc36b95a"></a>
<a class="el" href="classglow_1_1_local_response_normalization_node.html">LocalResponseNormalizationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createLocalResponseNormalization</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> halfWindowSize=2, float alpha=1e-4, float beta=0.75, float k=2.0)</td></tr>
<tr class="separator:a544aa71f28b5c4bd7c890febdc36b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2629554747ce321d9ea9fc688ecde30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_modulo_node.html">ModuloNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ae2629554747ce321d9ea9fc688ecde30">createModulo</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, int64_t divisor, bool signFollowDivisor=false)</td></tr>
<tr class="separator:ae2629554747ce321d9ea9fc688ecde30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc9ffad1ed89c88bc53b5121e8d1d5"><td class="memItemLeft" align="right" valign="top"><a id="ad5fc9ffad1ed89c88bc53b5121e8d1d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Add)</td></tr>
<tr class="separator:ad5fc9ffad1ed89c88bc53b5121e8d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5299ac3adfd3aa3f177e07fdef51b505"><td class="memItemLeft" align="right" valign="top"><a id="a5299ac3adfd3aa3f177e07fdef51b505"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Mul)</td></tr>
<tr class="separator:a5299ac3adfd3aa3f177e07fdef51b505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20bc7409fa02bd60c68cf268f772227"><td class="memItemLeft" align="right" valign="top"><a id="ab20bc7409fa02bd60c68cf268f772227"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Sub)</td></tr>
<tr class="separator:ab20bc7409fa02bd60c68cf268f772227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957466a0dd20deaa6695468c59c55dc5"><td class="memItemLeft" align="right" valign="top"><a id="a957466a0dd20deaa6695468c59c55dc5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Div)</td></tr>
<tr class="separator:a957466a0dd20deaa6695468c59c55dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db12acd2848454a919bc97924838485"><td class="memItemLeft" align="right" valign="top"><a id="a3db12acd2848454a919bc97924838485"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Max)</td></tr>
<tr class="separator:a3db12acd2848454a919bc97924838485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3b6f9d7f4f65bc1820c4bdcfab941a"><td class="memItemLeft" align="right" valign="top"><a id="a0f3b6f9d7f4f65bc1820c4bdcfab941a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Min)</td></tr>
<tr class="separator:a0f3b6f9d7f4f65bc1820c4bdcfab941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676ccc5af05703fee7bce9b2d50ae77e"><td class="memItemLeft" align="right" valign="top"><a id="a676ccc5af05703fee7bce9b2d50ae77e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (CmpLTE)</td></tr>
<tr class="separator:a676ccc5af05703fee7bce9b2d50ae77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfacd5bdf971b6f8faff5bc40277225"><td class="memItemLeft" align="right" valign="top"><a id="a4cfacd5bdf971b6f8faff5bc40277225"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (CmpLT)</td></tr>
<tr class="separator:a4cfacd5bdf971b6f8faff5bc40277225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724d8f9ff0b904331213717101ced8d"><td class="memItemLeft" align="right" valign="top"><a id="aa724d8f9ff0b904331213717101ced8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (CmpEQ)</td></tr>
<tr class="separator:aa724d8f9ff0b904331213717101ced8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca93b01c604a61e82f7a1795f8d674"><td class="memItemLeft" align="right" valign="top"><a id="a37ca93b01c604a61e82f7a1795f8d674"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ARITHMETIC_FUN_DECL</b> (Pow)</td></tr>
<tr class="separator:a37ca93b01c604a61e82f7a1795f8d674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a160429e8788071bc587a417edaa35"><td class="memItemLeft" align="right" valign="top"><a id="a45a160429e8788071bc587a417edaa35"></a>
std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>broadcastInputs</b> (int axis, const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; inputs)</td></tr>
<tr class="separator:a45a160429e8788071bc587a417edaa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b34304a6130cd64289773e212dba8b"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ad8b34304a6130cd64289773e212dba8b"><td class="memTemplItemLeft" align="right" valign="top">enable_if_same_t&lt; T, <a class="el" href="classglow_1_1_select_node.html">SelectNode</a> &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad8b34304a6130cd64289773e212dba8b">createNodeWithBroadcast</a> (const std::string &amp;name, int axis, Args &amp;&amp;... inputArgs)</td></tr>
<tr class="separator:ad8b34304a6130cd64289773e212dba8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3c2945ca9381bc22dc01559dcdbbe9"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a6b3c2945ca9381bc22dc01559dcdbbe9"><td class="memTemplItemLeft" align="right" valign="top">enable_if_same_t&lt; T, <a class="el" href="classglow_1_1_cmp_l_t_node.html">CmpLTNode</a> &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a6b3c2945ca9381bc22dc01559dcdbbe9">createNodeWithBroadcast</a> (const std::string &amp;name, int axis, Args &amp;&amp;... inputArgs)</td></tr>
<tr class="separator:a6b3c2945ca9381bc22dc01559dcdbbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441d3bf4a13e444a8ddaa5e129e3acee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_is_na_n_node.html">IsNaNNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a441d3bf4a13e444a8ddaa5e129e3acee">createIsNaN</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:a441d3bf4a13e444a8ddaa5e129e3acee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad091697cc2cabe1ec8139eab16df6432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_replace_na_n_node.html">ReplaceNaNNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad091697cc2cabe1ec8139eab16df6432">createReplaceNaN</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, float value)</td></tr>
<tr class="separator:ad091697cc2cabe1ec8139eab16df6432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa328c366d4dae452b12e4d3cfcafe4a3"><td class="memItemLeft" align="right" valign="top"><a id="aa328c366d4dae452b12e4d3cfcafe4a3"></a>
<a class="el" href="classglow_1_1_pow_node.html">PowNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createPow</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> base, float exp)</td></tr>
<tr class="separator:aa328c366d4dae452b12e4d3cfcafe4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cc5b13c00716d04eaae431674a17ba"><td class="memItemLeft" align="right" valign="top"><a id="a40cc5b13c00716d04eaae431674a17ba"></a>
<a class="el" href="classglow_1_1_select_node.html">SelectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSelect</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Cond, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> LHS, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> RHS)</td></tr>
<tr class="separator:a40cc5b13c00716d04eaae431674a17ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4709be4b92c0294ec4e6a08b8bc8abf"><td class="memItemLeft" align="right" valign="top"><a id="ae4709be4b92c0294ec4e6a08b8bc8abf"></a>
<a class="el" href="classglow_1_1_select_node.html">SelectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSelect</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Cond, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> LHS, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> RHS)</td></tr>
<tr class="separator:ae4709be4b92c0294ec4e6a08b8bc8abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae701e42c30454e8a1ad9021ae0544ad0"><td class="memItemLeft" align="right" valign="top"><a id="ae701e42c30454e8a1ad9021ae0544ad0"></a>
<a class="el" href="classglow_1_1_splat_node.html">SplatNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSplat</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> ty, float value)</td></tr>
<tr class="separator:ae701e42c30454e8a1ad9021ae0544ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645c430d478415bb9dbac164390ce3cb"><td class="memItemLeft" align="right" valign="top"><a id="a645c430d478415bb9dbac164390ce3cb"></a>
<a class="el" href="classglow_1_1_mat_mul_node.html">MatMulNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createMatMul</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lhs, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> rhs)</td></tr>
<tr class="separator:a645c430d478415bb9dbac164390ce3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34171d96ac8fd4cf496e5c54ffab00b"><td class="memItemLeft" align="right" valign="top"><a id="ae34171d96ac8fd4cf496e5c54ffab00b"></a>
<a class="el" href="classglow_1_1_mat_mul_node.html">MatMulNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createMatMul</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lhs, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> rhs)</td></tr>
<tr class="separator:ae34171d96ac8fd4cf496e5c54ffab00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb2262cb88e35da526281c917c89774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batch_mat_mul_node.html">BatchMatMulNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#abdb2262cb88e35da526281c917c89774">createBatchMatMul</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lhs, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> rhs)</td></tr>
<tr class="separator:abdb2262cb88e35da526281c917c89774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5f3c2af2648d3581dcb308ce2717f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batched_reduce_add_node.html">BatchedReduceAddNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a2c5f3c2af2648d3581dcb308ce2717f2">createBatchedReduceAdd</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; axes)</td></tr>
<tr class="separator:a2c5f3c2af2648d3581dcb308ce2717f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00d007284518a222352b1a8083c892e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batched_reduce_add_node.html">BatchedReduceAddNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ab00d007284518a222352b1a8083c892e">createBatchedReduceAdd</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; axes)</td></tr>
<tr class="separator:ab00d007284518a222352b1a8083c892e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f18260c6c63f0a20760a0a4a7ae2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batched_reduce_min_node.html">BatchedReduceMinNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a1e0f18260c6c63f0a20760a0a4a7ae2a">createBatchedReduceMin</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; axes)</td></tr>
<tr class="separator:a1e0f18260c6c63f0a20760a0a4a7ae2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8059d320a828aa4f6909804128479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batched_reduce_mean_node.html">BatchedReduceMeanNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad4c8059d320a828aa4f6909804128479">createBatchedReduceMean</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; axes)</td></tr>
<tr class="separator:ad4c8059d320a828aa4f6909804128479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5d9dca40362f4088f9e6db5c41b0ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batched_reduce_mean_node.html">BatchedReduceMeanNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aeb5d9dca40362f4088f9e6db5c41b0ee">createBatchedReduceMean</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; axes)</td></tr>
<tr class="separator:aeb5d9dca40362f4088f9e6db5c41b0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bed8634d0a19292fd3a82d84e405f8"><td class="memItemLeft" align="right" valign="top"><a id="a96bed8634d0a19292fd3a82d84e405f8"></a>
<a class="el" href="classglow_1_1_batched_add_node.html">BatchedAddNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createBatchedAdd</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> sample)</td></tr>
<tr class="separator:a96bed8634d0a19292fd3a82d84e405f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a3a119c976dabad7c60f1c45154ae"><td class="memItemLeft" align="right" valign="top"><a id="a429a3a119c976dabad7c60f1c45154ae"></a>
<a class="el" href="classglow_1_1_batched_add_node.html">BatchedAddNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createBatchedAdd</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> batch, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> sample)</td></tr>
<tr class="separator:a429a3a119c976dabad7c60f1c45154ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bdca6a0b3ac6ba120f98b28440e2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_lengths_sum_node.html">LengthsSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a24bdca6a0b3ac6ba120f98b28440e2bc">createLengthsSum</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths)</td></tr>
<tr class="separator:a24bdca6a0b3ac6ba120f98b28440e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd07dd06c24d69113033f9ceb1135ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sparse_lengths_sum_node.html">SparseLengthsSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5dd07dd06c24d69113033f9ceb1135ed">createSparseLengthsSum</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths)</td></tr>
<tr class="separator:a5dd07dd06c24d69113033f9ceb1135ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f7aafb024ab39071832980f90fa8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_node.html">SparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a294f7aafb024ab39071832980f90fa8d">createSparseLengthsWeightedSum</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths)</td></tr>
<tr class="separator:a294f7aafb024ab39071832980f90fa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a7f2e3210051403bbc3eecb016455e"><td class="memItemLeft" align="right" valign="top"><a id="af7a7f2e3210051403bbc3eecb016455e"></a>
<a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_offsets_node.html">SparseLengthsWeightedSumOffsetsNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#af7a7f2e3210051403bbc3eecb016455e">createSparseLengthsWeightedSumOffsets</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> offsets)</td></tr>
<tr class="memdesc:af7a7f2e3210051403bbc3eecb016455e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another version of SparseLengthsSum using offsets instead. <br /></td></tr>
<tr class="separator:af7a7f2e3210051403bbc3eecb016455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f195f77eb6fefdaac84ff2e1b887d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_node.html">SparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a1f195f77eb6fefdaac84ff2e1b887d75">createSparseLengthsWeightedSum</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths)</td></tr>
<tr class="separator:a1f195f77eb6fefdaac84ff2e1b887d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336683b0ec8e06e084caec12f60142fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a336683b0ec8e06e084caec12f60142fd">createRowwiseQuantizedSparseLengthsSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_constant.html">Constant</a> *data, <a class="el" href="classglow_1_1_constant.html">Constant</a> *scales, <a class="el" href="classglow_1_1_constant.html">Constant</a> *offsets, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> precision=ElemKind::FloatTy, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:a336683b0ec8e06e084caec12f60142fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7977506330eaf13bc3c39d63d83c333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ae7977506330eaf13bc3c39d63d83c333">createRowwiseQuantizedSparseLengthsSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, quantization::Schema schema, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> precision=ElemKind::FloatTy, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:ae7977506330eaf13bc3c39d63d83c333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17510e67747d910c5ba7999ff498ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ae17510e67747d910c5ba7999ff498ea5">createRowwiseQuantizedSparseLengthsWeightedSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_constant.html">Constant</a> *data, <a class="el" href="classglow_1_1_constant.html">Constant</a> *scales, <a class="el" href="classglow_1_1_constant.html">Constant</a> *offsets, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> precision=ElemKind::FloatTy, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:ae17510e67747d910c5ba7999ff498ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae39e625ab8f247f03f7283dd7d0dd80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aae39e625ab8f247f03f7283dd7d0dd80">createRowwiseQuantizedSparseLengthsWeightedSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, quantization::Schema schema, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> precision=ElemKind::FloatTy, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:aae39e625ab8f247f03f7283dd7d0dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec48696db840ba590510e6c282b3a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html">FusedRowwiseQuantizedSparseLengthsSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a1ec48696db840ba590510e6c282b3a38">createFusedRowwiseQuantizedSparseLengthsSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_constant.html">Constant</a> *data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:a1ec48696db840ba590510e6c282b3a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fe21630865f07b5fcaba7dcdeff6cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html">FusedRowwiseQuantizedSparseLengthsSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a50fe21630865f07b5fcaba7dcdeff6cb">createFusedRowwiseQuantizedSparseLengthsSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> fusedElemKind=ElemKind::UInt8FusedQTy, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:a50fe21630865f07b5fcaba7dcdeff6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc35291a608ce9d7aa2806ed50fa1e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html">FusedRowwiseQuantizedSparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#acc35291a608ce9d7aa2806ed50fa1e1b">createFusedRowwiseQuantizedSparseLengthsWeightedSum</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:acc35291a608ce9d7aa2806ed50fa1e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4463d76e607351b153d5c4704e9b26bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html">FusedRowwiseQuantizedSparseLengthsWeightedSumNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a4463d76e607351b153d5c4704e9b26bb">createFusedRowwiseQuantizedSparseLengthsWeightedSum</a> (llvm::StringRef name, <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> weights, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> fusedElemKind=ElemKind::UInt8FusedQTy, bool useFP16Accumulation=false)</td></tr>
<tr class="separator:a4463d76e607351b153d5c4704e9b26bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98924f81beee494322bc1cb8e7f5e5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_lengths_to_ranges_node.html">LengthsToRangesNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a98924f81beee494322bc1cb8e7f5e5e7">createLengthsToRanges</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths)</td></tr>
<tr class="separator:a98924f81beee494322bc1cb8e7f5e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e83d1e9da4a42527cc13d24ac29c17b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_lengths_range_fill_node.html">LengthsRangeFillNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0e83d1e9da4a42527cc13d24ac29c17b">createLengthsRangeFill</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> maxOutputSize)</td></tr>
<tr class="separator:a0e83d1e9da4a42527cc13d24ac29c17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30faa862c948082d65911e42d9745e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sparse_to_dense_node.html">SparseToDenseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aa30faa862c948082d65911e42d9745e3">createSparseToDense</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> values, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> dataToInferDim)</td></tr>
<tr class="separator:aa30faa862c948082d65911e42d9745e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c8dca4c538dfdf2d248bdb2c8d680a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_sparse_to_dense_mask_node.html">SparseToDenseMaskNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a40c8dca4c538dfdf2d248bdb2c8d680a">createSparseToDenseMask</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> values, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> defaultValue, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, llvm::ArrayRef&lt; int64_t &gt; mask)</td></tr>
<tr class="separator:a40c8dca4c538dfdf2d248bdb2c8d680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe83becaad9631ff34377f9b0943b54"><td class="memItemLeft" align="right" valign="top"><a id="a8fe83becaad9631ff34377f9b0943b54"></a>
<a class="el" href="classglow_1_1_save_node.html">SaveNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSave</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:a8fe83becaad9631ff34377f9b0943b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b112a4a4d551c9069d894d4dd7a0e6e"><td class="memItemLeft" align="right" valign="top"><a id="a3b112a4a4d551c9069d894d4dd7a0e6e"></a>
<a class="el" href="classglow_1_1_save_node.html">SaveNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createSave</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="classglow_1_1_placeholder.html">Placeholder</a> *output)</td></tr>
<tr class="separator:a3b112a4a4d551c9069d894d4dd7a0e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9866986d73736c124e1bfaf3222aa13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_quantization_profile_node.html">QuantizationProfileNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ae9866986d73736c124e1bfaf3222aa13">createQuantizationProfile</a> (<a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;bindings, llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:ae9866986d73736c124e1bfaf3222aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb9971cd6af5a091098680ae2a26e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_int_lookup_table_node.html">IntLookupTableNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ab6fb9971cd6af5a091098680ae2a26e0">createIntLookupTable</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, llvm::ArrayRef&lt; int8_t &gt; initValues, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:ab6fb9971cd6af5a091098680ae2a26e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0896ecd6746f310b8794f0cc26cbb378"><td class="memItemLeft" align="right" valign="top"><a id="a0896ecd6746f310b8794f0cc26cbb378"></a>
<a class="el" href="classglow_1_1_int_lookup_table_node.html">IntLookupTableNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0896ecd6746f310b8794f0cc26cbb378">createIntTanh</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="memdesc:a0896ecd6746f310b8794f0cc26cbb378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create quantized tanh. <br /></td></tr>
<tr class="separator:a0896ecd6746f310b8794f0cc26cbb378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fb048e72c58e2b6be7403503e1dc55"><td class="memItemLeft" align="right" valign="top"><a id="a14fb048e72c58e2b6be7403503e1dc55"></a>
<a class="el" href="classglow_1_1_int_lookup_table_node.html">IntLookupTableNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a14fb048e72c58e2b6be7403503e1dc55">createIntSigmoid</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="memdesc:a14fb048e72c58e2b6be7403503e1dc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create quantized sigmoid. <br /></td></tr>
<tr class="separator:a14fb048e72c58e2b6be7403503e1dc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f21b419a4f8b79696807baa54d257"><td class="memItemLeft" align="right" valign="top"><a id="a6e2f21b419a4f8b79696807baa54d257"></a>
<a class="el" href="classglow_1_1_top_k_node.html">TopKNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createTopK</b> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> k)</td></tr>
<tr class="separator:a6e2f21b419a4f8b79696807baa54d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dedd74fc1b4538ad12cd60d43339dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_gather_node.html">GatherNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5dedd74fc1b4538ad12cd60d43339dc8">createGather</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> batchDims=0)</td></tr>
<tr class="separator:a5dedd74fc1b4538ad12cd60d43339dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff08f2044b5486dc1df39158fd333ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_gather_ranges_node.html">GatherRangesNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aff08f2044b5486dc1df39158fd333ceb">createGatherRanges</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> ranges, <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> maxOutputSize)</td></tr>
<tr class="separator:aff08f2044b5486dc1df39158fd333ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe25057f5bb26ea1011b44b8815d6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_scatter_data_node.html">ScatterDataNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#acbe25057f5bb26ea1011b44b8815d6c9">createScatterData</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> indices, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> slices, bool cumulative=false)</td></tr>
<tr class="separator:acbe25057f5bb26ea1011b44b8815d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0863b14aadd1072ca7f12a1925a790b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_batch_one_hot_node.html">BatchOneHotNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a0863b14aadd1072ca7f12a1925a790b0">createBatchOneHot</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> data, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lengths, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> values)</td></tr>
<tr class="separator:a0863b14aadd1072ca7f12a1925a790b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad17e40fffb4fe287d329c74a32256ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_space_to_depth_node.html">SpaceToDepthNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#aad17e40fffb4fe287d329c74a32256ea">createSpaceToDepth</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, unsigned blockSize)</td></tr>
<tr class="separator:aad17e40fffb4fe287d329c74a32256ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e21b55f20e481869522d45d6856f8ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_resize_nearest_node.html">ResizeNearestNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a3e21b55f20e481869522d45d6856f8ae">createResizeNearest</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, float heightScale, float widthScale)</td></tr>
<tr class="separator:a3e21b55f20e481869522d45d6856f8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5137409e46739131c920052ea550b003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_quantize_node.html">QuantizeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5137409e46739131c920052ea550b003">createQuantize</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:a5137409e46739131c920052ea550b003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553e6f6d7495c5371f64a9a41080f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_dequantize_node.html">DequantizeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ac553e6f6d7495c5371f64a9a41080f8d">createDequantize</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input)</td></tr>
<tr class="separator:ac553e6f6d7495c5371f64a9a41080f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e4f0404804fe1b57bb77e5f9a48e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_dequantize_node.html">DequantizeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#a5f8e4f0404804fe1b57bb77e5f9a48e8">createDequantize</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:a5f8e4f0404804fe1b57bb77e5f9a48e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac964783c66b57eb30d0d643cf73026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_rescale_quantized_node.html">RescaleQuantizedNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#acac964783c66b57eb30d0d643cf73026">createRescaleQuantized</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_type.html">TypeRef</a> outTy)</td></tr>
<tr class="separator:acac964783c66b57eb30d0d643cf73026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab511da8a4555e0e9b7e62b2f378716c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ab511da8a4555e0e9b7e62b2f378716c9">createWeightedSum</a> (llvm::StringRef name, llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; data, llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; weights)</td></tr>
<tr class="separator:ab511da8a4555e0e9b7e62b2f378716c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6329d3a8eb625ebd0a6b8f77762801f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#ad6329d3a8eb625ebd0a6b8f77762801f">createBatchBoxCox</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lambda1, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> lambda2, float epsilon=std::numeric_limits&lt; float &gt;::min())</td></tr>
<tr class="separator:ad6329d3a8eb625ebd0a6b8f77762801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91f1a1f6278ab97ef760c5a04b34a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_clip_node.html">ClipNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_function.html#af91f1a1f6278ab97ef760c5a04b34a6a">createClip</a> (llvm::StringRef name, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> input, float min, float max)</td></tr>
<tr class="separator:af91f1a1f6278ab97ef760c5a04b34a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the compute graph. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a52bb076e6a99804a4349e1cb3b54291f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bb076e6a99804a4349e1cb3b54291f">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_function.html">Function</a> * Function::clone </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>newName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::DenseMap&lt; <a class="el" href="classglow_1_1_node.html">Node</a> *, <a class="el" href="classglow_1_1_node.html">Node</a> *&gt; *&#160;</td>
          <td class="paramname"><em>map</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clone the current function into a new function with the name <code>newName</code>. If <code>map</code> is non-null then the procedure records the mapping between the old node to the new node in <code>map</code>. </p><dl class="section return"><dt>Returns</dt><dd>a new function that is a copy of the current function. </dd></dl>

</div>
</div>
<a id="a5145a97eddf1d1dd26ae7a9de37b341b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5145a97eddf1d1dd26ae7a9de37b341b">&#9670;&nbsp;</a></span>createAdaptiveAvgPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_adaptive_avg_pool_node.html">AdaptiveAvgPoolNode</a> * Function::createAdaptiveAvgPool </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>an AdaptiveAvgPool node with <code>name</code>, <code>input</code>, and <code>outTy</code>. The <a class="el" href="classglow_1_1_adaptive_avg_pool_node.html" title="Performs an Adaptive Average Pool operation on the Input given. ">AdaptiveAvgPoolNode</a> will perform average pooling over the input so that the result is of the shape specified by <code>outTy</code>. </dd></dl>

</div>
</div>
<a id="a0dffc1674d4a1654cb7206a4d7752b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dffc1674d4a1654cb7206a4d7752b1e">&#9670;&nbsp;</a></span>createArgMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_arg_max_node.html">ArgMaxNode</a> * Function::createArgMax </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the indices of the max elements of the input tensor along the provided <code>axis</code>. The resulted tensor has the same rank as the input if <code>keepDims</code> equal 1. If <code>keepdims</code> equals 0, the resulted tensor has the reduced dimension pruned. The type of the output tensor is int64. </p>

</div>
</div>
<a id="ad6329d3a8eb625ebd0a6b8f77762801f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6329d3a8eb625ebd0a6b8f77762801f">&#9670;&nbsp;</a></span>createBatchBoxCox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createBatchBoxCox </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;float&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a series of nodes that implements a two-parameter rowwise Box-Cox transform. For each element of the <code>input</code> x, this is defined as:</p>
<p>y = ln(max(x + lambda2, 1e-6)), if lambda1 == 0 (max(x + lambda2, 1e-6)^lambda1 - 1)/lambda1, if lambda1 != 0</p>
<p>The transform parameters <code>lambda1</code> and <code>lambda2</code> are vectors of size D that are broadcasted to match the size of <code>input</code> (NxD). The transform itself is implemented using elementwise Max, Add, Log (if lambda1 == 0), Pow, Splat, Sub, and Div (if lambda1 != 0) nodes with a Splat and Select node to select between the two cases listed above. </p><dl class="section return"><dt>Returns</dt><dd>the final Select node. <code>epsilon</code> is used to ensure we do not divide by zero when calculating the lambda == 0 case, as we use a Select to choose which result to use, and so both paths are executed. </dd></dl>

</div>
</div>
<a id="a2c5f3c2af2648d3581dcb308ce2717f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5f3c2af2648d3581dcb308ce2717f2">&#9670;&nbsp;</a></span>createBatchedReduceAdd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batched_reduce_add_node.html">BatchedReduceAddNode</a> * Function::createBatchedReduceAdd </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing BatchedReduceAdd operation. Output type is based on the input <code>batch</code> type with dimensions specified with <code>axes</code> removed. </p>

</div>
</div>
<a id="ab00d007284518a222352b1a8083c892e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00d007284518a222352b1a8083c892e">&#9670;&nbsp;</a></span>createBatchedReduceAdd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batched_reduce_add_node.html">BatchedReduceAddNode</a> * Function::createBatchedReduceAdd </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing BatchedReduceAdd operation. Output type matches input <code>outTy</code> type. </p>

</div>
</div>
<a id="ad4c8059d320a828aa4f6909804128479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c8059d320a828aa4f6909804128479">&#9670;&nbsp;</a></span>createBatchedReduceMean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batched_reduce_mean_node.html">BatchedReduceMeanNode</a> * Function::createBatchedReduceMean </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing BatchedReduceMean operation. Output type matches input <code>outTy</code> type. </p>

</div>
</div>
<a id="aeb5d9dca40362f4088f9e6db5c41b0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5d9dca40362f4088f9e6db5c41b0ee">&#9670;&nbsp;</a></span>createBatchedReduceMean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batched_reduce_mean_node.html">BatchedReduceMeanNode</a> * Function::createBatchedReduceMean </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing BatchedReduceMean operation. Output type is based on the input <code>batch</code> type with dimensions specified with <code>axes</code> removed. </p>

</div>
</div>
<a id="a1e0f18260c6c63f0a20760a0a4a7ae2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0f18260c6c63f0a20760a0a4a7ae2a">&#9670;&nbsp;</a></span>createBatchedReduceMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batched_reduce_min_node.html">BatchedReduceMinNode</a> * Function::createBatchedReduceMin </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing BatchedReduceMin operation. Output type is based on the input <code>batch</code> type with dimensions specified with <code>axes</code> removed. </p>

</div>
</div>
<a id="abdb2262cb88e35da526281c917c89774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb2262cb88e35da526281c917c89774">&#9670;&nbsp;</a></span>createBatchMatMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batch_mat_mul_node.html">BatchMatMulNode</a> * Function::createBatchMatMul </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>lhs</code> and <code>rhs</code> are 3d matrices, where the leading dimension is the batch size. For each batch element number i, lhs.slice(i) is multiplied by rhs.slice(i). </p>

</div>
</div>
<a id="a0863b14aadd1072ca7f12a1925a790b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0863b14aadd1072ca7f12a1925a790b0">&#9670;&nbsp;</a></span>createBatchOneHot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_batch_one_hot_node.html">BatchOneHotNode</a> * Function::createBatchOneHot </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given 2D matrix <code>data</code>, 1D vector <code>lengths</code> (of the same size as width of <code>data</code>), and 1D vector <code>values</code> (of the same size as sum of <code>lengths</code>), expand each row of the <code>data</code> to a row of zeros and ones, according to One Hot Encoding. j-th element of resulting i-th row is one iff <code>values</code>[j] == <code>data</code>[i][some index within range of j]. </p>

</div>
</div>
<a id="a757d71d8785b075edcc6f0e9b9bc12ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757d71d8785b075edcc6f0e9b9bc12ac">&#9670;&nbsp;</a></span>createBroadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createBroadcast </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnsignedArrayRef&#160;</td>
          <td class="paramname"><em>newShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a series of nodes that implement a Broadcast operation. The <code>input</code> <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> is broadcasted based on <code>newShape</code> and along the <code>axis</code>, which defines the offset from the leading dimension under which broadcasting is performed. </p>

</div>
</div>
<a id="aa6412c6acdbc1e9c6ec002c841e071f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6412c6acdbc1e9c6ec002c841e071f7">&#9670;&nbsp;</a></span>createBucketizeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_bucketize_node.html">BucketizeNode</a> * Function::createBucketizeNode </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; float &gt;&#160;</td>
          <td class="paramname"><em>boundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bucketizes the input tensor based on monotonically increasing <code>boundaries</code> for each value in <code>input</code>. For each value x in input, the operator </p><dl class="section return"><dt>Returns</dt><dd>index i given boundaries[i-1] &lt; x &lt;= boundaries[i]. If the value x is beyond the bounds of boundaries, 0 or len(boundaries) is returned as appropriate. </dd></dl>

</div>
</div>
<a id="a0a16974812ba2aaadd2ec5cf521ef1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a16974812ba2aaadd2ec5cf521ef1a0">&#9670;&nbsp;</a></span>createChannelShuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createChannelShuffle </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuffles dimension number <code>kernel</code>. Suppose original size is D. It will be represented as groupX(D/group) matrix, transposed and concatenated back to size D. For example, shuffle of {1, 2, 3, 4, 5, 6} with <code>group</code> = 2 is {1, 4, 2, 5, 3, 6} </p>

</div>
</div>
<a id="a94c1fee1a3b4e7779c7a1cee21592f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c1fee1a3b4e7779c7a1cee21592f0f">&#9670;&nbsp;</a></span>createChannelwiseQuantizedConv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_channelwise_quantized_convolution_node.html">ChannelwiseQuantizedConvolutionNode</a> * Function::createChannelwiseQuantizedConv </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>scales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_channelwise_quantized_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">ChannelwiseQuantizedConvolutionNode</a> with the given <code>name</code> which convolves the 4D <code>input</code> with <code>filter</code> and . <code>scales</code> and <code>offsets</code> provide individual quantization parameters for each filter group in <code>filter</code>. <code>kernels</code> defines the size of the height and width dimensions of the filters. <code>strides</code> defines the number of steps to take in the input for each output cell. <code>pads</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. NOTE: <a class="el" href="classglow_1_1_channelwise_quantized_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">ChannelwiseQuantizedConvolutionNode</a> does not yet have an implementation so attempting to run a graph containing this node fails. </p>

</div>
</div>
<a id="af91f1a1f6278ab97ef760c5a04b34a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91f1a1f6278ab97ef760c5a04b34a6a">&#9670;&nbsp;</a></span>createClip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_clip_node.html">ClipNode</a> * Function::createClip </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a series of nodes for the Clip operator. It limits the given input within an interval specified by the <code>min</code> and <code>max</code> arguments. </p>

</div>
</div>
<a id="a0b28c191e7dbb0c0c83165a7c7107313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b28c191e7dbb0c0c83165a7c7107313">&#9670;&nbsp;</a></span>createConv() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> * Function::createConv </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code>ConvolutionLayout::NHWC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">ConvolutionNode</a> with the given <code>name</code> which convolves the 4D <code>input</code> with <code>filter</code> and . <code>kernels</code> defines the size of the height and width dimensions of the filters. <code>strides</code> defines the number of steps to take in the input for each output cell. <code>pads</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. <code>dilation</code> defines factor by which gap between 2 neighboring kernel elements is expanded along each axis. <code>layout</code> defines the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> layout and must be either NHWC or NCHW. </p>

</div>
</div>
<a id="ad16bccb2690886aa72ad02131f9caf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16bccb2690886aa72ad02131f9caf2c">&#9670;&nbsp;</a></span>createConv() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> * Function::createConv </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code>ConvolutionLayout::NHWC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">ConvolutionNode</a> with the given <code>name</code> which convolves the 4D <code>input</code> with <code>filter</code> and . <code>kernel</code> defines the size of the height and width dimensions of the filters. <code>stride</code> defines the number of steps to take in the input for each output cell. <code>pad</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. <code>dilation</code> defines factor by which gap between 2 neighboring kernel elements is expanded along each axis. <code>layout</code> defines the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> layout and must be either NHWC or NCHW. </p>

</div>
</div>
<a id="a878cada26ba13b88d149d7a631f5ae10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878cada26ba13b88d149d7a631f5ae10">&#9670;&nbsp;</a></span>createConv() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> * Function::createConv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code>NHWC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">ConvolutionNode</a> with the given <code>name</code> which convolves the 4D <code>input</code>. <code>kernels</code> defines the size of the height and width dimensions of the convolutional filters. <code>stride</code> defines the the number of steps to take in the input for each output cell. <code>pads</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. <code>dilation</code> defines factor by which gap between 2 neighboring kernel elements is expanded along each axis. <code>layout</code> defines the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> layout and must be either NHWC or NCHW. </p>

</div>
</div>
<a id="a9fce0de99a46d774b0f9bd9aa04b1498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fce0de99a46d774b0f9bd9aa04b1498">&#9670;&nbsp;</a></span>createConv() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution_node.html">ConvolutionNode</a> * Function::createConv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#aa2f3a33e05699df0f42295c5c4bd1f77">ConvolutionLayout</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code>NHWC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">ConvolutionNode</a> with the given <code>name</code> which convolves the 4D <code>input</code>. <code>kernel</code> defines the size of the height and width dimensions of the convolutional filters. <code>stride</code> defines the the number of steps to take in the input for each output cell. <code>pad</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately.<code>dilation</code> defines factor by which gap between 2 neighboring kernel elements is expanded along each axis. <code>layout</code> defines the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> layout and must be either NHWC or NCHW. </p>

</div>
</div>
<a id="a5eec756ea2779f3768102cd496cce846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eec756ea2779f3768102cd496cce846">&#9670;&nbsp;</a></span>createConv3D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> * Function::createConv3D </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution3_d_node.html" title="Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">Convolution3DNode</a> with the given <code>name</code> which convolves the 5D <code>input</code> with <code>filter</code> and . <code>kernels</code> defines the size of the height, width, and depth dimensions of the filters. <code>strides</code> defines the the number of steps to take in the input for each output cell. <code>pads</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. <code>outTy</code> defines the type of the output of the 3d convolution. </p>

</div>
</div>
<a id="a29c34498d91c08a88e7f503bcb55646d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c34498d91c08a88e7f503bcb55646d">&#9670;&nbsp;</a></span>createConv3D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> * Function::createConv3D </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution3_d_node.html" title="Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">Convolution3DNode</a> with the given <code>name</code> which convolves the 5D <code>input</code> with <code>filter</code> and . <code>kernel</code> defines the size of the height, width, and depth dimensions of the filters. <code>stride</code> defines the the number of steps to take in the input for each output cell. <code>pad</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. <code>outTy</code> defines the type of the output of the 3d convolution. </p>

</div>
</div>
<a id="aaad3ec8a2afa0bcfcb21a55719f3df4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad3ec8a2afa0bcfcb21a55719f3df4f">&#9670;&nbsp;</a></span>createConv3D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> * Function::createConv3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>kernels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>pads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution3_d_node.html" title="Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">Convolution3DNode</a> with the given <code>name</code> which convolves the 5D <code>input</code>. <code>kernels</code> defines the size of the height, width, and depth dimensions of the convolutional filters. <code>strides</code> defines the the number of steps to take in the input for each output cell. <code>pads</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. </p>

</div>
</div>
<a id="a99742506dcf9c372bb92cf74e8160de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99742506dcf9c372bb92cf74e8160de2">&#9670;&nbsp;</a></span>createConv3D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convolution3_d_node.html">Convolution3DNode</a> * Function::createConv3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classglow_1_1_convolution3_d_node.html" title="Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels...">Convolution3DNode</a> with the given <code>name</code> which convolves the 5D <code>input</code>. <code>kernel</code> defines the size of the height, width, and depth dimensions of the convolutional filters. <code>stride</code> defines the the number of steps to take in the input for each output cell. <code>pad</code> defines how many zero padding cells should be added to the input during convolution. <code>group</code> defines the number of groups the input and output channels should be divided into and convolved separately. </p>

</div>
</div>
<a id="afb186d99df71f01dc37871b7a91fe207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb186d99df71f01dc37871b7a91fe207">&#9670;&nbsp;</a></span>createConvertTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convert_to_node.html">ConvertToNode</a> * Function::createConvertTo </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a ConvertTo <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> with name <code>name</code> of <code>input</code> to output type <code>outTy</code>. </dd></dl>

</div>
</div>
<a id="aad00b9f260eb7c5c21f5c59ebd0089b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad00b9f260eb7c5c21f5c59ebd0089b3">&#9670;&nbsp;</a></span>createConvertTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_convert_to_node.html">ConvertToNode</a> * Function::createConvertTo </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a ConvertTo <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> with name <code>name</code> of <code>input</code> to output ElemKind <code>k</code>. </dd></dl>

</div>
</div>
<a id="ac553e6f6d7495c5371f64a9a41080f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac553e6f6d7495c5371f64a9a41080f8d">&#9670;&nbsp;</a></span>createDequantize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_dequantize_node.html">DequantizeNode</a> * Function::createDequantize </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create dequantization node which transforms quantized tensor to a floating point one with given Scale and Offset. Scale and Offset params are part of the <code>input</code>. </p>

</div>
</div>
<a id="a5f8e4f0404804fe1b57bb77e5f9a48e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e4f0404804fe1b57bb77e5f9a48e8">&#9670;&nbsp;</a></span>createDequantize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_dequantize_node.html">DequantizeNode</a> * Function::createDequantize </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create dequantization node which transforms quantized tensor to a floating point type <code>outTy</code> one with given Scale and Offset. Scale and Offset params are part of the <code>input</code>. </p>

</div>
</div>
<a id="accf9b83116497dd0ac4c3bb730be5153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf9b83116497dd0ac4c3bb730be5153">&#9670;&nbsp;</a></span>createDotProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createDotProduct </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implement an operation that computes the row-wise dot product of its inputs. Consequently, <code>X</code> and <code>Y</code> must be either 1D or 2D tensors. This lowered to a Mul node, and is followed by a BatchedReduceAdd if <code>X</code> and <code>Y</code> are 2D. </p><dl class="section return"><dt>Returns</dt><dd>either the Mul or BatchedReduceAdd node. </dd></dl>

</div>
</div>
<a id="aefc00c1542599ab75332a236d1aee6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc00c1542599ab75332a236d1aee6a3">&#9670;&nbsp;</a></span>createElementwiseLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createElementwiseLinear </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node that implements the elementwise linear operator. <code>X</code> is 2D and <code>w</code> and <code>b</code> are 1D. <code>w</code> and <code>b</code> are broadcasted to match the shape of <code>X</code> and then the output is computed by multiplying <code>X</code> and broadcasted <code>w</code> and adding broadcasted <code>b</code>. </p><dl class="section return"><dt>Returns</dt><dd>the ElementwiseLinearNode. <code>axis</code> indicates the axis of the inputs (the other axis of <code>X</code> is assumed to be the batch index). </dd></dl>

</div>
</div>
<a id="af32483c4b5aff8743513d9eeec6d26fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32483c4b5aff8743513d9eeec6d26fe">&#9670;&nbsp;</a></span>createExp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_exp_node.html">ExpNode</a> * Function::createExp </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an Exp node with <code>name</code>, which calculates element-wise exponential of <code>input</code>. </p>

</div>
</div>
<a id="a05272c5de8896a7f0110b620ae8ee3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05272c5de8896a7f0110b620ae8ee3d9">&#9670;&nbsp;</a></span>createExpandDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> * Function::createExpandDims </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add single-dimensional entries to the shape of the <code>input</code> tensor at locations in <code>axes</code>. <code>axes</code> is listed as seen in the output tensor. Implemented as a single <a class="el" href="classglow_1_1_reshape_node.html" title="Reshape the Input tensor to shape Dims. ">ReshapeNode</a>. This is the opposite of Squeeze. </p>

</div>
</div>
<a id="a5978750e2f05e9c022756e49e2591830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5978750e2f05e9c022756e49e2591830">&#9670;&nbsp;</a></span>createFlatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> * Function::createFlatten </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flattens the input tensor into a 2D matrix. If input tensor has shape (d_0, d_1, ... d_n) then the output will have shape: (d_0 X d_1 ... d_(axis-1), d_axis X d_(axis+1) ... X d_n). </p>

</div>
</div>
<a id="a369fe971f7e75ca38ff5d6bb0928be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369fe971f7e75ca38ff5d6bb0928be89">&#9670;&nbsp;</a></span>createFullyConnected() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a> * Function::createFullyConnected </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_storage.html">Storage</a> *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_storage.html">Storage</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_fully_connected_node.html" title="Creates a FullyConnected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output. ">FullyConnectedNode</a> with <code>name</code>, <code>input</code>, weights <code>W</code>, bias <code>B</code>. If <code>input</code> is not 2 dimensional then it is flattened along <code>axis</code>. Note, output type and outputDepth are inferred based on the input types. </dd></dl>

</div>
</div>
<a id="ad38b3e6dd3052c286126ab1239d97aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38b3e6dd3052c286126ab1239d97aa8">&#9670;&nbsp;</a></span>createFullyConnected() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a> * Function::createFullyConnected </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_fully_connected_node.html" title="Creates a FullyConnected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output. ">FullyConnectedNode</a> with <code>name</code>, <code>input</code>, weights <code>W</code>, bias <code>B</code>, and <code>outTy</code>. If <code>input</code> is not 2 dimensional then it is flattened along <code>axis</code>. Note, outputDepth is inferred based on <code>outTy</code>. </dd></dl>

</div>
</div>
<a id="ade9306e5e5d5665e16fc64dcf8df3e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9306e5e5d5665e16fc64dcf8df3e94">&#9670;&nbsp;</a></span>createFullyConnected() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fully_connected_node.html">FullyConnectedNode</a> * Function::createFullyConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_fully_connected_node.html" title="Creates a FullyConnected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output. ">FullyConnectedNode</a> with <code>name</code>, <code>input</code>, weights <code>W</code>, bias <code>B</code>. If <code>input</code> is not 2 dimensional then it is flattened along <code>axis</code>. Note, output type is inferred based on the input types. Trainable weight and bias variables are created implicitly. </dd></dl>

</div>
</div>
<a id="a1ec48696db840ba590510e6c282b3a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec48696db840ba590510e6c282b3a38">&#9670;&nbsp;</a></span>createFusedRowwiseQuantizedSparseLengthsSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html">FusedRowwiseQuantizedSparseLengthsSumNode</a> * Function::createFusedRowwiseQuantizedSparseLengthsSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a node of <code>name</code>, performing the SparseLengthsSum operation, using fused rowwise quantization for the input <code>data</code> wherein the scales and offsets are fused inline with each row of data. <code>data</code> must be of a fused ElemKind. Gathers slices of the outer-most dimension of data indexed by the <code>indices</code> vector, and then accumulates them into len(<code>lengths</code>) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). The precision for the Result is determined by the <code>data</code> input's ElemKind used for Scale and Offset. If <code>useFP16Accumulation</code>, then internal arithmetic will use FP16 accumulation; otherwise defaults to FP32. </dd></dl>

</div>
</div>
<a id="a50fe21630865f07b5fcaba7dcdeff6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fe21630865f07b5fcaba7dcdeff6cb">&#9670;&nbsp;</a></span>createFusedRowwiseQuantizedSparseLengthsSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html">FusedRowwiseQuantizedSparseLengthsSumNode</a> * Function::createFusedRowwiseQuantizedSparseLengthsSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>fusedElemKind</em> = <code>ElemKind::UInt8FusedQTy</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#a1ec48696db840ba590510e6c282b3a38">createFusedRowwiseQuantizedSparseLengthsSum()</a>, but expects float input <code>data</code>, which is rowwise-quantized and fused internally. <code>fusedElemKind</code> represents the element kind to use for the final fused rowwise-quantized data. </p>

</div>
</div>
<a id="acc35291a608ce9d7aa2806ed50fa1e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc35291a608ce9d7aa2806ed50fa1e1b">&#9670;&nbsp;</a></span>createFusedRowwiseQuantizedSparseLengthsWeightedSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html">FusedRowwiseQuantizedSparseLengthsWeightedSumNode</a> * Function::createFusedRowwiseQuantizedSparseLengthsWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#a1ec48696db840ba590510e6c282b3a38">createFusedRowwiseQuantizedSparseLengthsSum()</a>, but i-th slice is multiplied by weights[i]. len(weights) must be equal to len(indices). </p>

</div>
</div>
<a id="a4463d76e607351b153d5c4704e9b26bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4463d76e607351b153d5c4704e9b26bb">&#9670;&nbsp;</a></span>createFusedRowwiseQuantizedSparseLengthsWeightedSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html">FusedRowwiseQuantizedSparseLengthsWeightedSumNode</a> * Function::createFusedRowwiseQuantizedSparseLengthsWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>fusedElemKind</em> = <code>ElemKind::UInt8FusedQTy</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#acc35291a608ce9d7aa2806ed50fa1e1b">createFusedRowwiseQuantizedSparseLengthsWeightedSum()</a>, but expects float input <code>data</code>, which is rowwise-quantized and fused internally. <code>fusedElemKind</code> represents the element kind to use for the final fused rowwise-quantized data. </p>

</div>
</div>
<a id="a5dedd74fc1b4538ad12cd60d43339dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dedd74fc1b4538ad12cd60d43339dc8">&#9670;&nbsp;</a></span>createGather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_gather_node.html">GatherNode</a> * Function::createGather </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>batchDims</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gathers entries of the outer-most dimension of <code>data</code> indexed by <code>indices</code>, and concatenates them. A non-zero <code>batchDims</code> specifies the batch, and the result is the concatenation of the operation on each sample in the batch. </p>

</div>
</div>
<a id="aff08f2044b5486dc1df39158fd333ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff08f2044b5486dc1df39158fd333ceb">&#9670;&nbsp;</a></span>createGatherRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_gather_ranges_node.html">GatherRangesNode</a> * Function::createGatherRanges </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>maxOutputSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing GatherRanges operation: Gathers entries of <code>data</code> in groups specified by the "examples" in <code>ranges</code>. Each example in <code>ranges</code> contains a list of pairs of indices of the form (index, length) which specify which entries of <code>data</code> to gather. The ordering of elements in <code>ranges</code> and of pairs within an element is preserved in the output. In addition to the result of gathering ("output"), the lengths of the ranges gathered by each example in <code>ranges</code> is also produced as an output ("lengths"). <code>maxOutputSize</code> is the maximum possible size of "output" and is used to set its type. Users must use "lengths" to interpret "output" correctly. </p><dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classglow_1_1_gather_ranges_node.html" title="Gathers entries of Data into Output in groups specified by the elements of Ranges. Each element of Ranges contains a list of pairs of indices of the form (index, length) which specify which entries of data to gather. The ordering of elements in Ranges and of pairs within an element is preserved in Output. Lengths contains the lengths of the ranges gathered by each list of pairs in Ranges. ">GatherRangesNode</a>. </dd></dl>

</div>
</div>
<a id="a38073ffa1c63421716ee236d56178738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38073ffa1c63421716ee236d56178738">&#9670;&nbsp;</a></span>createGRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Function::createGRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>namePrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>hiddenSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>outputSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an unrolled single-layer GRU cell with <code>hiddenSize</code> dimensionality of the hidden state and <code>outputSize</code> dimensionality of the output state. <code>inputs</code> define the input for the cell at each time step and the number of time steps is equal to the size of the <code>inputs</code>. The names of the created variables are prefixed by <code>namePrefix</code>. The output variables are written to <code>outputs</code>, they represent the activation of the output layer, unrolled over time. </p>

</div>
</div>
<a id="aeacd10cc5da0f12caa196897ce7a6141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacd10cc5da0f12caa196897ce7a6141">&#9670;&nbsp;</a></span>createInsertTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_insert_tensor_node.html">InsertTensorNode</a> * Function::createInsertTensor </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>big</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>small</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an insert tensor node <code>name</code>, which inserts <code>small</code> into <code>big</code> at offset into big <code>start</code> <code>count</code> times along <code>axis</code>. </p>

</div>
</div>
<a id="ab6fb9971cd6af5a091098680ae2a26e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fb9971cd6af5a091098680ae2a26e0">&#9670;&nbsp;</a></span>createIntLookupTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_int_lookup_table_node.html">IntLookupTableNode</a> * Function::createIntLookupTable </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; int8_t &gt;&#160;</td>
          <td class="paramname"><em>initValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create lookup table for mapping between quantized numbers. <code>input</code> and <code>outTy</code> must have quantized type. Table contains all numbers from the quantized range, e.g., 256 entries for int8. Position 0 in the <code>initValues</code> corresponds to the -128 input number, position 255 to 127. </p>

</div>
</div>
<a id="a441d3bf4a13e444a8ddaa5e129e3acee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441d3bf4a13e444a8ddaa5e129e3acee">&#9670;&nbsp;</a></span>createIsNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_is_na_n_node.html">IsNaNNode</a> * Function::createIsNaN </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node that produces an boolean output of the same shape as <code>input</code> in which each element indicates whether or not the corresponding element in <code>input</code> is NaN or not. </p>

</div>
</div>
<a id="a0e83d1e9da4a42527cc13d24ac29c17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e83d1e9da4a42527cc13d24ac29c17b">&#9670;&nbsp;</a></span>createLengthsRangeFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_lengths_range_fill_node.html">LengthsRangeFillNode</a> * Function::createLengthsRangeFill </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>maxOutputSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector of <code>lengths</code>, </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_lengths_range_fill_node.html" title="Converts an input Lengths 1D vector into a range sequence. ">LengthsRangeFillNode</a>. This <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> calculates a range sequence given <code>lengths</code>, where the sum of the elements of <code>lengths</code> must be no greater than <code>maxOutputSize</code>, which is used to set the output type. </dd></dl>

</div>
</div>
<a id="a24bdca6a0b3ac6ba120f98b28440e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bdca6a0b3ac6ba120f98b28440e2bc">&#9670;&nbsp;</a></span>createLengthsSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_lengths_sum_node.html">LengthsSumNode</a> * Function::createLengthsSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements an operation that accumulates the values in <code>data</code> along the first dimension into len(<code>lengths</code>) entries by summing together the first lengths[0] values, then the subsequent lengths[1] values, etc. sum(<code>lengths</code>) must equal the first dimension of <code>data</code>. This operation is similar to SparseLengthsSum but the input is a dense represention instead of a sparse one. In other words, it has already been Gathered. </p>

</div>
</div>
<a id="a98924f81beee494322bc1cb8e7f5e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98924f81beee494322bc1cb8e7f5e5e7">&#9670;&nbsp;</a></span>createLengthsToRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_lengths_to_ranges_node.html">LengthsToRangesNode</a> * Function::createLengthsToRanges </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector of segment lengths, calculates offsets of each segment and packs them next to the lengths. For the input vector of length N the output is a Nx2 matrix with (offset, lengths) packaged for each segment. </p>

</div>
</div>
<a id="a4fd96b3007929f8a2c534e72311cd6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd96b3007929f8a2c534e72311cd6e8">&#9670;&nbsp;</a></span>createLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_log_node.html">LogNode</a> * Function::createLog </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Log node with <code>name</code>, which calculates element-wise natural log of <code>input</code>, with output type <code>outTy</code>. </p>

</div>
</div>
<a id="a81e3b70fd3322cc3ae6f733c7c818ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e3b70fd3322cc3ae6f733c7c818ff2">&#9670;&nbsp;</a></span>createLogit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createLogit </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a series of nodes with <code>name</code> that implements an element-wise logit transform. For each element of the <code>input</code> x, this is defined as:</p>
<p>y = log(x / (1 - x))</p>
<p>where the <code>input</code> is clamped in (<code>eps</code>, 1 - <code>eps</code>), and the transform parameter <code>eps</code> is a positive value (&lt; 0.5) (needed to avoid degenerate probabilities of 0 or 1, which would result in taking the logarithm of zero). The transform itself is implemented using element-wise Clip, Sub, Splat, Div, and Log nodes. </p><dl class="section return"><dt>Returns</dt><dd>the final node. </dd></dl>

</div>
</div>
<a id="a031dffcebc9798d481beaefaa927db61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031dffcebc9798d481beaefaa927db61">&#9670;&nbsp;</a></span>createLSTM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Function::createLSTM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>namePrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>hiddenSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>outputSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an unrolled single-layer LSTM cell with <code>hiddenSize</code> dimensionality of the hidden state and <code>outputSize</code> dimensionality of the output state. <code>inputs</code> define the input for the cell at each time step and the number of time steps is equal to the size of the <code>inputs</code>. The names of the created variables are prefixed by <code>namePrefix</code>. The output variables are written to <code>outputs</code>, they represent the activation of the output layer, unrolled over time. </p>

</div>
</div>
<a id="ae2629554747ce321d9ea9fc688ecde30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2629554747ce321d9ea9fc688ecde30">&#9670;&nbsp;</a></span>createModulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_modulo_node.html">ModuloNode</a> * Function::createModulo </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signFollowDivisor</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classglow_1_1_modulo_node.html" title="Performs elementwise modulo operation on the input where each element in the output is the correspond...">ModuloNode</a> which performs the modulo operation elementwise on the <code>input</code> such that each element in the output is equal to the corresponding element in the input modulo <code>divisor</code>. If <code>signFollowDivisor</code> is true then any negative elements in the output will have divisor added to their final values. </p>

</div>
</div>
<a id="ad8b34304a6130cd64289773e212dba8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b34304a6130cd64289773e212dba8b">&#9670;&nbsp;</a></span>createNodeWithBroadcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enable_if_same_t&lt;T, <a class="el" href="classglow_1_1_select_node.html">SelectNode</a>&gt;::type* glow::Function::createNodeWithBroadcast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>inputArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template function that creates a node and normalizes its input shapes with the use of BroadCast nodes. If axis is -1, it calculates it automatically for multi directional broadcast. Template function that creates a node and normalizes its input shapes with the use of BroadCast nodes. If axis is -1, it calculates it automatically for multi directional broadcast. </p>

</div>
</div>
<a id="a6b3c2945ca9381bc22dc01559dcdbbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3c2945ca9381bc22dc01559dcdbbe9">&#9670;&nbsp;</a></span>createNodeWithBroadcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enable_if_same_t&lt;T, <a class="el" href="classglow_1_1_cmp_l_t_node.html">CmpLTNode</a>&gt;::type* glow::Function::createNodeWithBroadcast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>inputArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template function that creates a node and normalizes its input shapes with the use of BroadCast nodes. If axis is -1, it calculates it automatically for multi directional broadcast. </p>

</div>
</div>
<a id="a128f705eed37efbbb40cc644c36dd16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128f705eed37efbbb40cc644c36dd16e">&#9670;&nbsp;</a></span>createPRELU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_p_relu_node.html">PReluNode</a> * Function::createPRELU </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>slope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a PReLU node with the given <code>name</code>, <code>input</code> and <code>slope</code>. Result type will be implicitly set based on the <code>input</code> type. </p>

</div>
</div>
<a id="a87131023c229abbfbc109c06485106a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87131023c229abbfbc109c06485106a7">&#9670;&nbsp;</a></span>createPRELU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_p_relu_node.html">PReluNode</a> * Function::createPRELU </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a PReLU node with the given <code>name</code>, <code>input</code>, <code>slope</code> and output type <code>outTy</code>. </p>

</div>
</div>
<a id="ae9866986d73736c124e1bfaf3222aa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9866986d73736c124e1bfaf3222aa13">&#9670;&nbsp;</a></span>createQuantizationProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_quantization_profile_node.html">QuantizationProfileNode</a> * Function::createQuantizationProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create quantization profile node named <code>name</code> for the output tensor from <code>input</code> in <a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> <code>bindings</code>. Capture observed node name in quantization profile node as original node can be replaced during lowering phase. </p>

</div>
</div>
<a id="a5137409e46739131c920052ea550b003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5137409e46739131c920052ea550b003">&#9670;&nbsp;</a></span>createQuantize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_quantize_node.html">QuantizeNode</a> * Function::createQuantize </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create quantization node which transforms floating point tensor to a quantized one with given Scale and Offset. Scale and Offset params are part of the <code>outTy</code>. </p>

</div>
</div>
<a id="ada1e5e0678dc0af5c17835ffea6c3367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1e5e0678dc0af5c17835ffea6c3367">&#9670;&nbsp;</a></span>createRELU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_relu_node.html">ReluNode</a> * Function::createRELU </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a ReLU node with the given <code>name</code> and <code>input</code>. Result type will be implicitly set based on the <code>input</code> type. </p>

</div>
</div>
<a id="a31145d8863286195749705d53a93b9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31145d8863286195749705d53a93b9b0">&#9670;&nbsp;</a></span>createRELU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_relu_node.html">ReluNode</a> * Function::createRELU </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a ReLU node with the given <code>name</code>, <code>input</code> and output type <code>outTy</code>. </p>

</div>
</div>
<a id="ad091697cc2cabe1ec8139eab16df6432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad091697cc2cabe1ec8139eab16df6432">&#9670;&nbsp;</a></span>createReplaceNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_replace_na_n_node.html">ReplaceNaNNode</a> * Function::createReplaceNaN </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classglow_1_1_replace_na_n_node.html" title="Replaces NaNs found in Input with Value. ">ReplaceNaNNode</a> given <code>name</code>, <code>input</code>, and <code>value</code>. </dd></dl>

</div>
</div>
<a id="acac964783c66b57eb30d0d643cf73026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac964783c66b57eb30d0d643cf73026">&#9670;&nbsp;</a></span>createRescaleQuantized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_rescale_quantized_node.html">RescaleQuantizedNode</a> * Function::createRescaleQuantized </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create transformation for quantized tensors to rescale based on the new Scale and Offset. </p>

</div>
</div>
<a id="a3e21b55f20e481869522d45d6856f8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e21b55f20e481869522d45d6856f8ae">&#9670;&nbsp;</a></span>createResizeNearest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_resize_nearest_node.html">ResizeNearestNode</a> * Function::createResizeNearest </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>heightScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>widthScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>input</code> tensor of [N,H,W,C], where N is the batch, C is the channel or depth, H is the height and W is the width, generates an Output tensor with resized spatial dimensions using nearest neighbor interpolation. The Output tensor is of shape [N, floor(H * <code>heightScale</code>), floor(W * <code>widthScale</code>), C] </p>

</div>
</div>
<a id="aa4b45584a08282fd6b027ce972c5f74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b45584a08282fd6b027ce972c5f74d">&#9670;&nbsp;</a></span>createRowwiseQuantizedFullyConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_rowwise_quantized_fully_connected_node.html">RowwiseQuantizedFullyConnectedNode</a> * Function::createRowwiseQuantizedFullyConnected </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quantization::Schema&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeWeight</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a row-wise quantized fully connected node. This node is only used in quantization. Args <code>input</code> and <code>B</code> are quantized in regular way, <code>W</code> is the constant weights and will be row-wise quantized during node creation time. The output is quantized in the regular way, and its type <code>outTy</code> is a quantized type. if <code>transposeWeight</code> is true, <code>W</code> need to be transposed first. </p>

</div>
</div>
<a id="a336683b0ec8e06e084caec12f60142fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336683b0ec8e06e084caec12f60142fd">&#9670;&nbsp;</a></span>createRowwiseQuantizedSparseLengthsSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> * Function::createRowwiseQuantizedSparseLengthsSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>scales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>ElemKind::FloatTy</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and </p><dl class="section return"><dt>Returns</dt><dd>a node of <code>name</code>, performing the SparseLengthsSum operation, using rowwise quantization for the input <code>data</code> with the <code>scales</code> and <code>offsets</code> as separate input tensors. Gathers slices of the outer-most dimension of data indexed by the <code>indices</code> vector, and then accumulates them into len(<code>lengths</code>) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). <code>precision</code> represents what precision to use for Scale, Offset, and Result. If <code>useFP16Accumulation</code>, then internal arithmetic will use FP16 accumulation; otherwise defaults to FP32. </dd></dl>

</div>
</div>
<a id="ae7977506330eaf13bc3c39d63d83c333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7977506330eaf13bc3c39d63d83c333">&#9670;&nbsp;</a></span>createRowwiseQuantizedSparseLengthsSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> * Function::createRowwiseQuantizedSparseLengthsSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quantization::Schema&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>ElemKind::FloatTy</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#a336683b0ec8e06e084caec12f60142fd">createRowwiseQuantizedSparseLengthsSum()</a>, but expects float input <code>data</code>, which is rowwise-quantized internally. </p>

</div>
</div>
<a id="ae17510e67747d910c5ba7999ff498ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17510e67747d910c5ba7999ff498ea5">&#9670;&nbsp;</a></span>createRowwiseQuantizedSparseLengthsWeightedSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> * Function::createRowwiseQuantizedSparseLengthsWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>scales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>ElemKind::FloatTy</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#a336683b0ec8e06e084caec12f60142fd">createRowwiseQuantizedSparseLengthsSum()</a>, but i-th slice is multiplied by weights[i]. len(weights) must be equal to len(indices). </p>

</div>
</div>
<a id="aae39e625ab8f247f03f7283dd7d0dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae39e625ab8f247f03f7283dd7d0dd80">&#9670;&nbsp;</a></span>createRowwiseQuantizedSparseLengthsWeightedSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html">RowwiseQuantizedSparseLengthsWeightedSumNode</a> * Function::createRowwiseQuantizedSparseLengthsWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quantization::Schema&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>ElemKind::FloatTy</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFP16Accumulation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#ae17510e67747d910c5ba7999ff498ea5">createRowwiseQuantizedSparseLengthsWeightedSum()</a>, but expects float input <code>data</code>, which is rowwise-quantized internally. </p>

</div>
</div>
<a id="acbe25057f5bb26ea1011b44b8815d6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe25057f5bb26ea1011b44b8815d6c9">&#9670;&nbsp;</a></span>createScatterData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_scatter_data_node.html">ScatterDataNode</a> * Function::createScatterData </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cumulative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies each slice from <code>slices</code> into <code>data</code> at the corresponding index in <code>indices</code>, and </p><dl class="section return"><dt>Returns</dt><dd>this new version of data. For example, given input data {{1,2},{3,4},{5,6}}, slices {{-3,-4}}, and indices {1}, the result is {{1,2},{-3,-4},{5,6}}. If <code>cumulative</code> is true, this node adds values instead of copying. </dd></dl>

</div>
</div>
<a id="a8e62024d3d2033210f189b8f0fb19b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e62024d3d2033210f189b8f0fb19b04">&#9670;&nbsp;</a></span>createSigmoid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sigmoid_node.html">SigmoidNode</a> * Function::createSigmoid </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Sigmoid node with the given <code>name</code>, <code>input</code> and output type <code>outTy</code>. </p>

</div>
</div>
<a id="a5493f61de698fa74ca152bbb52b212aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5493f61de698fa74ca152bbb52b212aa">&#9670;&nbsp;</a></span>createSigmoid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sigmoid_node.html">SigmoidNode</a> * Function::createSigmoid </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Sigmoid node with the given <code>name</code> and <code>input</code>. Result type will be implicitly set based on the <code>input</code> type. </p>

</div>
</div>
<a id="a5aa2b425049f5e2868062da4ca7c438e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa2b425049f5e2868062da4ca7c438e">&#9670;&nbsp;</a></span>createSimpleRNN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Function::createSimpleRNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_placeholder_bindings.html">PlaceholderBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>namePrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>hiddenSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>outputSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an unrolled single-layer Simple RNN cell with <code>hiddenSize</code> dimensionality of the hidden state and <code>outputSize</code> dimensionality of the output state. <code>inputs</code> define the input for the cell at each time step and the number of time steps is equal to the size of the <code>inputs</code>. The names of the created variables are prefixed by <code>namePrefix</code>. The output variables are written to <code>outputs</code>, they represent the activations of the output layer, unrolled over time. </p>

</div>
</div>
<a id="abdff3f5f232d5db7d7b7529516053964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdff3f5f232d5db7d7b7529516053964">&#9670;&nbsp;</a></span>createSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_slice_node.html">SliceNode</a> * Function::createSlice </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a slice node with the given starting point for each dimension. End points will be calculated based on the output type during execution. </p>

</div>
</div>
<a id="aad17e40fffb4fe287d329c74a32256ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad17e40fffb4fe287d329c74a32256ea">&#9670;&nbsp;</a></span>createSpaceToDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_space_to_depth_node.html">SpaceToDepthNode</a> * Function::createSpaceToDepth </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given Input tensor of [N,H,W,C], where N is the batch axis, H is the height, W is the width, C is the channel or depth. This produces Output tensor of [N, H/blockSize, W/blockSize, C * blockSize * blockSize]. </p>

</div>
</div>
<a id="a5dd07dd06c24d69113033f9ceb1135ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd07dd06c24d69113033f9ceb1135ed">&#9670;&nbsp;</a></span>createSparseLengthsSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sparse_lengths_sum_node.html">SparseLengthsSumNode</a> * Function::createSparseLengthsSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node, performing SparseLengthsSum operation: Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates them into len(Lengths) entries: first Lengths[0] slices are aggregated to Result[0], next Lengths[1] slices are aggregated to Result[1], etc. I.e. sum(Lengths) must be equal to len(Indices). </p>

</div>
</div>
<a id="a294f7aafb024ab39071832980f90fa8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294f7aafb024ab39071832980f90fa8d">&#9670;&nbsp;</a></span>createSparseLengthsWeightedSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_node.html">SparseLengthsWeightedSumNode</a> * Function::createSparseLengthsWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as SparseLengthsSum, but i-th slice is multiplied by weights[i]. len(weights) must be equal to len(indices). </p>

</div>
</div>
<a id="a1f195f77eb6fefdaac84ff2e1b887d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f195f77eb6fefdaac84ff2e1b887d75">&#9670;&nbsp;</a></span>createSparseLengthsWeightedSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sparse_lengths_weighted_sum_node.html">SparseLengthsWeightedSumNode</a> * Function::createSparseLengthsWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classglow_1_1_function.html#a294f7aafb024ab39071832980f90fa8d">createSparseLengthsWeightedSum()</a>, but with <code>outTy</code> specified. </p>

</div>
</div>
<a id="aa30faa862c948082d65911e42d9745e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30faa862c948082d65911e42d9745e3">&#9670;&nbsp;</a></span>createSparseToDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sparse_to_dense_node.html">SparseToDenseNode</a> * Function::createSparseToDense </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>dataToInferDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements an operation that converts the sparse representation given by the pair of <code>indices</code> and <code>values</code> into a dense representation. This representation contains each value of <code>values</code> at the corresponding index given by <code>indices</code>. All indices that are not present in <code>indices</code> are filled with zeroes. <code>indices</code> can contain duplicates, and in this case, the corresponding values in <code>values</code> are added.</p>
<p><code>dataToInferDim</code> acts as a hint about the shape of the output. The first dimension of the output is the first dimension of this tensor. </p>

</div>
</div>
<a id="a40c8dca4c538dfdf2d248bdb2c8d680a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c8dca4c538dfdf2d248bdb2c8d680a">&#9670;&nbsp;</a></span>createSparseToDenseMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_sparse_to_dense_mask_node.html">SparseToDenseMaskNode</a> * Function::createSparseToDenseMask </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements an operation that converts the sparse representation given by the pair of <code>indices</code> and <code>values</code> into a dense representation, which only contains IDs from given <code>mask</code>. Indices cannot contain duplicates. <code>lengths</code> is used to distinguish elements that belong to different examples of one batch. That is, first <code>lengths</code>[0] index-value pairs belong to batch's example 0, next <code>lengths</code>[1] pairs belong to example 1 and so on. </p>

</div>
</div>
<a id="a9f77fd01d257c12ce44d64ee25c9a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f77fd01d257c12ce44d64ee25c9a65f">&#9670;&nbsp;</a></span>createSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Function::createSplit </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>outputNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classglow_1_1_slice_node.html">SliceNode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create <code>outputNum</code> slice nodes of <code>input</code>. Slices happen along dimension number <code>axis</code>. Array <code>split</code> defines lengths of slices. If <code>split</code> is empty, <code>input</code> is split to equal sized parts. </p>

</div>
</div>
<a id="a5fa046629fa2f742a28a49966c67e947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa046629fa2f742a28a49966c67e947">&#9670;&nbsp;</a></span>createSqueeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_reshape_node.html">ReshapeNode</a> * Function::createSqueeze </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes single-dimensional entries from the shape of a tensor. The parameter <code>axes</code> is a list of positive integers, indicating the dimensions to squeeze. Impelmented as a single <a class="el" href="classglow_1_1_reshape_node.html" title="Reshape the Input tensor to shape Dims. ">ReshapeNode</a>. This is the opposite of ExpandDims. <a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#squeeze">https://github.com/onnx/onnx/blob/master/docs/Operators.md#squeeze</a> </p>

</div>
</div>
<a id="a859e8e441d4479750853cca69c357803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859e8e441d4479750853cca69c357803">&#9670;&nbsp;</a></span>createTanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tanh_node.html">TanhNode</a> * Function::createTanh </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Tanh node with the given <code>name</code>, <code>input</code> and output type <code>outTy</code>. </p>

</div>
</div>
<a id="a311e1981e013129cef4882a2598c36f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311e1981e013129cef4882a2598c36f4">&#9670;&nbsp;</a></span>createTanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tanh_node.html">TanhNode</a> * Function::createTanh </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Tanh node with the given <code>name</code> and <code>input</code>. Result type will be implicitly set based on the <code>input</code> type. </p>

</div>
</div>
<a id="aea101a646a4e71c0b513608587127217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea101a646a4e71c0b513608587127217">&#9670;&nbsp;</a></span>createTile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tile_node.html">TileNode</a> * Function::createTile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>tiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>outTy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a quantized <a class="el" href="classglow_1_1_tile_node.html" title="Tile an Input tensor Count times along Axis. ">TileNode</a> with <code>name</code>, <code>input</code>, <code>tiles</code>, and <code>axis</code>. For example, an input tensor {{1,2,3,4}} of dimension 1x4 with tiles = 2 and axis = 0 would result in an output tensor {{1,2,3,4}, {1,2,3,4}} of dimension 2x4. </p>

</div>
</div>
<a id="a85bff46320d22692796a98c44c785d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bff46320d22692796a98c44c785d36">&#9670;&nbsp;</a></span>createTraceEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_trace_event_node.html">TraceEventNode</a> * Function::createTraceEvent </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structglow_1_1_trace_event.html">TraceEvent</a> in the runtime profile, which triggers collection of runtime statistics. </p>

</div>
</div>
<a id="ab511da8a4555e0e9b7e62b2f378716c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab511da8a4555e0e9b7e62b2f378716c9">&#9670;&nbsp;</a></span>createWeightedSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::createWeightedSum </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &gt;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a series of nodes that implement a weighted sum. <code>data</code> and <code>weights</code> should have the same number of elements. The nodes in <code>weights</code> should all be of size 1. Each node d_i in <code>data</code> is element-wise multiplied by the corresponding weight value w_i found in <code>weights</code>, broadcasted to the same shape as d_i, and resulting in r_i. All r_i are element-wise summed, and the final add node in this sum is returned. </p>

</div>
</div>
<a id="a25f5f7d84157c8c3c20faeb82c083c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f5f7d84157c8c3c20faeb82c083c2d">&#9670;&nbsp;</a></span>dumpDAG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Function::dumpDAG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump a dotty graph that depicts the function into a file. </p><dl class="section return"><dt>Returns</dt><dd>full path to the file. </dd></dl>

</div>
</div>
<a id="a0668c5170eedf2b84a292367cfb4fbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0668c5170eedf2b84a292367cfb4fbac">&#9670;&nbsp;</a></span>findConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstList Function::findConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search the <a class="el" href="classglow_1_1_module.html">Module</a> containing the function to gather and return a list of constants that are used by the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. </p>

</div>
</div>
<a id="abc73d2632bdeaaa7a2ec029196608ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc73d2632bdeaaa7a2ec029196608ab7">&#9670;&nbsp;</a></span>findPlaceholders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlaceholderList Function::findPlaceholders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search the <a class="el" href="classglow_1_1_module.html">Module</a> containing the function to gather and return a list of placeholders that are used by the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. </p>

</div>
</div>
<a id="a26cfda31e823d1499173f1bd23f2d86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cfda31e823d1499173f1bd23f2d86c">&#9670;&nbsp;</a></span>getNodeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Function::getNodeByName </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a node with the name <code>name</code> or nullptr if no node was found. </dd></dl>

</div>
</div>
<a id="ad79bc51bcabb426b1f64e8a0700fba2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79bc51bcabb426b1f64e8a0700fba2d">&#9670;&nbsp;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#a4919b7ef01548e927f0a5acb3a7400b9">NodesList</a>&amp; glow::Function::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the list of nodes that the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a> owns. </dd></dl>

</div>
</div>
<a id="aa766431c358524e3dfeafc66d1cdcb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa766431c358524e3dfeafc66d1cdcb4f">&#9670;&nbsp;</a></span>getNodesMemberPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceglow.html#a4919b7ef01548e927f0a5acb3a7400b9">NodesList</a> Function::* glow::Function::getNodesMemberPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>pointer to the class member for the nodes list. </dd></dl>

</div>
</div>
<a id="ab1dabb8d94895004268410f672079f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dabb8d94895004268410f672079f1a">&#9670;&nbsp;</a></span>orderNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Function::orderNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform ordering of nodes_ based on node's name. This is to make sure that performing optimizations have a deterministic behavior on the graphs which have the same ops but different ordering in nodes_. </p>

</div>
</div>
<a id="a74703c0bb968ca968b65dbc20653940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74703c0bb968ca968b65dbc20653940c">&#9670;&nbsp;</a></span>takeOwnershipOfNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Function::takeOwnershipOfNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take ownership of <code>N</code> by removing it from its original <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>, add it to the current <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>, and also unique its name. </p>

</div>
</div>
<a id="a73897a61138cf69eacb41357839815df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73897a61138cf69eacb41357839815df">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Function::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify the correctness of the <a class="el" href="classglow_1_1_function.html" title="Represents the compute graph. ">Function</a>. </p><dl class="section return"><dt>Returns</dt><dd>true when the function is valid. False otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/glow/Graph/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>lib/Graph/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
