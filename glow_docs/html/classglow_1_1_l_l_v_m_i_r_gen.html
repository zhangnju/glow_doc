<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow::LLVMIRGen Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglow.html">glow</a></li><li class="navelem"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html">LLVMIRGen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classglow_1_1_l_l_v_m_i_r_gen-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">glow::LLVMIRGen Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_l_l_v_m_i_r_gen_8h_source.html">LLVMIRGen.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for glow::LLVMIRGen:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classglow_1_1_l_l_v_m_i_r_gen.png" usemap="#glow::LLVMIRGen_map" alt=""/>
  <map id="glow::LLVMIRGen_map" name="glow::LLVMIRGen_map">
<area href="classglow_1_1_c_p_u_l_l_v_m_i_r_gen.html" alt="glow::CPULLVMIRGen" shape="rect" coords="0,56,137,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe35676f1aeccb43fddc4b01585f372d"><td class="memItemLeft" align="right" valign="top"><a id="abe35676f1aeccb43fddc4b01585f372d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#abe35676f1aeccb43fddc4b01585f372d">~LLVMIRGen</a> ()</td></tr>
<tr class="memdesc:abe35676f1aeccb43fddc4b01585f372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:abe35676f1aeccb43fddc4b01585f372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfb6f7f1baf45078e1686d0c0530fef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a9bfb6f7f1baf45078e1686d0c0530fef">LLVMIRGen</a> (const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> *M, <a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a> &amp;allocationsInfo, std::string mainEntryName, llvm::StringRef libjitBC)</td></tr>
<tr class="separator:a9bfb6f7f1baf45078e1686d0c0530fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712d537a8810928bb5b6836a3e1b36f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a712d537a8810928bb5b6836a3e1b36f6">initTargetMachine</a> (llvm::StringRef target, llvm::StringRef arch, llvm::StringRef cpu, const llvm::SmallVectorImpl&lt; std::string &gt; &amp;targetFeatures, llvm::CodeModel::Model CM, llvm::Reloc::Model relocModel)</td></tr>
<tr class="separator:a712d537a8810928bb5b6836a3e1b36f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36e4f70a5e436f3b29e54303ad1401"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a8b36e4f70a5e436f3b29e54303ad1401">generateLLVMIRForInstr</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *I)</td></tr>
<tr class="separator:a8b36e4f70a5e436f3b29e54303ad1401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa96711f023e2256bd0264508c9d093"><td class="memItemLeft" align="right" valign="top"><a id="a0aa96711f023e2256bd0264508c9d093"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a0aa96711f023e2256bd0264508c9d093">generateLLVMIRForModule</a> (llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a0aa96711f023e2256bd0264508c9d093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit LLVM-IR for the whole <a class="el" href="classglow_1_1_i_r_function.html" title="A function that represents the compilation unit. ">IRFunction</a>. <br /></td></tr>
<tr class="separator:a0aa96711f023e2256bd0264508c9d093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ce9483d4fc06df377217a0e7c4c855"><td class="memItemLeft" align="right" valign="top">virtual llvm::CallInst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a01ce9483d4fc06df377217a0e7c4c855">createCall</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::Function *callee, llvm::ArrayRef&lt; llvm::Value *&gt; args)</td></tr>
<tr class="separator:a01ce9483d4fc06df377217a0e7c4c855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573dc0804d60a5a7211f11f5d9e9b7b1"><td class="memItemLeft" align="right" valign="top">virtual llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a573dc0804d60a5a7211f11f5d9e9b7b1">getFunction</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a573dc0804d60a5a7211f11f5d9e9b7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b34709fef04c6318ce086e2128ccb7"><td class="memItemLeft" align="right" valign="top">virtual llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ad7b34709fef04c6318ce086e2128ccb7">getFunction</a> (const std::string &amp;name, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">glow::ElemKind</a> elemTy)</td></tr>
<tr class="separator:ad7b34709fef04c6318ce086e2128ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044469a2bbd62d2ce24c1da0fce621a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a044469a2bbd62d2ce24c1da0fce621a2">optimizeLLVMModule</a> (llvm::Module *M, llvm::TargetMachine &amp;TM)</td></tr>
<tr class="separator:a044469a2bbd62d2ce24c1da0fce621a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9021a869c4d7d8d79089d947c898cae5"><td class="memItemLeft" align="right" valign="top"><a id="a9021a869c4d7d8d79089d947c898cae5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a9021a869c4d7d8d79089d947c898cae5">performSpecialization</a> ()</td></tr>
<tr class="memdesc:a9021a869c4d7d8d79089d947c898cae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs specialization of operations based on constant parameters. <br /></td></tr>
<tr class="separator:a9021a869c4d7d8d79089d947c898cae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493cc6f5ebe4fae57ccce7c7bec07ead"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a493cc6f5ebe4fae57ccce7c7bec07ead">getAllocationsInfo</a> ()</td></tr>
<tr class="separator:a493cc6f5ebe4fae57ccce7c7bec07ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b7ebc89eb4f9ff63466c190ac6935"><td class="memItemLeft" align="right" valign="top">llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ad98b7ebc89eb4f9ff63466c190ac6935">getBundleName</a> () const</td></tr>
<tr class="separator:ad98b7ebc89eb4f9ff63466c190ac6935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1129e6ac613511aa059b44b83026a831"><td class="memItemLeft" align="right" valign="top"><a id="a1129e6ac613511aa059b44b83026a831"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a1129e6ac613511aa059b44b83026a831">setBundleName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a1129e6ac613511aa059b44b83026a831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the bundle. <br /></td></tr>
<tr class="separator:a1129e6ac613511aa059b44b83026a831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d552d8a207ea84b2e1c24585646df74"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a7d552d8a207ea84b2e1c24585646df74">getMainEntryName</a> () const</td></tr>
<tr class="separator:a7d552d8a207ea84b2e1c24585646df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4007c0b6dffa3ea7ab30c859ad0e72"><td class="memItemLeft" align="right" valign="top"><a id="a8a4007c0b6dffa3ea7ab30c859ad0e72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a8a4007c0b6dffa3ea7ab30c859ad0e72">setMainEntryName</a> (std::string name)</td></tr>
<tr class="memdesc:a8a4007c0b6dffa3ea7ab30c859ad0e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the main entry point. <br /></td></tr>
<tr class="separator:a8a4007c0b6dffa3ea7ab30c859ad0e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3fef79f9e5fbb73ee60dc0f674a72"><td class="memItemLeft" align="right" valign="top"><a id="ae6c3fef79f9e5fbb73ee60dc0f674a72"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ae6c3fef79f9e5fbb73ee60dc0f674a72">initCodeGen</a> ()</td></tr>
<tr class="memdesc:ae6c3fef79f9e5fbb73ee60dc0f674a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an LLVM module, the entry function, etc. <br /></td></tr>
<tr class="separator:ae6c3fef79f9e5fbb73ee60dc0f674a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae535df4df4e4181344a7be894cfdb5d9"><td class="memItemLeft" align="right" valign="top"><a id="ae535df4df4e4181344a7be894cfdb5d9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ae535df4df4e4181344a7be894cfdb5d9">performCodeGen</a> ()</td></tr>
<tr class="memdesc:ae535df4df4e4181344a7be894cfdb5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the code of the entry function, performs optimizations, etc. <br /></td></tr>
<tr class="separator:ae535df4df4e4181344a7be894cfdb5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa6667b0dbd8911e385ceff4af57799"><td class="memItemLeft" align="right" valign="top">llvm::IRBuilder &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a9aa6667b0dbd8911e385ceff4af57799">getBuilder</a> ()</td></tr>
<tr class="separator:a9aa6667b0dbd8911e385ceff4af57799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b7ddfbe2a68673d396ab06b10baf0e"><td class="memItemLeft" align="right" valign="top">llvm::TargetMachine &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a36b7ddfbe2a68673d396ab06b10baf0e">getTargetMachine</a> ()</td></tr>
<tr class="separator:a36b7ddfbe2a68673d396ab06b10baf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0810110612b078218a35bb4673c99"><td class="memItemLeft" align="right" valign="top">llvm::LLVMContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a07a0810110612b078218a35bb4673c99">getLLVMContext</a> ()</td></tr>
<tr class="separator:a07a0810110612b078218a35bb4673c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5019f4a96a599dac11b3d8eb2886a26"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#aa5019f4a96a599dac11b3d8eb2886a26">borrowModule</a> ()</td></tr>
<tr class="separator:aa5019f4a96a599dac11b3d8eb2886a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7e8150f5ab8f631a26711c39d00a3d"><td class="memItemLeft" align="right" valign="top">llvm::Module &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a2d7e8150f5ab8f631a26711c39d00a3d">getModule</a> () const</td></tr>
<tr class="separator:a2d7e8150f5ab8f631a26711c39d00a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe99ac3179cc752f0d1acbad9676213e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#afe99ac3179cc752f0d1acbad9676213e">getIRFunction</a> ()</td></tr>
<tr class="separator:afe99ac3179cc752f0d1acbad9676213e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be8ef572613c2d6d0acbc30a41439e"><td class="memItemLeft" align="right" valign="top"><a id="af9be8ef572613c2d6d0acbc30a41439e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#af9be8ef572613c2d6d0acbc30a41439e">setOutputDir</a> (llvm::StringRef outputDir)</td></tr>
<tr class="memdesc:af9be8ef572613c2d6d0acbc30a41439e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output directory for bundles, debug info files, etc. <br /></td></tr>
<tr class="separator:af9be8ef572613c2d6d0acbc30a41439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81843ca4f785f138b7d88b35a9e7df61"><td class="memItemLeft" align="right" valign="top"><a id="a81843ca4f785f138b7d88b35a9e7df61"></a>
llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a81843ca4f785f138b7d88b35a9e7df61">getOutputDir</a> () const</td></tr>
<tr class="memdesc:a81843ca4f785f138b7d88b35a9e7df61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output directory for bundles, debug info files, etc. <br /></td></tr>
<tr class="separator:a81843ca4f785f138b7d88b35a9e7df61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99d4cedbf1aedd16201a3f0c00af3a6"><td class="memItemLeft" align="right" valign="top"><a id="ae99d4cedbf1aedd16201a3f0c00af3a6"></a>
virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ae99d4cedbf1aedd16201a3f0c00af3a6">emitConstOffsetsArray</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a> &amp;allocationsInfo)</td></tr>
<tr class="memdesc:ae99d4cedbf1aedd16201a3f0c00af3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the array of constant offsets as provided by the <code>allocationsInfo</code>. <br /></td></tr>
<tr class="separator:ae99d4cedbf1aedd16201a3f0c00af3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b59669dd5d26b9f937b3f57727d7f62"><td class="memItemLeft" align="right" valign="top"><a id="a0b59669dd5d26b9f937b3f57727d7f62"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a0b59669dd5d26b9f937b3f57727d7f62">generateFunctionDebugInfo</a> (llvm::Function *F)</td></tr>
<tr class="memdesc:a0b59669dd5d26b9f937b3f57727d7f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate debug info for a LLVM function <code>F</code>. <br /></td></tr>
<tr class="separator:a0b59669dd5d26b9f937b3f57727d7f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb32e0e9805be98150fab0a83b61940"><td class="memItemLeft" align="right" valign="top"><a id="a3fb32e0e9805be98150fab0a83b61940"></a>
virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a3fb32e0e9805be98150fab0a83b61940">emitStringConst</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::StringRef str)</td></tr>
<tr class="memdesc:a3fb32e0e9805be98150fab0a83b61940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates LLVM IR that materializes the string literal <code>str</code>. <br /></td></tr>
<tr class="separator:a3fb32e0e9805be98150fab0a83b61940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd37d8ea2cc36dec91b7dfd9d3783fe"><td class="memItemLeft" align="right" valign="top"><a id="affd37d8ea2cc36dec91b7dfd9d3783fe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#affd37d8ea2cc36dec91b7dfd9d3783fe">markArgAsUnspecialized</a> (llvm::Value *val)</td></tr>
<tr class="memdesc:affd37d8ea2cc36dec91b7dfd9d3783fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register <code>val</code> as an argument that should not be specialized. <br /></td></tr>
<tr class="separator:affd37d8ea2cc36dec91b7dfd9d3783fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd22a5eea9925c89897a8a24b747dec"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a6dd22a5eea9925c89897a8a24b747dec">getTargetSizeTWidth</a> () const</td></tr>
<tr class="separator:a6dd22a5eea9925c89897a8a24b747dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c45ee294639713b1eaefe4092576e2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#aa6c45ee294639713b1eaefe4092576e2">getLibjitSizeTWidth</a> () const</td></tr>
<tr class="separator:aa6c45ee294639713b1eaefe4092576e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4377d61d03f0de9c285cf9b0448e8b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a6d4377d61d03f0de9c285cf9b0448e8b">isEligibleForSpecialization</a> (const llvm::CallInst *call)</td></tr>
<tr class="separator:a6d4377d61d03f0de9c285cf9b0448e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5884c76fb5620ed1955a9846bf9b82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a1d5884c76fb5620ed1955a9846bf9b82">preserveSymbol</a> (const llvm::GlobalValue &amp;GV)</td></tr>
<tr class="separator:a1d5884c76fb5620ed1955a9846bf9b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b41c0403ef1ff77626f35c5d4590118"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a7b41c0403ef1ff77626f35c5d4590118">canBePartOfDataParallelKernel</a> (const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *I) const</td></tr>
<tr class="separator:a7b41c0403ef1ff77626f35c5d4590118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8f1f6b6418b0be48fbd933fe48491c2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a8f1f6b6418b0be48fbd933fe48491c2d">emitDataParallelKernelImpl</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::ArrayRef&lt; const <a class="el" href="classglow_1_1_instruction.html">Instruction</a> *&gt; bundle, llvm::ArrayRef&lt; llvm::Type *&gt; argTypes, llvm::DenseMap&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, int &gt; &amp;bufferToArgNum, llvm::ArrayRef&lt; llvm::Value *&gt; buffers)</td></tr>
<tr class="separator:a8f1f6b6418b0be48fbd933fe48491c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78febfedef59f2e4dd47c4e8f7f11962"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a78febfedef59f2e4dd47c4e8f7f11962">emitValueAddress</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_value.html">glow::Value</a> *val)</td></tr>
<tr class="separator:a78febfedef59f2e4dd47c4e8f7f11962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99532ebebe16fe197d589073d07c4c92"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a99532ebebe16fe197d589073d07c4c92">emitBufferAddress</a> (llvm::IRBuilder&lt;&gt; &amp;builder, <a class="el" href="classglow_1_1_value.html">Value</a> *val, llvm::Function *kernel, llvm::DenseMap&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, int &gt; &amp;bufferToArgNum)</td></tr>
<tr class="separator:a99532ebebe16fe197d589073d07c4c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267fccf16ace7e109c96839e27112db1"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a267fccf16ace7e109c96839e27112db1">emitValueSize</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_value.html">glow::Value</a> *val)</td></tr>
<tr class="separator:a267fccf16ace7e109c96839e27112db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c68d41607fb828c4718a3a4d3b9985c"><td class="memItemLeft" align="right" valign="top"><a id="a5c68d41607fb828c4718a3a4d3b9985c"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a5c68d41607fb828c4718a3a4d3b9985c">emitConstF32</a> (llvm::IRBuilder&lt;&gt; &amp;builder, float val)</td></tr>
<tr class="memdesc:a5c68d41607fb828c4718a3a4d3b9985c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates LLVM IR that materializes the constant <code>val</code>. <br /></td></tr>
<tr class="separator:a5c68d41607fb828c4718a3a4d3b9985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c170328a8dfc86b1db19b1698bea839"><td class="memItemLeft" align="right" valign="top"><a id="a5c170328a8dfc86b1db19b1698bea839"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a5c170328a8dfc86b1db19b1698bea839">emitConstI32</a> (llvm::IRBuilder&lt;&gt; &amp;builder, int32_t val)</td></tr>
<tr class="memdesc:a5c170328a8dfc86b1db19b1698bea839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates LLVM IR that materializes the constant <code>val</code>. <br /></td></tr>
<tr class="separator:a5c170328a8dfc86b1db19b1698bea839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcbdda1374355bd0341b24e702cab68"><td class="memItemLeft" align="right" valign="top"><a id="a2dcbdda1374355bd0341b24e702cab68"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a2dcbdda1374355bd0341b24e702cab68">emitConstI8</a> (llvm::IRBuilder&lt;&gt; &amp;builder, int8_t val)</td></tr>
<tr class="memdesc:a2dcbdda1374355bd0341b24e702cab68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates LLVM IR that materializes the constant <code>val</code>. <br /></td></tr>
<tr class="separator:a2dcbdda1374355bd0341b24e702cab68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616c59309bbe6426ee5c6efccac9c1c8"><td class="memItemLeft" align="right" valign="top"><a id="a616c59309bbe6426ee5c6efccac9c1c8"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a616c59309bbe6426ee5c6efccac9c1c8">emitConstI1</a> (llvm::IRBuilder&lt;&gt; &amp;builder, bool val)</td></tr>
<tr class="memdesc:a616c59309bbe6426ee5c6efccac9c1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates LLVM IR that materializes the constant <code>val</code>. <br /></td></tr>
<tr class="separator:a616c59309bbe6426ee5c6efccac9c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c89455b1c7f932fd0c30d2a5ceb5e3"><td class="memItemLeft" align="right" valign="top"><a id="a21c89455b1c7f932fd0c30d2a5ceb5e3"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a21c89455b1c7f932fd0c30d2a5ceb5e3">emitConstSizeT</a> (llvm::IRBuilder&lt;&gt; &amp;builder, size_t val)</td></tr>
<tr class="memdesc:a21c89455b1c7f932fd0c30d2a5ceb5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates LLVM IR that materializes the constant <code>val</code>. <br /></td></tr>
<tr class="separator:a21c89455b1c7f932fd0c30d2a5ceb5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9058e2b14efacc79c28c71c74027e91b"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a9058e2b14efacc79c28c71c74027e91b">emitConst</a> (llvm::IRBuilder&lt;&gt; &amp;builder, float val, <a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">glow::ElemKind</a> kind)</td></tr>
<tr class="separator:a9058e2b14efacc79c28c71c74027e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada77060511b9c2cb322c04f88b414626"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada77060511b9c2cb322c04f88b414626"><td class="memTemplItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ada77060511b9c2cb322c04f88b414626">emitConstSizeTArray</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::ArrayRef&lt; T &gt; vals)</td></tr>
<tr class="separator:ada77060511b9c2cb322c04f88b414626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48cd5bfd5d480f9f3d29b399132b8a5"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ab48cd5bfd5d480f9f3d29b399132b8a5">emitConstArray</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::ArrayRef&lt; llvm::Constant *&gt; vals, llvm::Type *elemTy)</td></tr>
<tr class="separator:ab48cd5bfd5d480f9f3d29b399132b8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f4e8b52d60ed9688c2fbfbd233ee93"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a48f4e8b52d60ed9688c2fbfbd233ee93">emitValueDims</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_value.html">glow::Value</a> *val)</td></tr>
<tr class="separator:a48f4e8b52d60ed9688c2fbfbd233ee93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f23be02496680d03496b598c653c49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ac5f23be02496680d03496b598c653c49">loadBaseAddresses</a> (llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="separator:ac5f23be02496680d03496b598c653c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c55abb7ab22bd32aee5d3472606475"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ae8c55abb7ab22bd32aee5d3472606475">emitDataParallelKernel</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::ArrayRef&lt; const <a class="el" href="classglow_1_1_instruction.html">Instruction</a> *&gt; stackedInstrs)</td></tr>
<tr class="separator:ae8c55abb7ab22bd32aee5d3472606475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638e1a6f88ef525a57fa03c7c0cae7cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a638e1a6f88ef525a57fa03c7c0cae7cc">generateLLVMIRForDataParallelInstr</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *I, llvm::Function *kernel, llvm::DenseMap&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, int &gt; &amp;bufferToArgNum, llvm::Value *loopCount)</td></tr>
<tr class="separator:a638e1a6f88ef525a57fa03c7c0cae7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4632479e0de5211cbb0131c232e9b014"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a4632479e0de5211cbb0131c232e9b014">getElementType</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_value.html">Value</a> *val)</td></tr>
<tr class="separator:a4632479e0de5211cbb0131c232e9b014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6363384b6ce32e716b773fa5bb6e748d"><td class="memItemLeft" align="right" valign="top"><a id="a6363384b6ce32e716b773fa5bb6e748d"></a>
llvm::DIType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a6363384b6ce32e716b773fa5bb6e748d">getDebugType</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::Type *ty)</td></tr>
<tr class="memdesc:a6363384b6ce32e716b773fa5bb6e748d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a debug information for a given LLVM type <code>ty</code>. <br /></td></tr>
<tr class="separator:a6363384b6ce32e716b773fa5bb6e748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335637a14e9b5a71196b26eec696e000"><td class="memItemLeft" align="right" valign="top"><a id="a335637a14e9b5a71196b26eec696e000"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a335637a14e9b5a71196b26eec696e000">initDebugInfo</a> ()</td></tr>
<tr class="memdesc:a335637a14e9b5a71196b26eec696e000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the generation of debug information. <br /></td></tr>
<tr class="separator:a335637a14e9b5a71196b26eec696e000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145218c1ebef2593a5bf5e59b1630e04"><td class="memItemLeft" align="right" valign="top"><a id="a145218c1ebef2593a5bf5e59b1630e04"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a145218c1ebef2593a5bf5e59b1630e04">generateDebugInfo</a> ()</td></tr>
<tr class="memdesc:a145218c1ebef2593a5bf5e59b1630e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate debug information. <br /></td></tr>
<tr class="separator:a145218c1ebef2593a5bf5e59b1630e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fa2e2bb6dc70638fb8cbbec579feef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#af5fa2e2bb6dc70638fb8cbbec579feef">setCurrentDebugLocation</a> (llvm::IRBuilder&lt;&gt; &amp;builder, const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *I)</td></tr>
<tr class="separator:af5fa2e2bb6dc70638fb8cbbec579feef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9164764d6962ad3009ab2f8187ad315e"><td class="memItemLeft" align="right" valign="top"><a id="a9164764d6962ad3009ab2f8187ad315e"></a>
llvm::DISubprogram *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a9164764d6962ad3009ab2f8187ad315e">getOrCreateFunctionDebugInfo</a> (llvm::Function *F, llvm::DIScope *scope, llvm::DIFile *file, unsigned lineNo)</td></tr>
<tr class="memdesc:a9164764d6962ad3009ab2f8187ad315e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a debug information for a given LLVM function. <br /></td></tr>
<tr class="separator:a9164764d6962ad3009ab2f8187ad315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3caa35da86a7dbe2e02c35ee4f55e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#af3caa35da86a7dbe2e02c35ee4f55e77">emitDebugGlobalVariableForValue</a> (const <a class="el" href="classglow_1_1_value.html">Value</a> *val)</td></tr>
<tr class="separator:af3caa35da86a7dbe2e02c35ee4f55e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdcfdb9538be24c455b90f3855b0f93"><td class="memItemLeft" align="right" valign="top">std::pair&lt; llvm::BasicBlock *, llvm::BasicBlock * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#aacdcfdb9538be24c455b90f3855b0f93">createLoop</a> (llvm::IRBuilder&lt;&gt; &amp;builder, llvm::LLVMContext &amp;ctx, llvm::Value *numElements) const</td></tr>
<tr class="separator:aacdcfdb9538be24c455b90f3855b0f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a547b5f799b99850e524343291109ce9e"><td class="memItemLeft" align="right" valign="top"><a id="a547b5f799b99850e524343291109ce9e"></a>
const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a547b5f799b99850e524343291109ce9e">F_</a></td></tr>
<tr class="memdesc:a547b5f799b99850e524343291109ce9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IR to generate code for. <br /></td></tr>
<tr class="separator:a547b5f799b99850e524343291109ce9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46408754b14d6dbd25bb4a907c357d90"><td class="memItemLeft" align="right" valign="top"><a id="a46408754b14d6dbd25bb4a907c357d90"></a>
llvm::LLVMContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a46408754b14d6dbd25bb4a907c357d90">ctx_</a></td></tr>
<tr class="memdesc:a46408754b14d6dbd25bb4a907c357d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LLVM context. <br /></td></tr>
<tr class="separator:a46408754b14d6dbd25bb4a907c357d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae752832d01214abc7e30a8e43901952a"><td class="memItemLeft" align="right" valign="top"><a id="ae752832d01214abc7e30a8e43901952a"></a>
std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#ae752832d01214abc7e30a8e43901952a">llmodule_</a> {nullptr}</td></tr>
<tr class="memdesc:ae752832d01214abc7e30a8e43901952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LLVM IR module. <br /></td></tr>
<tr class="separator:ae752832d01214abc7e30a8e43901952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b144416b9efb55ab1921850c0d2a187"><td class="memItemLeft" align="right" valign="top"><a id="a8b144416b9efb55ab1921850c0d2a187"></a>
std::unique_ptr&lt; llvm::TargetMachine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a8b144416b9efb55ab1921850c0d2a187">TM_</a></td></tr>
<tr class="memdesc:a8b144416b9efb55ab1921850c0d2a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target machine. <br /></td></tr>
<tr class="separator:a8b144416b9efb55ab1921850c0d2a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdc48bcce7fee3857a461cea91d0743"><td class="memItemLeft" align="right" valign="top"><a id="a2bdc48bcce7fee3857a461cea91d0743"></a>
<a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a2bdc48bcce7fee3857a461cea91d0743">allocationsInfo_</a></td></tr>
<tr class="memdesc:a2bdc48bcce7fee3857a461cea91d0743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about allocations. <br /></td></tr>
<tr class="separator:a2bdc48bcce7fee3857a461cea91d0743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddc5bbe3db35bbfb9e32b942e46fcbb"><td class="memItemLeft" align="right" valign="top"><a id="aaddc5bbe3db35bbfb9e32b942e46fcbb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#aaddc5bbe3db35bbfb9e32b942e46fcbb">bundleName_</a></td></tr>
<tr class="memdesc:aaddc5bbe3db35bbfb9e32b942e46fcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the bundle. <br /></td></tr>
<tr class="separator:aaddc5bbe3db35bbfb9e32b942e46fcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686251b0e29406c6dde7e9e75a30b473"><td class="memItemLeft" align="right" valign="top"><a id="a686251b0e29406c6dde7e9e75a30b473"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a686251b0e29406c6dde7e9e75a30b473">mainEntryName_</a></td></tr>
<tr class="memdesc:a686251b0e29406c6dde7e9e75a30b473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the main entry. <br /></td></tr>
<tr class="separator:a686251b0e29406c6dde7e9e75a30b473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f512b8b99eb0c98509f95da66c65f30"><td class="memItemLeft" align="right" valign="top"><a id="a9f512b8b99eb0c98509f95da66c65f30"></a>
std::unique_ptr&lt; <a class="el" href="classglow_1_1_instruction_numbering.html">InstructionNumbering</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a9f512b8b99eb0c98509f95da66c65f30">instrNumbering_</a></td></tr>
<tr class="memdesc:a9f512b8b99eb0c98509f95da66c65f30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_instruction.html" title="This represents an instruction in our IR. ">Instruction</a> number for the module. <br /></td></tr>
<tr class="separator:a9f512b8b99eb0c98509f95da66c65f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f7aad6b5cbcae0f9dcf0f45ad75b63"><td class="memItemLeft" align="right" valign="top"><a id="aa7f7aad6b5cbcae0f9dcf0f45ad75b63"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#aa7f7aad6b5cbcae0f9dcf0f45ad75b63">baseActivationsAddr_</a> {nullptr}</td></tr>
<tr class="memdesc:aa7f7aad6b5cbcae0f9dcf0f45ad75b63"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_value.html">Value</a> holding the base address of the activations memory area. <br /></td></tr>
<tr class="separator:aa7f7aad6b5cbcae0f9dcf0f45ad75b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8bdf672c68d37cb51f6453d4bd499d"><td class="memItemLeft" align="right" valign="top"><a id="a3a8bdf672c68d37cb51f6453d4bd499d"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a3a8bdf672c68d37cb51f6453d4bd499d">baseConstantWeightVarsAddr_</a> {nullptr}</td></tr>
<tr class="memdesc:a3a8bdf672c68d37cb51f6453d4bd499d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_value.html">Value</a> holding the base address of the constant WeightVars memory area. <br /></td></tr>
<tr class="separator:a3a8bdf672c68d37cb51f6453d4bd499d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dabbdec1164fe59ab4e2855765066ff"><td class="memItemLeft" align="right" valign="top"><a id="a8dabbdec1164fe59ab4e2855765066ff"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a8dabbdec1164fe59ab4e2855765066ff">baseMutableWeightVarsAddr_</a> {nullptr}</td></tr>
<tr class="memdesc:a8dabbdec1164fe59ab4e2855765066ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_value.html">Value</a> holding the base address of mutable WeightVars memory area. <br /></td></tr>
<tr class="separator:a8dabbdec1164fe59ab4e2855765066ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdc9c17fb19d9693593b32bd5685004"><td class="memItemLeft" align="right" valign="top"><a id="a5bdc9c17fb19d9693593b32bd5685004"></a>
llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a5bdc9c17fb19d9693593b32bd5685004">offsetsArray_</a> {nullptr}</td></tr>
<tr class="memdesc:a5bdc9c17fb19d9693593b32bd5685004"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classglow_1_1_value.html">Value</a> holding the address of the offsets array. <br /></td></tr>
<tr class="separator:a5bdc9c17fb19d9693593b32bd5685004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5a95f9c36d016cd02c6c1e5872117"><td class="memItemLeft" align="right" valign="top">llvm::DenseMap&lt; llvm::Constant *, llvm::Value * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a19a5a95f9c36d016cd02c6c1e5872117">constArrayPtrs_</a></td></tr>
<tr class="separator:a19a5a95f9c36d016cd02c6c1e5872117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1408eac0eb3af218c2bdc2bd031876ec"><td class="memItemLeft" align="right" valign="top"><a id="a1408eac0eb3af218c2bdc2bd031876ec"></a>
std::unique_ptr&lt; llvm::IRBuilder&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a1408eac0eb3af218c2bdc2bd031876ec">builder_</a></td></tr>
<tr class="memdesc:a1408eac0eb3af218c2bdc2bd031876ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classglow_1_1_i_r_builder.html" title="The IRBuilder constructs the IR in the function. ">IRBuilder</a> used for the code generation. <br /></td></tr>
<tr class="separator:a1408eac0eb3af218c2bdc2bd031876ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547bb83a1485059e2084493bd191c12c"><td class="memItemLeft" align="right" valign="top"><a id="a547bb83a1485059e2084493bd191c12c"></a>
llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a547bb83a1485059e2084493bd191c12c">outputDir_</a></td></tr>
<tr class="memdesc:a547bb83a1485059e2084493bd191c12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output directory for bundles, debug info files, etc. <br /></td></tr>
<tr class="separator:a547bb83a1485059e2084493bd191c12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa951b795aa652fd59f7cf00150bef465"><td class="memItemLeft" align="right" valign="top"><a id="aa951b795aa652fd59f7cf00150bef465"></a>
<a class="el" href="structglow_1_1_debug_info.html">DebugInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#aa951b795aa652fd59f7cf00150bef465">dbgInfo_</a></td></tr>
<tr class="memdesc:aa951b795aa652fd59f7cf00150bef465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug info emission support. <br /></td></tr>
<tr class="separator:aa951b795aa652fd59f7cf00150bef465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4c6e477a326a2e9dc7018448e90764"><td class="memItemLeft" align="right" valign="top"><a id="a6f4c6e477a326a2e9dc7018448e90764"></a>
std::unique_ptr&lt; llvm::DIBuilder &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a6f4c6e477a326a2e9dc7018448e90764">DIBuilder_</a></td></tr>
<tr class="memdesc:a6f4c6e477a326a2e9dc7018448e90764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug info builder. <br /></td></tr>
<tr class="separator:a6f4c6e477a326a2e9dc7018448e90764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de29181c696a6c08cf26614ac84e1ba"><td class="memItemLeft" align="right" valign="top">llvm::DenseSet&lt; llvm::Value * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a7de29181c696a6c08cf26614ac84e1ba">dontSpecializeArgsSet_</a></td></tr>
<tr class="separator:a7de29181c696a6c08cf26614ac84e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c519495ca16ec3f09a25e267e624a"><td class="memItemLeft" align="right" valign="top">llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html#a851c519495ca16ec3f09a25e267e624a">libjitBC_</a></td></tr>
<tr class="separator:a851c519495ca16ec3f09a25e267e624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a class containing a common logic for the generation of the LLVM IR from an <a class="el" href="classglow_1_1_i_r_function.html" title="A function that represents the compilation unit. ">IRFunction</a>. The primary clients of this class are JITs and bundlers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bfb6f7f1baf45078e1686d0c0530fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfb6f7f1baf45078e1686d0c0530fef">&#9670;&nbsp;</a></span>LLVMIRGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVMIRGen::LLVMIRGen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>allocationsInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>mainEntryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>libjitBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ctor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td><a class="el" href="classglow_1_1_i_r_function.html" title="A function that represents the compilation unit. ">IRFunction</a> to be converted into LLVM IR. </td></tr>
    <tr><td class="paramname">allocationsInfo</td><td>information about allocation of weights and activations. </td></tr>
    <tr><td class="paramname">mainEntryName</td><td>Name of the main entry. </td></tr>
    <tr><td class="paramname">libjitBC</td><td>bitcode of the backend's libjit library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5019f4a96a599dac11b3d8eb2886a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5019f4a96a599dac11b3d8eb2886a26">&#9670;&nbsp;</a></span>borrowModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; glow::LLVMIRGen::borrowModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Borrows the LLVM module for further processing, e.g. by a JIT. The module cannot be used by the <a class="el" href="classglow_1_1_l_l_v_m_i_r_gen.html">LLVMIRGen</a> afterwards. </p>

</div>
</div>
<a id="a7b41c0403ef1ff77626f35c5d4590118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b41c0403ef1ff77626f35c5d4590118">&#9670;&nbsp;</a></span>canBePartOfDataParallelKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMIRGen::canBePartOfDataParallelKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if an instruction <code>I</code> can be part of a data parallel kernel. This gives backends a possibility to provide a custom logic to decide on a per-instruction basis what can be part of data parallel kernels. Typically an instruction which is isDataParallel() can be part of a data parallel kernel. But a backend may decide that a specific instruction <code>I</code> cannot be part of data-parallel kernels, because there is no support for this functionality in this backend yet. </dd></dl>

</div>
</div>
<a id="a01ce9483d4fc06df377217a0e7c4c855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ce9483d4fc06df377217a0e7c4c855">&#9670;&nbsp;</a></span>createCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::CallInst * LLVMIRGen::createCall </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Value *&gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to create a new CallInst, with the specified <code>builder</code>, <code>callee</code>, and <code>args</code>. Verifies that the function signature is correct, and then creates and </p><dl class="section return"><dt>Returns</dt><dd>the CallInst. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td>the IR builder to be used for creating the Call instruction. </td></tr>
    <tr><td class="paramname">callee</td><td>the function to be called. </td></tr>
    <tr><td class="paramname">args</td><td>arguments to be passed in this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generated Call instruction </dd></dl>

</div>
</div>
<a id="aacdcfdb9538be24c455b90f3855b0f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdcfdb9538be24c455b90f3855b0f93">&#9670;&nbsp;</a></span>createLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; llvm::BasicBlock *, llvm::BasicBlock * &gt; LLVMIRGen::createLoop </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create LLVM IR for the for loop with a loop count specified by the only parameter of the enclosing function. </p><dl class="section return"><dt>Returns</dt><dd>a pair of basic blocks. The first BB is the BB of the loop body, the second BB is the loop exit BB. </dd></dl>

</div>
</div>
<a id="a99532ebebe16fe197d589073d07c4c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99532ebebe16fe197d589073d07c4c92">&#9670;&nbsp;</a></span>emitBufferAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitBufferAddress </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::DenseMap&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferToArgNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit the address of the buffer <code>v</code> inside a data-parallel kernel <code>kernel</code> using the mapping provided by <code>bufferToArgNum</code>. </p>

</div>
</div>
<a id="a9058e2b14efacc79c28c71c74027e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9058e2b14efacc79c28c71c74027e91b">&#9670;&nbsp;</a></span>emitConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitConst </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">glow::ElemKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates LLVM IR that materializes the constant <code>val</code> as a constant of the type specified by <code>kind</code>. </p>

</div>
</div>
<a id="ab48cd5bfd5d480f9f3d29b399132b8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48cd5bfd5d480f9f3d29b399132b8a5">&#9670;&nbsp;</a></span>emitConstArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitConstArray </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Constant *&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>elemTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates LLVM IR that materializes the constant array <code>vals</code>. Elements of vals have the type <code>elemTy</code>. </p>

</div>
</div>
<a id="ada77060511b9c2cb322c04f88b414626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada77060511b9c2cb322c04f88b414626">&#9670;&nbsp;</a></span>emitConstSizeTArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitConstSizeTArray </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates LLVM IR that materializes the constant array <code>vals</code>. Note that it will cast non-size_t types T into size_t. </p>

</div>
</div>
<a id="ae8c55abb7ab22bd32aee5d3472606475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c55abb7ab22bd32aee5d3472606475">&#9670;&nbsp;</a></span>emitDataParallelKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::emitDataParallelKernel </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; const <a class="el" href="classglow_1_1_instruction.html">Instruction</a> *&gt;&#160;</td>
          <td class="paramname"><em>bundle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a function representing a stacked kernel for instructions provided in <code>stackedInstrs</code>.</p>
<p>Emit the function that implements a data-parallel kernel and calls it.</p>
<p>The generated kernel functions get buffers as their parameters. The buffers are uniqued, so that any buffer is passed as argument to the kernel function only once. This allows us to mark all parameters of the generated kernel as noalias. As a result, the LLVM optimizer makes use of the noalias attributes and produces nicely vectorized code for the generated data-parallel kernels. Note that we will emit a kernel whenever the number of arguments (aka unique buffers) exceeds <code>kArgLimit</code>. </p>

</div>
</div>
<a id="a8f1f6b6418b0be48fbd933fe48491c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1f6b6418b0be48fbd933fe48491c2d">&#9670;&nbsp;</a></span>emitDataParallelKernelImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::emitDataParallelKernelImpl </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; const <a class="el" href="classglow_1_1_instruction.html">Instruction</a> *&gt;&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Type *&gt;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::DenseMap&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferToArgNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Value *&gt;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of emitDataParallelKernel where we bound the number of inputs to 64. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classglow_1_1_i_r_builder.html" title="The IRBuilder constructs the IR in the function. ">IRBuilder</a> to be used for the LLVM IR code emission. </td></tr>
    <tr><td class="paramname">bundle</td><td>set of instructions to be emitted as a data-parallel kernel. </td></tr>
    <tr><td class="paramname">argType</td><td>types of arguments for the data-parallel kernel. </td></tr>
    <tr><td class="paramname">bufferToArgNum</td><td>mapping from a buffer to its argument number in the data-parallel kernel. </td></tr>
    <tr><td class="paramname">buffers</td><td>buffers used by the data-parallel kernel.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementation of emitDataParallelKernel where we guarantee that the number of arguments will be bound by 64. </p>

</div>
</div>
<a id="af3caa35da86a7dbe2e02c35ee4f55e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3caa35da86a7dbe2e02c35ee4f55e77">&#9670;&nbsp;</a></span>emitDebugGlobalVariableForValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::emitDebugGlobalVariableForValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit a debug info for the logical global variable representing a weight or an activation described by <code>val</code>. This allows for inspecting the values of weights and activations when using a debugger. Logical global variables are not materialized and do not require any additional memory to be reserved or allocated. Instead, they reside at offsets described by <a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a> inside the memory blocks dynamically allocated by clients for weights and activations, but behave like regular global variables from the debugger's perspective. </p>

</div>
</div>
<a id="a78febfedef59f2e4dd47c4e8f7f11962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78febfedef59f2e4dd47c4e8f7f11962">&#9670;&nbsp;</a></span>emitValueAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitValueAddress </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_value.html">glow::Value</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates LLVM IR that computes the address of <code>val</code> using <code>builder</code>. The address type is specified by <code>ptrTy</code>. </p>

</div>
</div>
<a id="a48f4e8b52d60ed9688c2fbfbd233ee93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f4e8b52d60ed9688c2fbfbd233ee93">&#9670;&nbsp;</a></span>emitValueDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitValueDims </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_value.html">glow::Value</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates LLVM IR that computes the dimensions of <code>val</code> using <code>builder</code>. The result type is "size_t*". </p>

</div>
</div>
<a id="a267fccf16ace7e109c96839e27112db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267fccf16ace7e109c96839e27112db1">&#9670;&nbsp;</a></span>emitValueSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * LLVMIRGen::emitValueSize </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_value.html">glow::Value</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates LLVM IR that computes the size of the tensor of <code>val</code> using <code>builder</code>. The size type is native to the machine (size_t). </p>

</div>
</div>
<a id="a638e1a6f88ef525a57fa03c7c0cae7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638e1a6f88ef525a57fa03c7c0cae7cc">&#9670;&nbsp;</a></span>generateLLVMIRForDataParallelInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::generateLLVMIRForDataParallelInstr </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::DenseMap&lt; <a class="el" href="classglow_1_1_value.html">Value</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferToArgNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>loopCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit IR for the data parallel instruction <code>I</code> which is invoked inside the stacked <code>kernel</code>. The current loop count is described by <code>loopCount</code>. The <code>bufferToArgNum</code> map can be used to find the required buffers, which are provided as arguments to the stacked <code>kernel</code>. Derived classes may want to override this function to implement a backend-specific LLVM IR generation logic for some intructions. </p>

<p>Reimplemented in <a class="el" href="classglow_1_1_c_p_u_l_l_v_m_i_r_gen.html#adbc69b398e182458dc67c93c3357b606">glow::CPULLVMIRGen</a>.</p>

</div>
</div>
<a id="a8b36e4f70a5e436f3b29e54303ad1401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b36e4f70a5e436f3b29e54303ad1401">&#9670;&nbsp;</a></span>generateLLVMIRForInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::generateLLVMIRForInstr </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit LLVM-IR for the instruction <code>I</code>, using the builder <code>builder</code>. Derived classes may want to override this function to implement a backend-specific LLVM IR generation logic for some intructions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classglow_1_1_i_r_builder.html" title="The IRBuilder constructs the IR in the function. ">IRBuilder</a> to be used to emit LLVM IR code. </td></tr>
    <tr><td class="paramname">I</td><td>IR instruction which should be compiled into LLVM IR. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classglow_1_1_c_p_u_l_l_v_m_i_r_gen.html#a396fcac8c5710b807e7fd670c33cd4bb">glow::CPULLVMIRGen</a>.</p>

</div>
</div>
<a id="a493cc6f5ebe4fae57ccce7c7bec07ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493cc6f5ebe4fae57ccce7c7bec07ead">&#9670;&nbsp;</a></span>getAllocationsInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structglow_1_1_allocations_info.html">AllocationsInfo</a>&amp; glow::LLVMIRGen::getAllocationsInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>allocations info. </dd></dl>

</div>
</div>
<a id="a9aa6667b0dbd8911e385ceff4af57799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa6667b0dbd8911e385ceff4af57799">&#9670;&nbsp;</a></span>getBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::IRBuilder&amp; glow::LLVMIRGen::getBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current builder. </dd></dl>

</div>
</div>
<a id="ad98b7ebc89eb4f9ff63466c190ac6935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b7ebc89eb4f9ff63466c190ac6935">&#9670;&nbsp;</a></span>getBundleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StringRef LLVMIRGen::getBundleName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of the bundle, to be used for filename when saving. </dd></dl>

</div>
</div>
<a id="a4632479e0de5211cbb0131c232e9b014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4632479e0de5211cbb0131c232e9b014">&#9670;&nbsp;</a></span>getElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * LLVMIRGen::getElementType </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the llvm type of the glow vale <code>val</code>.</dd>
<dd>
the LLVM type corresponding to the type of elements stored in <code>val</code>. </dd></dl>

</div>
</div>
<a id="a573dc0804d60a5a7211f11f5d9e9b7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573dc0804d60a5a7211f11f5d9e9b7b1">&#9670;&nbsp;</a></span>getFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * LLVMIRGen::getFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a libjit API function by name. </dd></dl>

</div>
</div>
<a id="ad7b34709fef04c6318ce086e2128ccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b34709fef04c6318ce086e2128ccb7">&#9670;&nbsp;</a></span>getFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * LLVMIRGen::getFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">glow::ElemKind</a>&#160;</td>
          <td class="paramname"><em>elemTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a libjit API function by name and tensor element type. </dd></dl>

</div>
</div>
<a id="afe99ac3179cc752f0d1acbad9676213e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe99ac3179cc752f0d1acbad9676213e">&#9670;&nbsp;</a></span>getIRFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglow_1_1_i_r_function.html">IRFunction</a>* glow::LLVMIRGen::getIRFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the IR function. </dd></dl>

</div>
</div>
<a id="aa6c45ee294639713b1eaefe4092576e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c45ee294639713b1eaefe4092576e2">&#9670;&nbsp;</a></span>getLibjitSizeTWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMIRGen::getLibjitSizeTWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sizeof(size_t) of the actual target-specific size_t type that was used to compile libjit into LLVM bitcode. </dd></dl>

</div>
</div>
<a id="a07a0810110612b078218a35bb4673c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0810110612b078218a35bb4673c99">&#9670;&nbsp;</a></span>getLLVMContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::LLVMContext&amp; glow::LLVMIRGen::getLLVMContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the LLVMContext being used. </dd></dl>

</div>
</div>
<a id="a7d552d8a207ea84b2e1c24585646df74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d552d8a207ea84b2e1c24585646df74">&#9670;&nbsp;</a></span>getMainEntryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LLVMIRGen::getMainEntryName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of the main entry point. When JITting, it will be "main". In case of bundling it will be the name of the bundle. </dd></dl>

</div>
</div>
<a id="a2d7e8150f5ab8f631a26711c39d00a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7e8150f5ab8f631a26711c39d00a3d">&#9670;&nbsp;</a></span>getModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module&amp; glow::LLVMIRGen::getModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current LLVM module. </dd></dl>

</div>
</div>
<a id="a36b7ddfbe2a68673d396ab06b10baf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b7ddfbe2a68673d396ab06b10baf0e">&#9670;&nbsp;</a></span>getTargetMachine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TargetMachine&amp; glow::LLVMIRGen::getTargetMachine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the target machine description. </dd></dl>

</div>
</div>
<a id="a6dd22a5eea9925c89897a8a24b747dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd22a5eea9925c89897a8a24b747dec">&#9670;&nbsp;</a></span>getTargetSizeTWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMIRGen::getTargetSizeTWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>bit-width of the target size_t. </dd></dl>

</div>
</div>
<a id="a712d537a8810928bb5b6836a3e1b36f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712d537a8810928bb5b6836a3e1b36f6">&#9670;&nbsp;</a></span>initTargetMachine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::initTargetMachine </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>arch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallVectorImpl&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetFeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::CodeModel::Model&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Reloc::Model&#160;</td>
          <td class="paramname"><em>relocModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Init the TargetMachine using a given <code>target</code>, <code>arch</code>, <code>cpu</code>, <code>targetFeatures</code> and code model. </p>

</div>
</div>
<a id="a6d4377d61d03f0de9c285cf9b0448e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4377d61d03f0de9c285cf9b0448e8b">&#9670;&nbsp;</a></span>isEligibleForSpecialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMIRGen::isEligibleForSpecialization </td>
          <td>(</td>
          <td class="paramtype">const llvm::CallInst *&#160;</td>
          <td class="paramname"><em>call</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if a call is eligible for specialization. </dd></dl>

</div>
</div>
<a id="ac5f23be02496680d03496b598c653c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f23be02496680d03496b598c653c49">&#9670;&nbsp;</a></span>loadBaseAddresses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::loadBaseAddresses </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load base addresses of different memory areas (activations, const weightvars, mutable weight vars) so that they can be reused inside the body of the function.</p>
<p>Load base addresses of different memory areas so that they can be easily reused during codegen. </p>

</div>
</div>
<a id="a044469a2bbd62d2ce24c1da0fce621a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044469a2bbd62d2ce24c1da0fce621a2">&#9670;&nbsp;</a></span>optimizeLLVMModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::optimizeLLVMModule </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetMachine &amp;&#160;</td>
          <td class="paramname"><em>TM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimize the function <code>F</code> and the module that owns it. <a class="el" href="structglow_1_1_use.html">Use</a> the target information from the <code>TM</code> target machine. </p>

</div>
</div>
<a id="a1d5884c76fb5620ed1955a9846bf9b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5884c76fb5620ed1955a9846bf9b82">&#9670;&nbsp;</a></span>preserveSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMIRGen::preserveSymbol </td>
          <td>(</td>
          <td class="paramtype">const llvm::GlobalValue &amp;&#160;</td>
          <td class="paramname"><em>GV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if a global symbol <code>GV</code> needs to be preserved in the module and not interalized during optimizations. </dd></dl>

</div>
</div>
<a id="af5fa2e2bb6dc70638fb8cbbec579feef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fa2e2bb6dc70638fb8cbbec579feef">&#9670;&nbsp;</a></span>setCurrentDebugLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMIRGen::setCurrentDebugLocation </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_instruction.html">glow::Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the debug location for the <code>builder</code>, so that it corresponds to the instruction <code>I</code> in the textual representation of the Glow IR. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a19a5a95f9c36d016cd02c6c1e5872117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a5a95f9c36d016cd02c6c1e5872117">&#9670;&nbsp;</a></span>constArrayPtrs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DenseMap&lt;llvm::Constant *, llvm::Value *&gt; glow::LLVMIRGen::constArrayPtrs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps constant arrays to the constant expressions representing size_t pointers to these arrays. This is done to ensure the proper uniqueness semantics of such pointers just like it is done for llvm::Constants. </p>

</div>
</div>
<a id="a7de29181c696a6c08cf26614ac84e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de29181c696a6c08cf26614ac84e1ba">&#9670;&nbsp;</a></span>dontSpecializeArgsSet_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DenseSet&lt;llvm::Value *&gt; glow::LLVMIRGen::dontSpecializeArgsSet_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A set that contains all of the argument that we request from the specializer not to specialize. </p>

</div>
</div>
<a id="a851c519495ca16ec3f09a25e267e624a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851c519495ca16ec3f09a25e267e624a">&#9670;&nbsp;</a></span>libjitBC_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StringRef glow::LLVMIRGen::libjitBC_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitcode of the libjit. Containts the starting address and the length of the bitcode. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/glow/LLVMIRCodeGen/<a class="el" href="_l_l_v_m_i_r_gen_8h_source.html">LLVMIRGen.h</a></li>
<li>lib/LLVMIRCodeGen/DebugInfo.cpp</li>
<li>lib/LLVMIRCodeGen/FunctionSpecializer.cpp</li>
<li>lib/LLVMIRCodeGen/LLVMIRGen.cpp</li>
<li>lib/LLVMIRCodeGen/Pipeline.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
