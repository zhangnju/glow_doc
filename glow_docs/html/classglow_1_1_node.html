<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglow.html">glow</a></li><li class="navelem"><a class="el" href="classglow_1_1_node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classglow_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">glow::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a node in the compute graph.  
 <a href="classglow_1_1_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_node_8h_source.html">Node.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for glow::Node:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classglow_1_1_node.png" usemap="#glow::Node_map" alt=""/>
  <map id="glow::Node_map" name="glow::Node_map">
<area href="classglow_1_1_named.html" title="This add the capability to name subclasses. " alt="glow::Named" shape="rect" coords="0,0,375,24"/>
<area href="classglow_1_1_kinded.html" title="Subclasses of Value have an enum that describe their kind. " alt="glow::Kinded" shape="rect" coords="385,0,760,24"/>
<area href="classglow_1_1_use_def.html" alt="glow::UseDef&lt; Node, NodeUse &gt;" shape="rect" coords="770,0,1145,24"/>
<area href="classglow_1_1_adaptive_avg_pool_grad_node.html" alt="glow::AdaptiveAvgPoolGradNode" shape="rect" coords="962,112,1337,136"/>
<area href="classglow_1_1_adaptive_avg_pool_node.html" title="Performs an Adaptive Average Pool operation on the Input given. " alt="glow::AdaptiveAvgPoolNode" shape="rect" coords="962,168,1337,192"/>
<area href="classglow_1_1_add_grad_node.html" alt="glow::AddGradNode" shape="rect" coords="962,224,1337,248"/>
<area href="classglow_1_1_add_node.html" title="Performs Add on the LHS and RHS operands. " alt="glow::AddNode" shape="rect" coords="962,280,1337,304"/>
<area href="classglow_1_1_arg_max_node.html" title="Finds index of a maximum element along Axis.If KeepDims is not true, the axis is removed from output..." alt="glow::ArgMaxNode" shape="rect" coords="962,336,1337,360"/>
<area href="classglow_1_1_avg_pool_grad_node.html" alt="glow::AvgPoolGradNode" shape="rect" coords="962,392,1337,416"/>
<area href="classglow_1_1_avg_pool_node.html" title="Performs an Average Pool operation on the Input given provided Kernels, Strides, and Pads..." alt="glow::AvgPoolNode" shape="rect" coords="962,448,1337,472"/>
<area href="classglow_1_1_batch_box_cox_node.html" title="Apply box-cox transform for each column for each column in NxD input tensor. " alt="glow::BatchBoxCoxNode" shape="rect" coords="962,504,1337,528"/>
<area href="classglow_1_1_batched_add_node.html" title="Adds the &#39;Slice&#39; operand to each one of the slices in the batch. " alt="glow::BatchedAddNode" shape="rect" coords="962,560,1337,584"/>
<area href="classglow_1_1_batched_reduce_add_node.html" title="Accumulates all of the layers in the batch and produce a tensor that has the same dimensions as the i..." alt="glow::BatchedReduceAddNode" shape="rect" coords="962,616,1337,640"/>
<area href="classglow_1_1_batched_reduce_mean_node.html" title="Performs Average Mean operation on the Input given Axes. " alt="glow::BatchedReduceMeanNode" shape="rect" coords="962,672,1337,696"/>
<area href="classglow_1_1_batched_reduce_min_node.html" title="Performs Reduce Min operation on the Input given Axes. " alt="glow::BatchedReduceMinNode" shape="rect" coords="962,728,1337,752"/>
<area href="classglow_1_1_batch_mat_mul_node.html" title="Performs batch matrix multiplication between the LHS and RHS. The operands are a stack of two dimensi..." alt="glow::BatchMatMulNode" shape="rect" coords="962,784,1337,808"/>
<area href="classglow_1_1_batch_normalization_grad_node.html" alt="glow::BatchNormalizationGradNode" shape="rect" coords="962,840,1337,864"/>
<area href="classglow_1_1_batch_normalization_node.html" title="Performs batch normalization on the Input tensor with the provided Scale, Bias, Mean, Var, ChannelIdx, Epsilon, and Momentum. Similar to Caffe2 SpatialBN, and ONNX BatchNormalization operator. " alt="glow::BatchNormalizationNode" shape="rect" coords="962,896,1337,920"/>
<area href="classglow_1_1_batch_one_hot_node.html" title="Expands each row of the Data to a row of zeros and ones, according to One Hot Encoding. i-th element of Result&#39;s row is one iff Values[i] equals to the corresponding element of Data. " alt="glow::BatchOneHotNode" shape="rect" coords="962,952,1337,976"/>
<area href="classglow_1_1_bucketize_node.html" title="Performs bucketization on the input given Boundaries. " alt="glow::BucketizeNode" shape="rect" coords="962,1008,1337,1032"/>
<area href="classglow_1_1_channel_shuffle_node.html" title="Performs Channel shuffle. " alt="glow::ChannelShuffleNode" shape="rect" coords="962,1064,1337,1088"/>
<area href="classglow_1_1_channelwise_quantized_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels..." alt="glow::ChannelwiseQuantizedConvolutionNode" shape="rect" coords="962,1120,1337,1144"/>
<area href="classglow_1_1_clip_node.html" title="Clip range of inputs to lie in [Min, Max]. " alt="glow::ClipNode" shape="rect" coords="962,1176,1337,1200"/>
<area href="classglow_1_1_cmp_e_q_node.html" title="Performs an element-wise equal comparison on the LHS and RHS operands. Inputs must be integer..." alt="glow::CmpEQNode" shape="rect" coords="962,1232,1337,1256"/>
<area href="classglow_1_1_cmp_l_t_e_node.html" title="Performs CmpLTE on the LHS and RHS operands. Generates a mask that&#39;s consumed by the select instructi..." alt="glow::CmpLTENode" shape="rect" coords="962,1288,1337,1312"/>
<area href="classglow_1_1_cmp_l_t_node.html" title="Compares X and Y element wise sets Dest[i] true if LHS[i] &lt; RHS[i] otherwise false. Final result is a mask consumed by Select, ONNX Where, operator. " alt="glow::CmpLTNode" shape="rect" coords="962,1344,1337,1368"/>
<area href="classglow_1_1_concat_node.html" alt="glow::ConcatNode" shape="rect" coords="962,1400,1337,1424"/>
<area href="classglow_1_1_convert_to_node.html" title="Convert the input from its current type to the destination type. The input and output types must have..." alt="glow::ConvertToNode" shape="rect" coords="962,1456,1337,1480"/>
<area href="classglow_1_1_convolution3_d_grad_node.html" alt="glow::Convolution3DGradNode" shape="rect" coords="962,1512,1337,1536"/>
<area href="classglow_1_1_convolution3_d_node.html" title="Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels..." alt="glow::Convolution3DNode" shape="rect" coords="962,1568,1337,1592"/>
<area href="classglow_1_1_convolution_grad_node.html" alt="glow::ConvolutionGradNode" shape="rect" coords="962,1624,1337,1648"/>
<area href="classglow_1_1_convolution_node.html" title="Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels..." alt="glow::ConvolutionNode" shape="rect" coords="962,1680,1337,1704"/>
<area href="classglow_1_1_c_p_u_conv_d_k_k_c8_node.html" title="This is a cpu-specific convolution implementation where the filter is transposed to the shape [D/8..." alt="glow::CPUConvDKKC8Node" shape="rect" coords="962,1736,1337,1760"/>
<area href="classglow_1_1_c_p_u_max_splat_node.html" title="A Max node with one splat input; CPU specific. " alt="glow::CPUMaxSplatNode" shape="rect" coords="962,1792,1337,1816"/>
<area href="classglow_1_1_cross_entropy_loss_grad_node.html" alt="glow::CrossEntropyLossGradNode" shape="rect" coords="962,1848,1337,1872"/>
<area href="classglow_1_1_cross_entropy_loss_node.html" title="Computes the average cross entropy loss of the input. " alt="glow::CrossEntropyLossNode" shape="rect" coords="962,1904,1337,1928"/>
<area href="classglow_1_1_dequantize_node.html" title="Convert quantized input tensor into the float representation. x = Scale * (x_q - Offset). " alt="glow::DequantizeNode" shape="rect" coords="962,1960,1337,1984"/>
<area href="classglow_1_1_div_grad_node.html" alt="glow::DivGradNode" shape="rect" coords="962,2016,1337,2040"/>
<area href="classglow_1_1_div_node.html" title="Performs Div on the LHS and RHS operands. " alt="glow::DivNode" shape="rect" coords="962,2072,1337,2096"/>
<area href="classglow_1_1_exp_node.html" title="Performs element-wise exponential to the Input. " alt="glow::ExpNode" shape="rect" coords="962,2128,1337,2152"/>
<area href="classglow_1_1_fully_connected_grad_node.html" alt="glow::FullyConnectedGradNode" shape="rect" coords="962,2184,1337,2208"/>
<area href="classglow_1_1_fully_connected_node.html" title="Creates a FullyConnected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output. " alt="glow::FullyConnectedNode" shape="rect" coords="962,2240,1337,2264"/>
<area href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node.html" title="Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates th..." alt="glow::FusedRowwiseQuantizedSparseLengthsSumNode" shape="rect" coords="962,2296,1337,2320"/>
<area href="classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node.html" title="Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates th..." alt="glow::FusedRowwiseQuantizedSparseLengthsWeightedSumNode" shape="rect" coords="962,2352,1337,2376"/>
<area href="classglow_1_1_gather_node.html" title="Gathers entries of the outer-most dimension of Data indexed by Indices, and concatenates them..." alt="glow::GatherNode" shape="rect" coords="962,2408,1337,2432"/>
<area href="classglow_1_1_gather_ranges_node.html" title="Gathers entries of Data into Output in groups specified by the elements of Ranges. Each element of Ranges contains a list of pairs of indices of the form (index, length) which specify which entries of data to gather. The ordering of elements in Ranges and of pairs within an element is preserved in Output. Lengths contains the lengths of the ranges gathered by each list of pairs in Ranges. " alt="glow::GatherRangesNode" shape="rect" coords="962,2464,1337,2488"/>
<area href="classglow_1_1_insert_tensor_node.html" title="Insert tensor Small into tensor Big given indices Start. Small is inserted Count times along Axis..." alt="glow::InsertTensorNode" shape="rect" coords="962,2520,1337,2544"/>
<area href="classglow_1_1_int_lookup_table_node.html" title="Simple mapping between quantized numbers.This can be used as quantized sigmoid or tanh functions..." alt="glow::IntLookupTableNode" shape="rect" coords="962,2576,1337,2600"/>
<area href="classglow_1_1_is_na_n_node.html" title="Determines whether each element of the Input is NaN and generates a mask that can be consumed by a Se..." alt="glow::IsNaNNode" shape="rect" coords="962,2632,1337,2656"/>
<area href="classglow_1_1_lengths_range_fill_node.html" title="Converts an input Lengths 1D vector into a range sequence. " alt="glow::LengthsRangeFillNode" shape="rect" coords="962,2688,1337,2712"/>
<area href="classglow_1_1_lengths_sum_node.html" title="Sums slices of the outermost dimension of Data in groups defined by Lengths. The first Lengths[0] sli..." alt="glow::LengthsSumNode" shape="rect" coords="962,2744,1337,2768"/>
<area href="classglow_1_1_lengths_to_ranges_node.html" title="Given a vector of segment lengths, calculates offsets of each segment and packs them next to the leng..." alt="glow::LengthsToRangesNode" shape="rect" coords="962,2800,1337,2824"/>
<area href="classglow_1_1_local_response_normalization_grad_node.html" alt="glow::LocalResponseNormalizationGradNode" shape="rect" coords="962,2856,1337,2880"/>
<area href="classglow_1_1_local_response_normalization_node.html" title="Performs local response normalization on the Input tensor with the provided Scale, Bias, Mean, Var, ChannelIdx, Epsilon, and Momentum. Similar to Caffe2 and ONNX LRN. " alt="glow::LocalResponseNormalizationNode" shape="rect" coords="962,2912,1337,2936"/>
<area href="classglow_1_1_log_node.html" title="Performs element-wise natural log to the Input. " alt="glow::LogNode" shape="rect" coords="962,2968,1337,2992"/>
<area href="classglow_1_1_mat_mul_node.html" title="Performs matrix multiplication between the LHS and RHS.Example: (A, Z) x (Z, B) =&gt; (A..." alt="glow::MatMulNode" shape="rect" coords="962,3024,1337,3048"/>
<area href="classglow_1_1_max_node.html" title="Performs Max on the LHS and RHS operands. " alt="glow::MaxNode" shape="rect" coords="962,3080,1337,3104"/>
<area href="classglow_1_1_max_pool_grad_node.html" alt="glow::MaxPoolGradNode" shape="rect" coords="962,3136,1337,3160"/>
<area href="classglow_1_1_max_pool_node.html" title="Performs a Max Pool with Argmax operation on the Input given provided Kernels, Strides, and Pads. Argmax is a flattened index corresponding to respective max element. Supported layouts are defined in the ConvolutionLayout enum: NHWC and NCHW. " alt="glow::MaxPoolNode" shape="rect" coords="962,3192,1337,3216"/>
<area href="classglow_1_1_mean_var_normalization_node.html" title="Calculates new normalized mean and variance based on the input mean, variance, and input..." alt="glow::MeanVarNormalizationNode" shape="rect" coords="962,3248,1337,3272"/>
<area href="classglow_1_1_min_node.html" title="Performs Min on the LHS and RHS operands. " alt="glow::MinNode" shape="rect" coords="962,3304,1337,3328"/>
<area href="classglow_1_1_modulo_node.html" title="Performs elementwise modulo operation on the input where each element in the output is the correspond..." alt="glow::ModuloNode" shape="rect" coords="962,3360,1337,3384"/>
<area href="classglow_1_1_mul_grad_node.html" alt="glow::MulGradNode" shape="rect" coords="962,3416,1337,3440"/>
<area href="classglow_1_1_mul_node.html" title="Performs Mul on the LHS and RHS operands. " alt="glow::MulNode" shape="rect" coords="962,3472,1337,3496"/>
<area href="classglow_1_1_pad_node.html" title="Performs padding of a given input tensor. The Padding information must be specified for each dimensio..." alt="glow::PadNode" shape="rect" coords="962,3528,1337,3552"/>
<area href="classglow_1_1_pow_node.html" title="Performs elementwise pow(LHS, RHS). " alt="glow::PowNode" shape="rect" coords="962,3584,1337,3608"/>
<area href="classglow_1_1_p_relu_node.html" title="Applies PReLU, slope * min(0, x) + max(0, x), to each element in the Input tensor. " alt="glow::PReluNode" shape="rect" coords="962,3640,1337,3664"/>
<area href="classglow_1_1_quantization_profile_node.html" title="Generate profile (distribution of values) of the Input tensor. This data is used for quantization of ..." alt="glow::QuantizationProfileNode" shape="rect" coords="962,3696,1337,3720"/>
<area href="classglow_1_1_quantize_node.html" title="Quantize floating point tensor. This operation converts floating point numbers to integers based on t..." alt="glow::QuantizeNode" shape="rect" coords="962,3752,1337,3776"/>
<area href="classglow_1_1_regression_grad_node.html" alt="glow::RegressionGradNode" shape="rect" coords="962,3808,1337,3832"/>
<area href="classglow_1_1_regression_node.html" title="Takes an Input tensor and creates a regression output layer. " alt="glow::RegressionNode" shape="rect" coords="962,3864,1337,3888"/>
<area href="classglow_1_1_relu_grad_node.html" alt="glow::ReluGradNode" shape="rect" coords="962,3920,1337,3944"/>
<area href="classglow_1_1_relu_node.html" title="Applies ReLU, max(0, x), to each element in the Input tensor. " alt="glow::ReluNode" shape="rect" coords="962,3976,1337,4000"/>
<area href="classglow_1_1_replace_na_n_node.html" title="Replaces NaNs found in Input with Value. " alt="glow::ReplaceNaNNode" shape="rect" coords="962,4032,1337,4056"/>
<area href="classglow_1_1_rescale_quantized_node.html" title="Rescale the input quantized tensor to a new Scale and Offset. The new Scale and Offset are specified ..." alt="glow::RescaleQuantizedNode" shape="rect" coords="962,4088,1337,4112"/>
<area href="classglow_1_1_reshape_node.html" title="Reshape the Input tensor to shape Dims. " alt="glow::ReshapeNode" shape="rect" coords="962,4144,1337,4168"/>
<area href="classglow_1_1_resize_nearest_node.html" title="Given Input tensor of [N,H,W,C], where N is the batch, C is the channel or depth, H is the height and..." alt="glow::ResizeNearestNode" shape="rect" coords="962,4200,1337,4224"/>
<area href="classglow_1_1_rowwise_quantized_fully_connected_node.html" title="Creates a RowwiseQuantizedFullyConnected node where the Input matrix and the transpose of Weights mat..." alt="glow::RowwiseQuantizedFullyConnectedNode" shape="rect" coords="962,4256,1337,4280"/>
<area href="classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node.html" title="Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates th..." alt="glow::RowwiseQuantizedSparseLengthsWeightedSumNode" shape="rect" coords="962,4312,1337,4336"/>
<area href="classglow_1_1_save_node.html" title="Specifies a node whose Input will be copied to Output.This node prevents graph optimizations from eli..." alt="glow::SaveNode" shape="rect" coords="962,4368,1337,4392"/>
<area href="classglow_1_1_scatter_data_node.html" title="Copies each slice from Slices into Data at the corresponding index in Indices. For example..." alt="glow::ScatterDataNode" shape="rect" coords="962,4424,1337,4448"/>
<area href="classglow_1_1_select_node.html" title="Selects between values on the LHS or RHS, depending on the value of Cond. Cond is generated by the co..." alt="glow::SelectNode" shape="rect" coords="962,4480,1337,4504"/>
<area href="classglow_1_1_s_g_d_node.html" title="Stochastic Gradient Descent node used during training. Produces the updated weight that needs to be u..." alt="glow::SGDNode" shape="rect" coords="962,4536,1337,4560"/>
<area href="classglow_1_1_sigmoid_cross_entropy_with_logits_node.html" title="Computes the sigmoid cross entropy between two inputs. " alt="glow::SigmoidCrossEntropyWithLogitsNode" shape="rect" coords="962,4592,1337,4616"/>
<area href="classglow_1_1_sigmoid_grad_node.html" alt="glow::SigmoidGradNode" shape="rect" coords="962,4648,1337,4672"/>
<area href="classglow_1_1_sigmoid_node.html" title="Applies Sigmoid, 1 / (1 + exp(-x)), to each element in the Input tensor. " alt="glow::SigmoidNode" shape="rect" coords="962,4704,1337,4728"/>
<area href="classglow_1_1_slice_node.html" title="Produces a slice of the Input tensor. The Start vector defines the starting indices for each dimensio..." alt="glow::SliceNode" shape="rect" coords="962,4760,1337,4784"/>
<area href="classglow_1_1_soft_max_grad_node.html" alt="glow::SoftMaxGradNode" shape="rect" coords="962,4816,1337,4840"/>
<area href="classglow_1_1_soft_max_node.html" title="Performs SoftMax normalization on the Input tensor. " alt="glow::SoftMaxNode" shape="rect" coords="962,4872,1337,4896"/>
<area href="classglow_1_1_space_to_depth_node.html" title="Given Input tensor of [N,H,W,C], where N is the batch axis, C is the channel or depth, H is the height and W is the width. This produces Output tensor of [N, H/BlockSize, W/BlockSize, C * BlockSize * BlockSize]. " alt="glow::SpaceToDepthNode" shape="rect" coords="962,4928,1337,4952"/>
<area href="classglow_1_1_sparse_lengths_sum_node.html" title="Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates th..." alt="glow::SparseLengthsSumNode" shape="rect" coords="962,4984,1337,5008"/>
<area href="classglow_1_1_sparse_lengths_weighted_sum_grad_node.html" alt="glow::SparseLengthsWeightedSumGradNode" shape="rect" coords="962,5040,1337,5064"/>
<area href="classglow_1_1_sparse_lengths_weighted_sum_node.html" title="Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates th..." alt="glow::SparseLengthsWeightedSumNode" shape="rect" coords="962,5096,1337,5120"/>
<area href="classglow_1_1_sparse_lengths_weighted_sum_offsets_node.html" title="Gathers slices of the outer-most dimension of Data indexed by Indices vector, and then accumulates th..." alt="glow::SparseLengthsWeightedSumOffsetsNode" shape="rect" coords="962,5152,1337,5176"/>
<area href="classglow_1_1_sparse_to_dense_mask_node.html" title="Converts the sparse representation specified by the pair (Indices, Values) into a dense one..." alt="glow::SparseToDenseMaskNode" shape="rect" coords="962,5208,1337,5232"/>
<area href="classglow_1_1_sparse_to_dense_node.html" title="Converts the sparse representation specified by the pair (Indices, Values) into a dense one..." alt="glow::SparseToDenseNode" shape="rect" coords="962,5264,1337,5288"/>
<area href="classglow_1_1_splat_node.html" title="Generate a tensor of a specific type filled with &#39;Value&#39;.Splat always keep floating point value inter..." alt="glow::SplatNode" shape="rect" coords="962,5320,1337,5344"/>
<area href="classglow_1_1_storage.html" alt="glow::Storage" shape="rect" coords="962,5376,1337,5400"/>
<area href="classglow_1_1_sub_grad_node.html" alt="glow::SubGradNode" shape="rect" coords="962,5432,1337,5456"/>
<area href="classglow_1_1_sub_node.html" title="Performs Sub on the LHS and RHS operands. " alt="glow::SubNode" shape="rect" coords="962,5488,1337,5512"/>
<area href="classglow_1_1_tanh_grad_node.html" alt="glow::TanhGradNode" shape="rect" coords="962,5544,1337,5568"/>
<area href="classglow_1_1_tanh_node.html" title="Applies hyperbolic tangent to each element in the Input tensor. " alt="glow::TanhNode" shape="rect" coords="962,5600,1337,5624"/>
<area href="classglow_1_1_tile_node.html" title="Tile an Input tensor Count times along Axis. " alt="glow::TileNode" shape="rect" coords="962,5656,1337,5680"/>
<area href="classglow_1_1_top_k_node.html" title="Finds the top K maximal elements for each vector in the tensor. Vectors are defined as the last dimen..." alt="glow::TopKNode" shape="rect" coords="962,5712,1337,5736"/>
<area href="classglow_1_1_trace_event_node.html" title="Inserts a TraceEvent for profiling. " alt="glow::TraceEventNode" shape="rect" coords="962,5768,1337,5792"/>
<area href="classglow_1_1_transpose_node.html" title="Transpose the Input tensor based on the vector Shuffle, which assigns a new axis for each dimension i..." alt="glow::TransposeNode" shape="rect" coords="962,5824,1337,5848"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a763bc613775e465454739bec23862f0c"><td class="memItemLeft" align="right" valign="top"><a id="a763bc613775e465454739bec23862f0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (Kinded::Kind k, llvm::StringRef name)</td></tr>
<tr class="separator:a763bc613775e465454739bec23862f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d2dcebd65cef8d43ca2e90f3b59d05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#aa8d2dcebd65cef8d43ca2e90f3b59d05">getPredicate</a> () const</td></tr>
<tr class="separator:aa8d2dcebd65cef8d43ca2e90f3b59d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab626908f81e8d10eb4f42376ecb152eb"><td class="memItemLeft" align="right" valign="top"><a id="ab626908f81e8d10eb4f42376ecb152eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ab626908f81e8d10eb4f42376ecb152eb">setPredicate</a> (const <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> &amp;P)</td></tr>
<tr class="memdesc:ab626908f81e8d10eb4f42376ecb152eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a nullable predicate to the current node. <br /></td></tr>
<tr class="separator:ab626908f81e8d10eb4f42376ecb152eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36202286cf4467a177d8e1844d9e9f0a"><td class="memItemLeft" align="right" valign="top"><a id="a36202286cf4467a177d8e1844d9e9f0a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a36202286cf4467a177d8e1844d9e9f0a">hasPredicate</a> () const</td></tr>
<tr class="memdesc:a36202286cf4467a177d8e1844d9e9f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a predicate is assigned to the current node. <br /></td></tr>
<tr class="separator:a36202286cf4467a177d8e1844d9e9f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b7b40d0aaef77d50648124cf310bbb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ac3b7b40d0aaef77d50648124cf310bbb">getNumResults</a> () const</td></tr>
<tr class="separator:ac3b7b40d0aaef77d50648124cf310bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcdbc1727fd5ee405409168fe834f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a2bcdbc1727fd5ee405409168fe834f5f">getNthResult</a> (unsigned idx)</td></tr>
<tr class="separator:a2bcdbc1727fd5ee405409168fe834f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa570f3b0b2125e3b18b125d3c557f12b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#aa570f3b0b2125e3b18b125d3c557f12b">getNthResult</a> (unsigned idx) const</td></tr>
<tr class="separator:aa570f3b0b2125e3b18b125d3c557f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11974fd21979f60789e6c02533e17fda"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a11974fd21979f60789e6c02533e17fda">getParent</a> () const</td></tr>
<tr class="separator:a11974fd21979f60789e6c02533e17fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca46f50522cc94fa461869821552adb7"><td class="memItemLeft" align="right" valign="top"><a id="aca46f50522cc94fa461869821552adb7"></a>
<a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParent</b> ()</td></tr>
<tr class="separator:aca46f50522cc94fa461869821552adb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab320e5e60178b9a7913c0a816109a0fd"><td class="memItemLeft" align="right" valign="top"><a id="ab320e5e60178b9a7913c0a816109a0fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ab320e5e60178b9a7913c0a816109a0fd">setParent</a> (<a class="el" href="classglow_1_1_function.html">Function</a> *parent)</td></tr>
<tr class="memdesc:ab320e5e60178b9a7913c0a816109a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the link to the function that holds this node. <br /></td></tr>
<tr class="separator:ab320e5e60178b9a7913c0a816109a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5702e4c8358c22a904cc3f874b1dc9"><td class="memItemLeft" align="right" valign="top"><a id="a8b5702e4c8358c22a904cc3f874b1dc9"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a8b5702e4c8358c22a904cc3f874b1dc9">getNumInputs</a> () const</td></tr>
<tr class="memdesc:a8b5702e4c8358c22a904cc3f874b1dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getters/setters to access <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a>'s inputs and outputs. <br /></td></tr>
<tr class="separator:a8b5702e4c8358c22a904cc3f874b1dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed63a8a5fcbcb158cb8e2765da8f9d6"><td class="memItemLeft" align="right" valign="top"><a id="afed63a8a5fcbcb158cb8e2765da8f9d6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getInputName</b> (unsigned idx) const</td></tr>
<tr class="separator:afed63a8a5fcbcb158cb8e2765da8f9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62cc118b0b1c8a9e23e6d431c41a11c"><td class="memItemLeft" align="right" valign="top"><a id="ad62cc118b0b1c8a9e23e6d431c41a11c"></a>
<a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNthInput</b> (unsigned idx)</td></tr>
<tr class="separator:ad62cc118b0b1c8a9e23e6d431c41a11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1daab7e145aa2f9dc9c7a68fd17cfda"><td class="memItemLeft" align="right" valign="top"><a id="ab1daab7e145aa2f9dc9c7a68fd17cfda"></a>
const <a class="el" href="structglow_1_1_node_value.html">NodeValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNthInput</b> (unsigned idx) const</td></tr>
<tr class="separator:ab1daab7e145aa2f9dc9c7a68fd17cfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551df6e3d3985f7746f30874b8e96a37"><td class="memItemLeft" align="right" valign="top"><a id="a551df6e3d3985f7746f30874b8e96a37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNthInput</b> (unsigned idx, <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> val)</td></tr>
<tr class="separator:a551df6e3d3985f7746f30874b8e96a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff71bc7d431207970d996b14782b0db"><td class="memItemLeft" align="right" valign="top"><a id="a5ff71bc7d431207970d996b14782b0db"></a>
llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><b>getOutputName</b> (unsigned idx) const</td></tr>
<tr class="separator:a5ff71bc7d431207970d996b14782b0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac711f231a8c8eb69954a0502281d22"><td class="memItemLeft" align="right" valign="top"><a id="abac711f231a8c8eb69954a0502281d22"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasSideEffects</b> () const</td></tr>
<tr class="separator:abac711f231a8c8eb69954a0502281d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a1c392e41b65c95833bd163927e504"><td class="memItemLeft" align="right" valign="top"><a id="a73a1c392e41b65c95833bd163927e504"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isArithmetic</b> () const</td></tr>
<tr class="separator:a73a1c392e41b65c95833bd163927e504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7fd2ca7503d3c8dc19bea6969cf440"><td class="memItemLeft" align="right" valign="top"><a id="a7f7fd2ca7503d3c8dc19bea6969cf440"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDataParallel</b> () const</td></tr>
<tr class="separator:a7f7fd2ca7503d3c8dc19bea6969cf440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d2b902d958cac587be871b69df1bdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#af8d2b902d958cac587be871b69df1bdf">isOverwrittenNthInput</a> (unsigned idx) const</td></tr>
<tr class="separator:af8d2b902d958cac587be871b69df1bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d828791f94bf520faf9c00c2f678135"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a0d828791f94bf520faf9c00c2f678135">getDebugDesc</a> () const</td></tr>
<tr class="separator:a0d828791f94bf520faf9c00c2f678135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a6afd99a1fa9ec17411c719f3170bc"><td class="memItemLeft" align="right" valign="top"><a id="a85a6afd99a1fa9ec17411c719f3170bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a85a6afd99a1fa9ec17411c719f3170bc">dump</a> (llvm::raw_ostream &amp;out) const</td></tr>
<tr class="memdesc:a85a6afd99a1fa9ec17411c719f3170bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> into provided output stream. <br /></td></tr>
<tr class="separator:a85a6afd99a1fa9ec17411c719f3170bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b8b415ec930f1c5444128c1825a1fd"><td class="memItemLeft" align="right" valign="top"><a id="ac0b8b415ec930f1c5444128c1825a1fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ac0b8b415ec930f1c5444128c1825a1fd">dump</a> () const</td></tr>
<tr class="memdesc:ac0b8b415ec930f1c5444128c1825a1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> into default output stream. <br /></td></tr>
<tr class="separator:ac0b8b415ec930f1c5444128c1825a1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5d17c95876fa6030ddabbdb1cb88d6"><td class="memItemLeft" align="right" valign="top"><a id="a3a5d17c95876fa6030ddabbdb1cb88d6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a3a5d17c95876fa6030ddabbdb1cb88d6">toString</a> () const</td></tr>
<tr class="memdesc:a3a5d17c95876fa6030ddabbdb1cb88d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_node.html" title="Represents a node in the compute graph. ">Node</a> to std::string. <br /></td></tr>
<tr class="separator:a3a5d17c95876fa6030ddabbdb1cb88d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e518ef19a5ddea3fff4d9a146c4f37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ae1e518ef19a5ddea3fff4d9a146c4f37">clone</a> () const</td></tr>
<tr class="separator:ae1e518ef19a5ddea3fff4d9a146c4f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeb437c040985884ff29c1ccd7946a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#aafeb437c040985884ff29c1ccd7946a5">isEqual</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;other) const</td></tr>
<tr class="separator:aafeb437c040985884ff29c1ccd7946a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f15015ad48947f9e6d329e94f4a29d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ad4f15015ad48947f9e6d329e94f4a29d">operator==</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;O) const</td></tr>
<tr class="separator:ad4f15015ad48947f9e6d329e94f4a29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64701a874397cb291e62b74d782f8729"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a64701a874397cb291e62b74d782f8729">getHash</a> () const</td></tr>
<tr class="separator:a64701a874397cb291e62b74d782f8729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf56aeb0f2601d389efd276691ba0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a3cf56aeb0f2601d389efd276691ba0cc">visit</a> (<a class="el" href="classglow_1_1_node.html">Node</a> *parent, <a class="el" href="classglow_1_1_node_walker.html">NodeWalker</a> *visitor)</td></tr>
<tr class="separator:a3cf56aeb0f2601d389efd276691ba0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc090e9f629b4a63a5b7a68173f21ecd"><td class="memItemLeft" align="right" valign="top"><a id="acc090e9f629b4a63a5b7a68173f21ecd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="classglow_1_1_node.html">Node</a> *parent, <a class="el" href="classglow_1_1_node_walker.html">NodeWalker</a> *visitor) const</td></tr>
<tr class="separator:acc090e9f629b4a63a5b7a68173f21ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68444a674fcec690542184620c62f3f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a68444a674fcec690542184620c62f3f9">verify</a> () const</td></tr>
<tr class="separator:a68444a674fcec690542184620c62f3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e43cd641d23ef79cbed7977406956"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a3f0e43cd641d23ef79cbed7977406956">releaseUsers</a> ()</td></tr>
<tr class="separator:a3f0e43cd641d23ef79cbed7977406956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbfc4b0def2722bb3b8a18499111d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a5fbfc4b0def2722bb3b8a18499111d69">getType</a> (unsigned idx) const</td></tr>
<tr class="separator:a5fbfc4b0def2722bb3b8a18499111d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc4d836519ee24333cf01500ba76a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#a6dc4d836519ee24333cf01500ba76a00">setType</a> (unsigned idx, <a class="el" href="structglow_1_1_type.html">TypeRef</a> ty)</td></tr>
<tr class="separator:a6dc4d836519ee24333cf01500ba76a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac8ff415675b1bdffe7ed357d87932023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ac8ff415675b1bdffe7ed357d87932023">getElementType</a> (unsigned resNo) const</td></tr>
<tr class="separator:ac8ff415675b1bdffe7ed357d87932023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bf0a7be9caaf273e176f2f97eb9c7f"><td class="memItemLeft" align="right" valign="top"><a id="ad9bf0a7be9caaf273e176f2f97eb9c7f"></a>
llvm::ArrayRef&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dims</b> (unsigned resNo) const</td></tr>
<tr class="separator:ad9bf0a7be9caaf273e176f2f97eb9c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classglow_1_1_named"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classglow_1_1_named')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classglow_1_1_named.html">glow::Named</a></td></tr>
<tr class="memitem:ac406265dc7c227a235ef0967c1ca3b78 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top"><a id="ac406265dc7c227a235ef0967c1ca3b78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Named</b> (llvm::StringRef name)</td></tr>
<tr class="separator:ac406265dc7c227a235ef0967c1ca3b78 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953e8bbe0c565edf52e374d461579c4e inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top">llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#a953e8bbe0c565edf52e374d461579c4e">getName</a> () const</td></tr>
<tr class="separator:a953e8bbe0c565edf52e374d461579c4e inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdd13e8cd2d61adbbc9cb6fedd0acd4 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#aafdd13e8cd2d61adbbc9cb6fedd0acd4">hasName</a> () const</td></tr>
<tr class="separator:aafdd13e8cd2d61adbbc9cb6fedd0acd4 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99fea3a80a29c8177bbba36232ba850 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top"><a id="ac99fea3a80a29c8177bbba36232ba850"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#ac99fea3a80a29c8177bbba36232ba850">setName</a> (llvm::StringRef name)</td></tr>
<tr class="memdesc:ac99fea3a80a29c8177bbba36232ba850 inherit pub_methods_classglow_1_1_named"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the instruction to <code>name</code>. <br /></td></tr>
<tr class="separator:ac99fea3a80a29c8177bbba36232ba850 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199b7443a774b5268848a783ef6cb186 inherit pub_methods_classglow_1_1_named"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_named.html#a199b7443a774b5268848a783ef6cb186">compareByName</a> (const <a class="el" href="classglow_1_1_named.html">Named</a> &amp;x) const</td></tr>
<tr class="memdesc:a199b7443a774b5268848a783ef6cb186 inherit pub_methods_classglow_1_1_named"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares by names,.  <a href="classglow_1_1_named.html#a199b7443a774b5268848a783ef6cb186">More...</a><br /></td></tr>
<tr class="separator:a199b7443a774b5268848a783ef6cb186 inherit pub_methods_classglow_1_1_named"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classglow_1_1_kinded"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classglow_1_1_kinded')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classglow_1_1_kinded.html">glow::Kinded</a></td></tr>
<tr class="memitem:a9b8409bbf440dd4311cc43aea3354b72 inherit pub_methods_classglow_1_1_kinded"><td class="memItemLeft" align="right" valign="top"><a id="a9b8409bbf440dd4311cc43aea3354b72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_kinded.html#a9b8409bbf440dd4311cc43aea3354b72">Kinded</a> (Kind vk)</td></tr>
<tr class="memdesc:a9b8409bbf440dd4311cc43aea3354b72 inherit pub_methods_classglow_1_1_kinded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor. <br /></td></tr>
<tr class="separator:a9b8409bbf440dd4311cc43aea3354b72 inherit pub_methods_classglow_1_1_kinded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c279eca46b25dce84795ef618e38071 inherit pub_methods_classglow_1_1_kinded"><td class="memItemLeft" align="right" valign="top"><a id="a4c279eca46b25dce84795ef618e38071"></a>
Kind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_kinded.html#a4c279eca46b25dce84795ef618e38071">getKind</a> () const</td></tr>
<tr class="memdesc:a4c279eca46b25dce84795ef618e38071 inherit pub_methods_classglow_1_1_kinded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of the instruction. <br /></td></tr>
<tr class="separator:a4c279eca46b25dce84795ef618e38071 inherit pub_methods_classglow_1_1_kinded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc07704564602612f0414548be4895b inherit pub_methods_classglow_1_1_kinded"><td class="memItemLeft" align="right" valign="top"><a id="a8cc07704564602612f0414548be4895b"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getKindName</b> () const</td></tr>
<tr class="separator:a8cc07704564602612f0414548be4895b inherit pub_methods_classglow_1_1_kinded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classglow_1_1_use_def"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classglow_1_1_use_def')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classglow_1_1_use_def.html">glow::UseDef&lt; Node, NodeUse &gt;</a></td></tr>
<tr class="memitem:a8ad43846727ec8ca1d90d6bfe78e42aa inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top"><a id="a8ad43846727ec8ca1d90d6bfe78e42aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#a8ad43846727ec8ca1d90d6bfe78e42aa">removeUse</a> (<a class="el" href="structglow_1_1_node_use.html">NodeUse</a> U)</td></tr>
<tr class="memdesc:a8ad43846727ec8ca1d90d6bfe78e42aa inherit pub_methods_classglow_1_1_use_def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the use <code>U</code> from the uselist. <br /></td></tr>
<tr class="separator:a8ad43846727ec8ca1d90d6bfe78e42aa inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c271b975499255e48b0ba1f050acf1 inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top"><a id="af4c271b975499255e48b0ba1f050acf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#af4c271b975499255e48b0ba1f050acf1">addUse</a> (<a class="el" href="structglow_1_1_node_use.html">NodeUse</a> U)</td></tr>
<tr class="memdesc:af4c271b975499255e48b0ba1f050acf1 inherit pub_methods_classglow_1_1_use_def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the use <code>U</code>. <br /></td></tr>
<tr class="separator:af4c271b975499255e48b0ba1f050acf1 inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e259466504c1b589ff4f84dc5bcbb9 inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#a57e259466504c1b589ff4f84dc5bcbb9">hasUsers</a> () const</td></tr>
<tr class="separator:a57e259466504c1b589ff4f84dc5bcbb9 inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3381f7085f27c6053426920b42147c inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#aff3381f7085f27c6053426920b42147c">hasOneUse</a> () const</td></tr>
<tr class="separator:aff3381f7085f27c6053426920b42147c inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4e20812def8d2a62db301527e8e9e8 inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#aee4e20812def8d2a62db301527e8e9e8">getNumUsers</a> () const</td></tr>
<tr class="separator:aee4e20812def8d2a62db301527e8e9e8 inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0a173f02a51a77ce3e9e342ae416c9 inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top"><a id="a9b0a173f02a51a77ce3e9e342ae416c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#a9b0a173f02a51a77ce3e9e342ae416c9">hasUser</a> (const <a class="el" href="classglow_1_1_node.html">Node</a> *I) const</td></tr>
<tr class="memdesc:a9b0a173f02a51a77ce3e9e342ae416c9 inherit pub_methods_classglow_1_1_use_def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the user <code>I</code> is in the list. <br /></td></tr>
<tr class="separator:a9b0a173f02a51a77ce3e9e342ae416c9 inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36287064b16f4c2569988d2b795cd9b7 inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structglow_1_1_node_use.html">NodeUse</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#a36287064b16f4c2569988d2b795cd9b7">getUsers</a> ()</td></tr>
<tr class="separator:a36287064b16f4c2569988d2b795cd9b7 inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a07afe24f9546f4ea841ffefe46508 inherit pub_methods_classglow_1_1_use_def"><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="structglow_1_1_node_use.html">NodeUse</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_use_def.html#a15a07afe24f9546f4ea841ffefe46508">getUsers</a> () const</td></tr>
<tr class="separator:a15a07afe24f9546f4ea841ffefe46508 inherit pub_methods_classglow_1_1_use_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae650ba4d94f1a206e5a495de6ac2d512"><td class="memItemLeft" align="right" valign="top"><a id="ae650ba4d94f1a206e5a495de6ac2d512"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#ae650ba4d94f1a206e5a495de6ac2d512">addResult</a> (<a class="el" href="structglow_1_1_type.html">TypeRef</a> T)</td></tr>
<tr class="memdesc:ae650ba4d94f1a206e5a495de6ac2d512"><td class="mdescLeft">&#160;</td><td class="mdescRight">When constructing the node, add a new result of type <code>T</code>. <br /></td></tr>
<tr class="separator:ae650ba4d94f1a206e5a495de6ac2d512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aca9c9027bff8aa59822a0e79d1c1914d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#aca9c9027bff8aa59822a0e79d1c1914d">destroyNode</a> (<a class="el" href="classglow_1_1_node.html">Node</a> *N)</td></tr>
<tr class="separator:aca9c9027bff8aa59822a0e79d1c1914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afd0dabbd2c342c80c33f16d2ed30102a"><td class="memItemLeft" align="right" valign="top"><a id="afd0dabbd2c342c80c33f16d2ed30102a"></a>
llvm::SmallVector&lt; <a class="el" href="structglow_1_1_type.html">TypeRef</a>, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#afd0dabbd2c342c80c33f16d2ed30102a">types_</a></td></tr>
<tr class="memdesc:afd0dabbd2c342c80c33f16d2ed30102a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output types for the results of the node. <br /></td></tr>
<tr class="separator:afd0dabbd2c342c80c33f16d2ed30102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff87321fccd69d8c1feb8b453c28e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structglow_1_1_node_handle.html">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#abff87321fccd69d8c1feb8b453c28e13">predicate_</a></td></tr>
<tr class="separator:abff87321fccd69d8c1feb8b453c28e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7da8db8229694ff1a01c4364d9f68d"><td class="memItemLeft" align="right" valign="top"><a id="aba7da8db8229694ff1a01c4364d9f68d"></a>
<a class="el" href="classglow_1_1_function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_node.html#aba7da8db8229694ff1a01c4364d9f68d">parent_</a></td></tr>
<tr class="memdesc:aba7da8db8229694ff1a01c4364d9f68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link to the function holding this node. <br /></td></tr>
<tr class="separator:aba7da8db8229694ff1a01c4364d9f68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classglow_1_1_kinded"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classglow_1_1_kinded')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classglow_1_1_kinded.html">glow::Kinded</a></td></tr>
<tr class="memitem:ac1213e4fa518bbe8f4cf0729eaf1162f inherit pub_types_classglow_1_1_kinded"><td class="memItemLeft" align="right" valign="top"><a id="ac1213e4fa518bbe8f4cf0729eaf1162f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Kind</b> { <b>DEF_INSTR</b>, 
<b>DEF_BACKEND_SPECIFIC_INSTR</b>, 
<b>DEF_VALUE</b>, 
<b>DEF_NODE</b>
 }</td></tr>
<tr class="separator:ac1213e4fa518bbe8f4cf0729eaf1162f inherit pub_types_classglow_1_1_kinded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classglow_1_1_kinded"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classglow_1_1_kinded')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classglow_1_1_kinded.html">glow::Kinded</a></td></tr>
<tr class="memitem:a8352d6787c9844f02927b0958de0bc48 inherit pub_static_methods_classglow_1_1_kinded"><td class="memItemLeft" align="right" valign="top"><a id="a8352d6787c9844f02927b0958de0bc48"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getKindName</b> (Kind IK)</td></tr>
<tr class="separator:a8352d6787c9844f02927b0958de0bc48 inherit pub_static_methods_classglow_1_1_kinded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a node in the compute graph. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1e518ef19a5ddea3fff4d9a146c4f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e518ef19a5ddea3fff4d9a146c4f37">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_node.html">Node</a> * Node::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>copy of the current node. Notice that the new node is not inserted into any DAG. The caller of this method should add it to some node-list. </dd></dl>

</div>
</div>
<a id="aca9c9027bff8aa59822a0e79d1c1914d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c9027bff8aa59822a0e79d1c1914d">&#9670;&nbsp;</a></span>destroyNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::destroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys a node and deallocates the memory. This method is typically implicitly invoked when a node is being removed from the intrusive list of nodes. </p>

</div>
</div>
<a id="a0d828791f94bf520faf9c00c2f678135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d828791f94bf520faf9c00c2f678135">&#9670;&nbsp;</a></span>getDebugDesc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Node::getDebugDesc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a textual description of the node. </dd></dl>

</div>
</div>
<a id="ac8ff415675b1bdffe7ed357d87932023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ff415675b1bdffe7ed357d87932023">&#9670;&nbsp;</a></span>getElementType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> Node::getElementType </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>resNo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Methods that forward to the result type (that must be valid): </p>

</div>
</div>
<a id="a64701a874397cb291e62b74d782f8729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64701a874397cb291e62b74d782f8729">&#9670;&nbsp;</a></span>getHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code Node::getHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a hash code of the node. </dd></dl>

</div>
</div>
<a id="a2bcdbc1727fd5ee405409168fe834f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcdbc1727fd5ee405409168fe834f5f">&#9670;&nbsp;</a></span>getNthResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Node::getNthResult </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <code>idx</code> result of the node. </dd></dl>

</div>
</div>
<a id="aa570f3b0b2125e3b18b125d3c557f12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa570f3b0b2125e3b18b125d3c557f12b">&#9670;&nbsp;</a></span>getNthResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Node::getNthResult </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the n'th result of the node. </dd></dl>

</div>
</div>
<a id="ac3b7b40d0aaef77d50648124cf310bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b7b40d0aaef77d50648124cf310bbb">&#9670;&nbsp;</a></span>getNumResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned glow::Node::getNumResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of results that the node has. </dd></dl>

</div>
</div>
<a id="a11974fd21979f60789e6c02533e17fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11974fd21979f60789e6c02533e17fda">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglow_1_1_function.html">Function</a>* glow::Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the function holding this node. If that node does not belong to any function, this is nullptr. </dd></dl>

</div>
</div>
<a id="aa8d2dcebd65cef8d43ca2e90f3b59d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d2dcebd65cef8d43ca2e90f3b59d05">&#9670;&nbsp;</a></span>getPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structglow_1_1_node_value.html">NodeValue</a> Node::getPredicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the nullable predicate of the current node. </dd></dl>

</div>
</div>
<a id="a5fbfc4b0def2722bb3b8a18499111d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbfc4b0def2722bb3b8a18499111d69">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structglow_1_1_type.html">TypeRef</a> Node::getType </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the n'th result type of the node. </dd></dl>

</div>
</div>
<a id="aafeb437c040985884ff29c1ccd7946a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafeb437c040985884ff29c1ccd7946a5">&#9670;&nbsp;</a></span>isEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the node is equal to the other node. </dd></dl>

</div>
</div>
<a id="af8d2b902d958cac587be871b69df1bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d2b902d958cac587be871b69df1bdf">&#9670;&nbsp;</a></span>isOverwrittenNthInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isOverwrittenNthInput </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this input is being overwritten by the node. </dd></dl>

</div>
</div>
<a id="ad4f15015ad48947f9e6d329e94f4a29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f15015ad48947f9e6d329e94f4a29d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::Node::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the node is equal to the other node. </dd></dl>

</div>
</div>
<a id="a3f0e43cd641d23ef79cbed7977406956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0e43cd641d23ef79cbed7977406956">&#9670;&nbsp;</a></span>releaseUsers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Node::releaseUsers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all uses of this node with null. This method is used by the destruction sequence. When the node is deleted we need to unregister all users. This allows us to deconstruct the graph in an arbitrary order. </p>

</div>
</div>
<a id="a6dc4d836519ee24333cf01500ba76a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc4d836519ee24333cf01500ba76a00">&#9670;&nbsp;</a></span>setType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setType </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the <code>idx'th</code> result type of the node. </p><dl class="section note"><dt>Note</dt><dd>This setter only changes the type of this one result. If that type is incompatible with the inputs of the node, the caller is responsible to update these if need be. </dd></dl>

</div>
</div>
<a id="a68444a674fcec690542184620c62f3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68444a674fcec690542184620c62f3f9">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify node. </p><dl class="section return"><dt>Returns</dt><dd>True if the node is valid. False otherwise. </dd></dl>

</div>
</div>
<a id="a3cf56aeb0f2601d389efd276691ba0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf56aeb0f2601d389efd276691ba0cc">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_node_walker.html">NodeWalker</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method implements the visitor pattern that scans the compute DAG top to bottom. The visitor <code>visitor</code> is sent by the parent node <code>parent</code>, or nullptr if this is the first node to be visited. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abff87321fccd69d8c1feb8b453c28e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff87321fccd69d8c1feb8b453c28e13">&#9670;&nbsp;</a></span>predicate_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structglow_1_1_node_handle.html">NodeHandle</a> glow::Node::predicate_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A nullable reference to some tensor value that may predicate the execution of the current node. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/glow/Graph/<a class="el" href="_node_8h_source.html">Node.h</a></li>
<li>lib/Graph/Node.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
