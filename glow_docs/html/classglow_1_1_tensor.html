<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glow: glow::Tensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Glow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglow.html">glow</a></li><li class="navelem"><a class="el" href="classglow_1_1_tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classglow_1_1_tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">glow::Tensor Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that represents a contiguous n-dimensional array (a tensor).  
 <a href="classglow_1_1_tensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_tensor_8h_source.html">Tensor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a20209a68c0539dfff33c065fe8358073"><td class="memItemLeft" align="right" valign="top"><a id="a20209a68c0539dfff33c065fe8358073"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a20209a68c0539dfff33c065fe8358073">InitKind</a> { <b>Zero</b>, 
<b>Broadcast</b>, 
<b>Xavier</b>
 }<tr class="memdesc:a20209a68c0539dfff33c065fe8358073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the kind initialization for the tensor. <br /></td></tr>
</td></tr>
<tr class="separator:a20209a68c0539dfff33c065fe8358073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a574b58e799067a444cb639d0e7791b47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a574b58e799067a444cb639d0e7791b47">isUnowned</a> () const</td></tr>
<tr class="separator:a574b58e799067a444cb639d0e7791b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785ff21009c869e55c614a740c14de6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a785ff21009c869e55c614a740c14de6f">getUnpaddedSizeInBytes</a> () const</td></tr>
<tr class="separator:a785ff21009c869e55c614a740c14de6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7622d21d76d06f4628386c9a2db733"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#aeb7622d21d76d06f4628386c9a2db733">getType</a> () const</td></tr>
<tr class="separator:aeb7622d21d76d06f4628386c9a2db733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88806a5ba8a0bbb9abff000f6b27d3b6"><td class="memItemLeft" align="right" valign="top"><a id="a88806a5ba8a0bbb9abff000f6b27d3b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a88806a5ba8a0bbb9abff000f6b27d3b6">setType</a> (const <a class="el" href="structglow_1_1_type.html">TypeRef</a> t)</td></tr>
<tr class="memdesc:a88806a5ba8a0bbb9abff000f6b27d3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> to <code>t</code>. <br /></td></tr>
<tr class="separator:a88806a5ba8a0bbb9abff000f6b27d3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaeb77d2037ea76e6deea21a13c39dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#affaeb77d2037ea76e6deea21a13c39dc">getElementType</a> () const</td></tr>
<tr class="separator:affaeb77d2037ea76e6deea21a13c39dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a74e37ff3771b581afc94291899f20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ac6a74e37ff3771b581afc94291899f20">isInBounds</a> (llvm::ArrayRef&lt; size_t &gt; indices) const</td></tr>
<tr class="separator:ac6a74e37ff3771b581afc94291899f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a3efa21c06448d41b445520aaef42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ab55a3efa21c06448d41b445520aaef42">zero</a> (bool resetFusedScalesOffsets=false)</td></tr>
<tr class="separator:ab55a3efa21c06448d41b445520aaef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad299b107d8ed92bb55392c4cb97070d9"><td class="memItemLeft" align="right" valign="top">llvm::ArrayRef&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ad299b107d8ed92bb55392c4cb97070d9">dims</a> () const</td></tr>
<tr class="separator:ad299b107d8ed92bb55392c4cb97070d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131eef055527823adf306e8928d4ae04"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a131eef055527823adf306e8928d4ae04">size</a> () const</td></tr>
<tr class="separator:a131eef055527823adf306e8928d4ae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f7219f5e4e926d953fd1dc674ff7c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a72f7219f5e4e926d953fd1dc674ff7c0">actualSize</a> () const</td></tr>
<tr class="separator:a72f7219f5e4e926d953fd1dc674ff7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef091fe78b378595f2ce3adf32b1821"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a5ef091fe78b378595f2ce3adf32b1821">getSizeInBytes</a> () const</td></tr>
<tr class="separator:a5ef091fe78b378595f2ce3adf32b1821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62651514d8a45c6633948a87a1766e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tensor_pool.html">TensorPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a62651514d8a45c6633948a87a1766e56">getOwningPool</a> ()</td></tr>
<tr class="separator:a62651514d8a45c6633948a87a1766e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a89f5d8183362c9baa5c6645aa8dfe6"><td class="memItemLeft" align="right" valign="top"><a id="a9a89f5d8183362c9baa5c6645aa8dfe6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a9a89f5d8183362c9baa5c6645aa8dfe6">Tensor</a> ()=default</td></tr>
<tr class="memdesc:a9a89f5d8183362c9baa5c6645aa8dfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an empty tensor. <br /></td></tr>
<tr class="separator:a9a89f5d8183362c9baa5c6645aa8dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc52422cff0e2bc0276c808578af1d6"><td class="memItemLeft" align="right" valign="top"><a id="a4fc52422cff0e2bc0276c808578af1d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a4fc52422cff0e2bc0276c808578af1d6">Tensor</a> (const std::initializer_list&lt; float &gt; &amp;vec)</td></tr>
<tr class="memdesc:a4fc52422cff0e2bc0276c808578af1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a list of float literals. <br /></td></tr>
<tr class="separator:a4fc52422cff0e2bc0276c808578af1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796a7a282d6a74c575bbbcb075292910"><td class="memItemLeft" align="right" valign="top"><a id="a796a7a282d6a74c575bbbcb075292910"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a796a7a282d6a74c575bbbcb075292910">Tensor</a> (<a class="el" href="structglow_1_1_type.html">TypeRef</a> ty)</td></tr>
<tr class="memdesc:a796a7a282d6a74c575bbbcb075292910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new tensor. <br /></td></tr>
<tr class="separator:a796a7a282d6a74c575bbbcb075292910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77474ecb6a18092b9b4f180c22f2ec7"><td class="memItemLeft" align="right" valign="top"><a id="aa77474ecb6a18092b9b4f180c22f2ec7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#aa77474ecb6a18092b9b4f180c22f2ec7">Tensor</a> (const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;ty)</td></tr>
<tr class="memdesc:aa77474ecb6a18092b9b4f180c22f2ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new tensor. <br /></td></tr>
<tr class="separator:aa77474ecb6a18092b9b4f180c22f2ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2543ba8816bd9cf0e6a48fec62de3843"><td class="memItemLeft" align="right" valign="top"><a id="a2543ba8816bd9cf0e6a48fec62de3843"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a2543ba8816bd9cf0e6a48fec62de3843">Tensor</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> elemTy, llvm::ArrayRef&lt; size_t &gt; <a class="el" href="classglow_1_1_tensor.html#ad299b107d8ed92bb55392c4cb97070d9">dims</a>)</td></tr>
<tr class="memdesc:a2543ba8816bd9cf0e6a48fec62de3843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a float new tensor. <br /></td></tr>
<tr class="separator:a2543ba8816bd9cf0e6a48fec62de3843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647b7d8c649846c034297a04d4c3680b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a647b7d8c649846c034297a04d4c3680b">Tensor</a> (void *data, <a class="el" href="structglow_1_1_type.html">TypeRef</a> ty, size_t unpaddedSize=0)</td></tr>
<tr class="separator:a647b7d8c649846c034297a04d4c3680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7361b57a0c9de802be4922c950962dd"><td class="memItemLeft" align="right" valign="top"><a id="af7361b57a0c9de802be4922c950962dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#af7361b57a0c9de802be4922c950962dd">Tensor</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> elemTy, llvm::ArrayRef&lt; size_t &gt; <a class="el" href="classglow_1_1_tensor.html#ad299b107d8ed92bb55392c4cb97070d9">dims</a>, float scale, int32_t offset)</td></tr>
<tr class="memdesc:af7361b57a0c9de802be4922c950962dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new integer tensor with <code>scale</code> and <code>offset</code>. <br /></td></tr>
<tr class="separator:af7361b57a0c9de802be4922c950962dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b1303d86eb052f1613a399d83e420e"><td class="memItemLeft" align="right" valign="top"><a id="ad8b1303d86eb052f1613a399d83e420e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ad8b1303d86eb052f1613a399d83e420e">Tensor</a> (<a class="el" href="structglow_1_1_type.html">TypeRef</a> ty, <a class="el" href="classglow_1_1_tensor_pool.html">TensorPool</a> *tensorPool)</td></tr>
<tr class="memdesc:ad8b1303d86eb052f1613a399d83e420e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> managed by the <code>tensorPool</code>. <br /></td></tr>
<tr class="separator:ad8b1303d86eb052f1613a399d83e420e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c34395273dedd71eb372cb1c9a3a102"><td class="memItemLeft" align="right" valign="top"><a id="a3c34395273dedd71eb372cb1c9a3a102"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;other)=delete</td></tr>
<tr class="separator:a3c34395273dedd71eb372cb1c9a3a102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa46002e4a5dce0acb4ad5f130af344f"><td class="memItemLeft" align="right" valign="top"><a id="aaa46002e4a5dce0acb4ad5f130af344f"></a>
<a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;other)=delete</td></tr>
<tr class="separator:aaa46002e4a5dce0acb4ad5f130af344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bee99ef7a8498018fe4471574a10e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a57bee99ef7a8498018fe4471574a10e9">init</a> (<a class="el" href="classglow_1_1_tensor.html#a20209a68c0539dfff33c065fe8358073">InitKind</a> init, float val, <a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;PRNG)</td></tr>
<tr class="separator:a57bee99ef7a8498018fe4471574a10e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b71346a672215c780ec46d1925c6d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a2b71346a672215c780ec46d1925c6d03">getUnowned</a> (llvm::ArrayRef&lt; size_t &gt; <a class="el" href="classglow_1_1_tensor.html#ad299b107d8ed92bb55392c4cb97070d9">dims</a>, llvm::ArrayRef&lt; size_t &gt; offsets={}) const</td></tr>
<tr class="separator:a2b71346a672215c780ec46d1925c6d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2559af82f20a58b5e9da6d136a0684e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#aa2559af82f20a58b5e9da6d136a0684e">getOwnedSlice</a> (llvm::ArrayRef&lt; size_t &gt; <a class="el" href="classglow_1_1_tensor.html#ad299b107d8ed92bb55392c4cb97070d9">dims</a>, llvm::ArrayRef&lt; size_t &gt; offsets={}) const</td></tr>
<tr class="separator:aa2559af82f20a58b5e9da6d136a0684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6a485f0e461c1be799b7b8ad3b985e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#aac6a485f0e461c1be799b7b8ad3b985e">reset</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *other)</td></tr>
<tr class="separator:aac6a485f0e461c1be799b7b8ad3b985e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f2e49d32b9630d283c2938eaac48b"><td class="memItemLeft" align="right" valign="top"><a id="a746f2e49d32b9630d283c2938eaac48b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> elemTy, llvm::ArrayRef&lt; size_t &gt; shape)</td></tr>
<tr class="separator:a746f2e49d32b9630d283c2938eaac48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138bbf066e0c7d1d635395fbd6d3d95e"><td class="memItemLeft" align="right" valign="top"><a id="a138bbf066e0c7d1d635395fbd6d3d95e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> elemTy, llvm::ArrayRef&lt; size_t &gt; shape, float scale, int32_t offset)</td></tr>
<tr class="separator:a138bbf066e0c7d1d635395fbd6d3d95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe39403f76673198519ef4cd764a6ea1"><td class="memItemLeft" align="right" valign="top"><a id="abe39403f76673198519ef4cd764a6ea1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#abe39403f76673198519ef4cd764a6ea1">reset</a> (const <a class="el" href="structglow_1_1_type.html">Type</a> &amp;T)</td></tr>
<tr class="memdesc:abe39403f76673198519ef4cd764a6ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a new shape to the tensor and allocates a new buffer. <br /></td></tr>
<tr class="separator:abe39403f76673198519ef4cd764a6ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683bda6d887705f654f3dab72cd384a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a683bda6d887705f654f3dab72cd384a8">release</a> ()</td></tr>
<tr class="separator:a683bda6d887705f654f3dab72cd384a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed951b58cca4db640fffb4bc0eec3e"><td class="memItemLeft" align="right" valign="top"><a id="a36ed951b58cca4db640fffb4bc0eec3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a36ed951b58cca4db640fffb4bc0eec3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527a98b0a543ec2bef35c7986ed22376"><td class="memItemLeft" align="right" valign="top"><a id="a527a98b0a543ec2bef35c7986ed22376"></a>
<a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a527a98b0a543ec2bef35c7986ed22376">operator=</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a527a98b0a543ec2bef35c7986ed22376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a527a98b0a543ec2bef35c7986ed22376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c4661689063631677e9607cd04a1e3"><td class="memItemLeft" align="right" valign="top"><a id="ab1c4661689063631677e9607cd04a1e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ab1c4661689063631677e9607cd04a1e3">dump</a> (llvm::raw_ostream &amp;os) const</td></tr>
<tr class="memdesc:ab1c4661689063631677e9607cd04a1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> into provided output stream. <br /></td></tr>
<tr class="separator:ab1c4661689063631677e9607cd04a1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae22fafeb2d202f793c585876791793"><td class="memItemLeft" align="right" valign="top"><a id="a9ae22fafeb2d202f793c585876791793"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a9ae22fafeb2d202f793c585876791793">dump</a> () const</td></tr>
<tr class="memdesc:a9ae22fafeb2d202f793c585876791793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> into default output stream. <br /></td></tr>
<tr class="separator:a9ae22fafeb2d202f793c585876791793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a66dc3db1ac2e30c341552e93e20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ac67a66dc3db1ac2e30c341552e93e20d">dump</a> (llvm::raw_ostream &amp;os, unsigned maxNumElem) const</td></tr>
<tr class="separator:ac67a66dc3db1ac2e30c341552e93e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb64938f01ec86bb60020eebb1edf4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#afb64938f01ec86bb60020eebb1edf4e1">dump</a> (unsigned maxNumElem) const</td></tr>
<tr class="separator:afb64938f01ec86bb60020eebb1edf4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c052b4150fd71d91a2185873f75bb6"><td class="memItemLeft" align="right" valign="top"><a id="ad2c052b4150fd71d91a2185873f75bb6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ad2c052b4150fd71d91a2185873f75bb6">toString</a> () const</td></tr>
<tr class="memdesc:ad2c052b4150fd71d91a2185873f75bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a textual representation of the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> to std::string. <br /></td></tr>
<tr class="separator:ad2c052b4150fd71d91a2185873f75bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306995cc2d51a2676bef62bca462e2c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a306995cc2d51a2676bef62bca462e2c4">toString</a> (unsigned maxNumElem) const</td></tr>
<tr class="separator:a306995cc2d51a2676bef62bca462e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8169ad48bdffbd2e8fa18b914cc73a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#adc8169ad48bdffbd2e8fa18b914cc73a">isEqual</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;other, float allowedError=0.0001, bool verbose=true) const</td></tr>
<tr class="separator:adc8169ad48bdffbd2e8fa18b914cc73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4db56127af74adb5d9d6315bd6813c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a9e4db56127af74adb5d9d6315bd6813c">isBitwiseEqual</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;other) const</td></tr>
<tr class="separator:a9e4db56127af74adb5d9d6315bd6813c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe490fac96b01156ffb682cba77a40ed"><td class="memItemLeft" align="right" valign="top"><a id="afe490fac96b01156ffb682cba77a40ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEqualImpl</b> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;other, bool isBitwise, float allowedError, bool verbose) const</td></tr>
<tr class="separator:afe490fac96b01156ffb682cba77a40ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b433338320e6b2b2ecf76f44da37da"><td class="memItemLeft" align="right" valign="top"><a id="a95b433338320e6b2b2ecf76f44da37da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a95b433338320e6b2b2ecf76f44da37da">assign</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *t)</td></tr>
<tr class="memdesc:a95b433338320e6b2b2ecf76f44da37da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the content and type of the tensor from the tensor <code>t</code>. <br /></td></tr>
<tr class="separator:a95b433338320e6b2b2ecf76f44da37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51cf4de0d985f4c2d0aa08ac82fbc1c"><td class="memItemLeft" align="right" valign="top"><a id="af51cf4de0d985f4c2d0aa08ac82fbc1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#af51cf4de0d985f4c2d0aa08ac82fbc1c">copyRawFrom</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *t)</td></tr>
<tr class="memdesc:af51cf4de0d985f4c2d0aa08ac82fbc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the raw data of the tensor from the tensor <code>t</code>. <br /></td></tr>
<tr class="separator:af51cf4de0d985f4c2d0aa08ac82fbc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2859b4783c2e9c2a661d5d52754147df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a2859b4783c2e9c2a661d5d52754147df">copySlice</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *t, size_t slice)</td></tr>
<tr class="separator:a2859b4783c2e9c2a661d5d52754147df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a32f8e59470dcda68232cbb1a05399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a66a32f8e59470dcda68232cbb1a05399">copyConsecutiveSlices</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *t, size_t startSliceIdx)</td></tr>
<tr class="separator:a66a32f8e59470dcda68232cbb1a05399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944ce87f0c192971b423b5fe93baaa9"><td class="memTemplParams" colspan="2">template&lt;typename DestElemType , typename SrcElemType &gt; </td></tr>
<tr class="memitem:ae944ce87f0c192971b423b5fe93baaa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#ae944ce87f0c192971b423b5fe93baaa9">copyWithCast</a> (const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *t)</td></tr>
<tr class="separator:ae944ce87f0c192971b423b5fe93baaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68745fea2e9158f33b0254db7e14be9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a68745fea2e9158f33b0254db7e14be9a">convertToType</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> newTy)</td></tr>
<tr class="separator:a68745fea2e9158f33b0254db7e14be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65f889cbe5429225fe9d2ffe431a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a5a65f889cbe5429225fe9d2ffe431a38">getCopyConvertedToType</a> (<a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> newKind) const</td></tr>
<tr class="separator:a5a65f889cbe5429225fe9d2ffe431a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111b8eb06a33746bdd520931f940b520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a111b8eb06a33746bdd520931f940b520">transpose</a> (<a class="el" href="classglow_1_1_tensor.html">Tensor</a> *dest, llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt; shuffle) const</td></tr>
<tr class="separator:a111b8eb06a33746bdd520931f940b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba0d361088018e1cb85a34e5e75b4f5"><td class="memItemLeft" align="right" valign="top"><a id="a4ba0d361088018e1cb85a34e5e75b4f5"></a>
<a class="el" href="classglow_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a4ba0d361088018e1cb85a34e5e75b4f5">clone</a> () const</td></tr>
<tr class="memdesc:a4ba0d361088018e1cb85a34e5e75b4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new copy of the current tensor. <br /></td></tr>
<tr class="separator:a4ba0d361088018e1cb85a34e5e75b4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82545ea7f472278da9479508f1018d18"><td class="memItemLeft" align="right" valign="top"><a id="a82545ea7f472278da9479508f1018d18"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a82545ea7f472278da9479508f1018d18">getUnsafePtr</a> () const</td></tr>
<tr class="memdesc:a82545ea7f472278da9479508f1018d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw unsafe pointer to the tensor payload. <br /></td></tr>
<tr class="separator:a82545ea7f472278da9479508f1018d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3145589191c1d1a4fd79f5c2f1215860"><td class="memTemplParams" colspan="2">template&lt;class ElemTy  = float&gt; </td></tr>
<tr class="memitem:a3145589191c1d1a4fd79f5c2f1215860"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a3145589191c1d1a4fd79f5c2f1215860">getHandle</a> () &amp;</td></tr>
<tr class="separator:a3145589191c1d1a4fd79f5c2f1215860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd750d3ec78725e4629479519430807"><td class="memTemplParams" colspan="2"><a id="acbd750d3ec78725e4629479519430807"></a>
template&lt;class ElemTy  = float&gt; </td></tr>
<tr class="memitem:acbd750d3ec78725e4629479519430807"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getHandle</b> () const &amp;</td></tr>
<tr class="separator:acbd750d3ec78725e4629479519430807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d10a5548da1a2bea1f4c52874ddf41c"><td class="memTemplParams" colspan="2"><a id="a2d10a5548da1a2bea1f4c52874ddf41c"></a>
template&lt;class ElemTy  = float&gt; </td></tr>
<tr class="memitem:a2d10a5548da1a2bea1f4c52874ddf41c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglow_1_1_tensor.html#a2d10a5548da1a2bea1f4c52874ddf41c">getHandle</a> () &amp;&amp;=delete</td></tr>
<tr class="memdesc:a2d10a5548da1a2bea1f4c52874ddf41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> is rvalue, it is an error to get its <a class="el" href="classglow_1_1_handle.html">Handle</a>. <br /></td></tr>
<tr class="separator:a2d10a5548da1a2bea1f4c52874ddf41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3145589191c1d1a4fd79f5c2f1215860"><td class="memTemplParams" colspan="2"><a id="a3145589191c1d1a4fd79f5c2f1215860"></a>
template&lt;class ElemTy &gt; </td></tr>
<tr class="memitem:a3145589191c1d1a4fd79f5c2f1215860"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getHandle</b> () &amp;</td></tr>
<tr class="separator:a3145589191c1d1a4fd79f5c2f1215860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd750d3ec78725e4629479519430807"><td class="memTemplParams" colspan="2"><a id="acbd750d3ec78725e4629479519430807"></a>
template&lt;class ElemTy &gt; </td></tr>
<tr class="memitem:acbd750d3ec78725e4629479519430807"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classglow_1_1_handle.html">Handle</a>&lt; ElemTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getHandle</b> () const &amp;</td></tr>
<tr class="separator:acbd750d3ec78725e4629479519430807"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a67ca1a2d91273eaf85fb3d23ba8ce984"><td class="memTemplParams" colspan="2"><a id="a67ca1a2d91273eaf85fb3d23ba8ce984"></a>
template&lt;class ElemTy &gt; </td></tr>
<tr class="memitem:a67ca1a2d91273eaf85fb3d23ba8ce984"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Handle</b></td></tr>
<tr class="separator:a67ca1a2d91273eaf85fb3d23ba8ce984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that represents a contiguous n-dimensional array (a tensor). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a647b7d8c649846c034297a04d4c3680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647b7d8c649846c034297a04d4c3680b">&#9670;&nbsp;</a></span>Tensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glow::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglow_1_1_type.html">TypeRef</a>&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unpaddedSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an unowned tensor provided an existing payload buffer. This constructor can be used when there is a need to work with "externally" managed payload buffers using <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> APIs. Additionally <code>unpaddedSize</code> can be set to indicate actual size of the inputs. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72f7219f5e4e926d953fd1dc674ff7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f7219f5e4e926d953fd1dc674ff7c0">&#9670;&nbsp;</a></span>actualSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t glow::Tensor::actualSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the actual number of elements in the tensor taking striding into account. Since <a class="el" href="classglow_1_1_tensor.html#a131eef055527823adf306e8928d4ae04">size()</a> does not take striding into account, <a class="el" href="classglow_1_1_tensor.html#a131eef055527823adf306e8928d4ae04">size()</a> is always &lt;= <a class="el" href="classglow_1_1_tensor.html#a72f7219f5e4e926d953fd1dc674ff7c0">actualSize()</a>. </dd></dl>

</div>
</div>
<a id="a68745fea2e9158f33b0254db7e14be9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68745fea2e9158f33b0254db7e14be9a">&#9670;&nbsp;</a></span>convertToType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tensor::convertToType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>newTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert each element of this tensor to <code>newTy</code>. Calls into <a class="el" href="classglow_1_1_tensor.html#a5a65f889cbe5429225fe9d2ffe431a38">getCopyConvertedToType()</a> to do the conversion, and hence supports converting between whatever ElemKinds it supports. </p>

</div>
</div>
<a id="a66a32f8e59470dcda68232cbb1a05399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a32f8e59470dcda68232cbb1a05399">&#9670;&nbsp;</a></span>copyConsecutiveSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::copyConsecutiveSlices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startSliceIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the content of the tensor with a sequence of slices from the tensor <code>t</code>. A slice is one index from the first dimension of the tensor. The copying operation may overlap the end of the tensor <code>t</code> one or more times. This means that the data in the input tensor may be duplicated. </p>

</div>
</div>
<a id="a2859b4783c2e9c2a661d5d52754147df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2859b4783c2e9c2a661d5d52754147df">&#9670;&nbsp;</a></span>copySlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::copySlice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the content of the tensor with a slice from tensor <code>t</code>. A slice is one index from the first dimension of the tensor. </p>

</div>
</div>
<a id="ae944ce87f0c192971b423b5fe93baaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944ce87f0c192971b423b5fe93baaa9">&#9670;&nbsp;</a></span>copyWithCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DestElemType , typename SrcElemType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::copyWithCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience method to copy the content of <code>t</code> to this while both have different underlying types. This copy will read each element of <code>t</code> as SrcElemType and cast them to DestElemType in this. </p>

</div>
</div>
<a id="ad299b107d8ed92bb55392c4cb97070d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad299b107d8ed92bb55392c4cb97070d9">&#9670;&nbsp;</a></span>dims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::ArrayRef&lt;size_t&gt; glow::Tensor::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of the tensor. </dd></dl>

</div>
</div>
<a id="ac67a66dc3db1ac2e30c341552e93e20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67a66dc3db1ac2e30c341552e93e20d">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tensor::dump </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxNumElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump a textual representation of a specific number of elements in the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> into provided output stream. </p>

</div>
</div>
<a id="afb64938f01ec86bb60020eebb1edf4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb64938f01ec86bb60020eebb1edf4e1">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tensor::dump </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxNumElem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump a textual representation of a specific number of elements in the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> into default output stream. </p>

</div>
</div>
<a id="a5a65f889cbe5429225fe9d2ffe431a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a65f889cbe5429225fe9d2ffe431a38">&#9670;&nbsp;</a></span>getCopyConvertedToType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> Tensor::getCopyConvertedToType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a>&#160;</td>
          <td class="paramname"><em>newKind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a copy of the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> but converted to <code>newKind</code>. Currently supports conversion for:<ul>
<li>FloatTy to Float16Ty</li>
<li>Float16Ty to FloatTy</li>
<li>UInt8FusedQTy to UInt8FusedFP16QTy </li>
</ul>
</dd></dl>

</div>
</div>
<a id="affaeb77d2037ea76e6deea21a13c39dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaeb77d2037ea76e6deea21a13c39dc">&#9670;&nbsp;</a></span>getElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceglow.html#ab92e14a94329daf4083db670e95fbcdf">ElemKind</a> glow::Tensor::getElementType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the element type of the tensor. </dd></dl>

</div>
</div>
<a id="a3145589191c1d1a4fd79f5c2f1215860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3145589191c1d1a4fd79f5c2f1215860">&#9670;&nbsp;</a></span>getHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElemTy  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_handle.html">Handle</a>&lt;ElemTy&gt; glow::Tensor::getHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a new handle that points and manages this tensor. </dd></dl>

</div>
</div>
<a id="aa2559af82f20a58b5e9da6d136a0684e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2559af82f20a58b5e9da6d136a0684e">&#9670;&nbsp;</a></span>getOwnedSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> glow::Tensor::getOwnedSlice </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="classglow_1_1_tensor.html#a2b71346a672215c780ec46d1925c6d03">getUnowned()</a> but it produces an owned tensor instead. </p><dl class="section return"><dt>Returns</dt><dd>owned tensor copied from the data buffer of the current tensor but having different dimensions <code>dims</code>. <code>offsets</code> represents an optional offset into the tensor representing the location of the first element to start a subview from. </dd></dl>

</div>
</div>
<a id="a62651514d8a45c6633948a87a1766e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62651514d8a45c6633948a87a1766e56">&#9670;&nbsp;</a></span>getOwningPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tensor_pool.html">TensorPool</a>* glow::Tensor::getOwningPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classglow_1_1_tensor_pool.html">TensorPool</a> managing this object, or nullptr if it is unmanaged. </dd></dl>

</div>
</div>
<a id="a5ef091fe78b378595f2ce3adf32b1821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef091fe78b378595f2ce3adf32b1821">&#9670;&nbsp;</a></span>getSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t glow::Tensor::getSizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to store the tensor. </dd></dl>

</div>
</div>
<a id="aeb7622d21d76d06f4628386c9a2db733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7622d21d76d06f4628386c9a2db733">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structglow_1_1_type.html">Type</a>&amp; glow::Tensor::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the type of the tensor. </dd></dl>

</div>
</div>
<a id="a2b71346a672215c780ec46d1925c6d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b71346a672215c780ec46d1925c6d03">&#9670;&nbsp;</a></span>getUnowned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> glow::Tensor::getUnowned </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>unowned tensor using the same data buffer as the current tensor but having different dimensions <code>dims</code>. <code>offsets</code> represents an optional offset into the tensor representing the location of the first element to start a subview from. The returned unonwed tensor is essentially a different view or subview on the same data.</dd></dl>
<p>The lifetime of the returned unowned tensor should be always within the lifetime of its parent tensor, i.e. the unowned tensor should not outlive its parent tensor. </p>

</div>
</div>
<a id="a785ff21009c869e55c614a740c14de6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785ff21009c869e55c614a740c14de6f">&#9670;&nbsp;</a></span>getUnpaddedSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Tensor::getUnpaddedSizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the unpadded memory region. If unpaddedSize_ is not set return the size of the entire payload. </dd></dl>

</div>
</div>
<a id="a57bee99ef7a8498018fe4471574a10e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bee99ef7a8498018fe4471574a10e9">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tensor::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html#a20209a68c0539dfff33c065fe8358073">InitKind</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglow_1_1_pseudo_r_n_g.html">PseudoRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>PRNG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the content of the tensor using the <code>init</code> method. The value <code>val</code> is the initialization parameter. <code>PRNG</code> is used to generate random numbers. Note that if the tensor's kind is Fused, then the fused scaled/offsets will not be modified. </p>

</div>
</div>
<a id="a9e4db56127af74adb5d9d6315bd6813c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4db56127af74adb5d9d6315bd6813c">&#9670;&nbsp;</a></span>isBitwiseEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::Tensor::isBitwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the content of the other tensor <code>other</code> is bitwise identical to this one. </dd></dl>

</div>
</div>
<a id="adc8169ad48bdffbd2e8fa18b914cc73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8169ad48bdffbd2e8fa18b914cc73a">&#9670;&nbsp;</a></span>isEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::Tensor::isEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>allowedError</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the content of the other tensor <code>other</code> is identical to this one, given some <code>allowedError</code>. If <code>verbose</code> and the tensors are not equal, then we will log information about the mismatch (number of elements exceeding allowed error; maximum error and location found; etc.). </dd></dl>

</div>
</div>
<a id="ac6a74e37ff3771b581afc94291899f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a74e37ff3771b581afc94291899f20">&#9670;&nbsp;</a></span>isInBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::Tensor::isInBounds </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the coordinate is within the array. </dd></dl>

</div>
</div>
<a id="a574b58e799067a444cb639d0e7791b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574b58e799067a444cb639d0e7791b47">&#9670;&nbsp;</a></span>isUnowned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool glow::Tensor::isUnowned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if it is an unowned tensor. </dd></dl>

</div>
</div>
<a id="a683bda6d887705f654f3dab72cd384a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683bda6d887705f654f3dab72cd384a8">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases the data buffer and sets the unOwned flag to true. This is useful for keeping metadata around but not the actual contents. </p>

</div>
</div>
<a id="aac6a485f0e461c1be799b7b8ad3b985e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6a485f0e461c1be799b7b8ad3b985e">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the shape and type of this tensor to match the shape and type of <code>other</code>. </p>

</div>
</div>
<a id="a131eef055527823adf306e8928d4ae04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131eef055527823adf306e8928d4ae04">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t glow::Tensor::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of real meaningful elements in the tensor. Does not take strides into account. </dd></dl>

</div>
</div>
<a id="a306995cc2d51a2676bef62bca462e2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306995cc2d51a2676bef62bca462e2c4">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Tensor::toString </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxNumElem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump a textual representation of a specific number of elements in the <a class="el" href="classglow_1_1_tensor.html" title="A class that represents a contiguous n-dimensional array (a tensor). ">Tensor</a> to std::string. </p>

</div>
</div>
<a id="a111b8eb06a33746bdd520931f940b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111b8eb06a33746bdd520931f940b520">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglow_1_1_tensor.html">Tensor</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; <a class="el" href="namespaceglow.html#a0ca574644e1e42ef193a9947fb4d8911">unsigned_t</a> &gt;&#160;</td>
          <td class="paramname"><em>shuffle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transpose the tensor <code>src</code> into the empty tensor <code>dest</code>. Shuffle the axis based on the list <code>shuffle</code>, where each element is the src index. </p>

</div>
</div>
<a id="ab55a3efa21c06448d41b445520aaef42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a3efa21c06448d41b445520aaef42">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glow::Tensor::zero </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetFusedScalesOffsets</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the content of the tensor to zero. If <code>resetFusedScalesOffsets</code>, then fused scales/offsets will be set to 1.0/0.0 as well. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/glow/Base/<a class="el" href="_tensor_8h_source.html">Tensor.h</a></li>
<li>lib/Base/Tensor.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
