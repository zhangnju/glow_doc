\hypertarget{namespaceglow}{}\section{glow Namespace Reference}
\label{namespaceglow}\index{glow@{glow}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceglow_1_1_arithmetic_node}{Arithmetic\+Node}
\item 
 \hyperlink{namespaceglow_1_1detail}{detail}
\begin{DoxyCompactList}\small\item\em Forward declarations. \end{DoxyCompactList}\item 
 \hyperlink{namespaceglow_1_1tagged__list__details}{tagged\+\_\+list\+\_\+details}
\begin{DoxyCompactList}\small\item\em Namespace of \hyperlink{classglow_1_1_tagged_list}{Tagged\+List} implementation details. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classglow_1_1_adaptive_avg_pool_grad_inst}{Adaptive\+Avg\+Pool\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_adaptive_avg_pool_grad_node}{Adaptive\+Avg\+Pool\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_adaptive_avg_pool_inst}{Adaptive\+Avg\+Pool\+Inst}
\item 
class \hyperlink{classglow_1_1_adaptive_avg_pool_node}{Adaptive\+Avg\+Pool\+Node}
\begin{DoxyCompactList}\small\item\em Performs an Adaptive Average Pool operation on the Input given. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_add_grad_node}{Add\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_add_node}{Add\+Node}
\begin{DoxyCompactList}\small\item\em Performs Add on the L\+HS and R\+HS operands. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_alloc_activation_inst}{Alloc\+Activation\+Inst}
\item 
struct \hyperlink{structglow_1_1_allocations_info}{Allocations\+Info}
\item 
class \hyperlink{classglow_1_1_arg_max_inst}{Arg\+Max\+Inst}
\item 
class \hyperlink{classglow_1_1_arg_max_node}{Arg\+Max\+Node}
\begin{DoxyCompactList}\small\item\em Finds index of a maximum element along Axis.\+If Keep\+Dims is not true, the axis is removed from output. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_avg_pool_grad_inst}{Avg\+Pool\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_avg_pool_grad_node}{Avg\+Pool\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_avg_pool_inst}{Avg\+Pool\+Inst}
\item 
class \hyperlink{classglow_1_1_avg_pool_node}{Avg\+Pool\+Node}
\begin{DoxyCompactList}\small\item\em Performs an Average Pool operation on the Input given provided Kernels, Strides, and Pads. Supported layouts are defined in the Convolution\+Layout enum\+: N\+H\+WC and N\+C\+HW. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_backend}{Backend}
\item 
struct \hyperlink{structglow_1_1_backend_hints}{Backend\+Hints}
\begin{DoxyCompactList}\small\item\em Hints provided to the \hyperlink{classglow_1_1_backend}{Backend}, the backend is not required to honor them. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_backend_info}{Backend\+Info}
\item 
struct \hyperlink{structglow_1_1_backend_options}{Backend\+Options}
\begin{DoxyCompactList}\small\item\em Options relevant to Backends during compilation. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_backend_using_glow_i_r}{Backend\+Using\+Glow\+IR}
\item 
class \hyperlink{classglow_1_1_base_factory}{Base\+Factory}
\item 
class \hyperlink{classglow_1_1_batch_box_cox_node}{Batch\+Box\+Cox\+Node}
\begin{DoxyCompactList}\small\item\em Apply box-\/cox transform for each column for each column in NxD input tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batched_add_inst}{Batched\+Add\+Inst}
\item 
class \hyperlink{classglow_1_1_batched_add_node}{Batched\+Add\+Node}
\begin{DoxyCompactList}\small\item\em Adds the \textquotesingle{}Slice\textquotesingle{} operand to each one of the slices in the batch. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batched_reduce_add_inst}{Batched\+Reduce\+Add\+Inst}
\item 
class \hyperlink{classglow_1_1_batched_reduce_add_node}{Batched\+Reduce\+Add\+Node}
\begin{DoxyCompactList}\small\item\em Accumulates all of the layers in the batch and produce a tensor that has the same dimensions as the input tensor without the first dimension. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batched_reduce_mean_node}{Batched\+Reduce\+Mean\+Node}
\begin{DoxyCompactList}\small\item\em Performs Average Mean operation on the Input given Axes. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batched_reduce_min_inst}{Batched\+Reduce\+Min\+Inst}
\item 
class \hyperlink{classglow_1_1_batched_reduce_min_node}{Batched\+Reduce\+Min\+Node}
\begin{DoxyCompactList}\small\item\em Performs Reduce Min operation on the Input given Axes. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batch_mat_mul_node}{Batch\+Mat\+Mul\+Node}
\begin{DoxyCompactList}\small\item\em Performs batch matrix multiplication between the L\+HS and R\+HS. The operands are a stack of two dimensional matrices. Example\+: (N, A, Z) x (N, Z, B) =$>$ (N, A, B) \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batch_normalization_grad_node}{Batch\+Normalization\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_batch_normalization_node}{Batch\+Normalization\+Node}
\begin{DoxyCompactList}\small\item\em Performs batch normalization on the Input tensor with the provided Scale, Bias, Mean, Var, Channel\+Idx, Epsilon, and Momentum. Similar to Caffe2 Spatial\+BN, and O\+N\+NX Batch\+Normalization operator. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_batch_one_hot_inst}{Batch\+One\+Hot\+Inst}
\item 
class \hyperlink{classglow_1_1_batch_one_hot_node}{Batch\+One\+Hot\+Node}
\begin{DoxyCompactList}\small\item\em Expands each row of the Data to a row of zeros and ones, according to One Hot Encoding. i-\/th element of Result\textquotesingle{}s row is one iff Values\mbox{[}i\mbox{]} equals to the corresponding element of Data. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_block_stream}{Block\+Stream}
\item 
class \hyperlink{classglow_1_1_bound_interpreter_function}{Bound\+Interpreter\+Function}
\begin{DoxyCompactList}\small\item\em An \hyperlink{classglow_1_1_interpreter_function}{Interpreter\+Function} bound to a specific invocation. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_bucketize_node}{Bucketize\+Node}
\begin{DoxyCompactList}\small\item\em Performs bucketization on the input given Boundaries. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_bundle_saver}{Bundle\+Saver}
\item 
class \hyperlink{classglow_1_1_caffe2_model_loader}{Caffe2\+Model\+Loader}
\begin{DoxyCompactList}\small\item\em Loads \hyperlink{namespacecaffe2}{caffe2} models. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_channel_shuffle_node}{Channel\+Shuffle\+Node}
\begin{DoxyCompactList}\small\item\em Performs Channel shuffle. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_channelwise_quantized_convolution_inst}{Channelwise\+Quantized\+Convolution\+Inst}
\item 
class \hyperlink{classglow_1_1_channelwise_quantized_convolution_node}{Channelwise\+Quantized\+Convolution\+Node}
\begin{DoxyCompactList}\small\item\em Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, and Group. Quantization parameters are provided by Scales and Offsets. If Groupwise is true then the quantization is per-\/group otherwise it is per-\/channel. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_child_mem_size_based_scheduler}{Child\+Mem\+Size\+Based\+Scheduler}
\item 
class \hyperlink{classglow_1_1_clip_node}{Clip\+Node}
\begin{DoxyCompactList}\small\item\em Clip range of inputs to lie in \mbox{[}Min, Max\mbox{]}. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_cmp_e_q_node}{Cmp\+E\+Q\+Node}
\begin{DoxyCompactList}\small\item\em Performs an element-\/wise equal comparison on the L\+HS and R\+HS operands. Inputs must be integer. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_cmp_l_t_e_node}{Cmp\+L\+T\+E\+Node}
\begin{DoxyCompactList}\small\item\em Performs Cmp\+L\+TE on the L\+HS and R\+HS operands. Generates a mask that\textquotesingle{}s consumed by the select instruction. The format of the result is target-\/ and type-\/specific. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_cmp_l_t_node}{Cmp\+L\+T\+Node}
\begin{DoxyCompactList}\small\item\em Compares X and Y element wise sets Dest\mbox{[}i\mbox{]} true if L\+HS\mbox{[}i\mbox{]} $<$ R\+HS\mbox{[}i\mbox{]} otherwise false. Final result is a mask consumed by Select, O\+N\+NX Where, operator. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_common_operator_loader}{Common\+Operator\+Loader}
\item 
class \hyperlink{classglow_1_1_common_operator_writer}{Common\+Operator\+Writer}
\item 
struct \hyperlink{structglow_1_1_compare_operator_equal}{Compare\+Operator\+Equal}
\begin{DoxyCompactList}\small\item\em Operator ==. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_compare_operator_greater_equal}{Compare\+Operator\+Greater\+Equal}
\begin{DoxyCompactList}\small\item\em Operator $>$=. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_compare_operator_greater_than}{Compare\+Operator\+Greater\+Than}
\begin{DoxyCompactList}\small\item\em Operator $>$. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_compare_operator_less_equal}{Compare\+Operator\+Less\+Equal}
\begin{DoxyCompactList}\small\item\em Operator $<$=. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_compare_with_name}{Compare\+With\+Name}
\begin{DoxyCompactList}\small\item\em Interface that the comparison operator must implement. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context}
\begin{DoxyCompactList}\small\item\em Context for compilation. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_compiled_function}{Compiled\+Function}
\begin{DoxyCompactList}\small\item\em Interface for executing a compiled function. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_concat_node}{Concat\+Node}
\item 
class \hyperlink{classglow_1_1_constant}{Constant}
\item 
class \hyperlink{classglow_1_1_convert_to_inst}{Convert\+To\+Inst}
\item 
class \hyperlink{classglow_1_1_convert_to_node}{Convert\+To\+Node}
\begin{DoxyCompactList}\small\item\em Convert the input from its current type to the destination type. The input and output types must have the same shapes. Moreover the input and output types must not be quantized types. Quantized types should use the appropriate Quantize, Dequantize, and Rescale nodes. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_convolution3_d_grad_inst}{Convolution3\+D\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_convolution3_d_grad_node}{Convolution3\+D\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_convolution3_d_inst}{Convolution3\+D\+Inst}
\item 
class \hyperlink{classglow_1_1_convolution3_d_node}{Convolution3\+D\+Node}
\begin{DoxyCompactList}\small\item\em Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, and Group. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_convolution_grad_inst}{Convolution\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_convolution_grad_node}{Convolution\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_convolution_inst}{Convolution\+Inst}
\item 
class \hyperlink{classglow_1_1_convolution_node}{Convolution\+Node}
\begin{DoxyCompactList}\small\item\em Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, Group and Dilation. Supported Layouts are defined in the Convolution\+Layout enum\+: N\+H\+WC and N\+C\+HW. Supported Fused\+Activations are defined in the Fused\+Activation enum. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_copy_inst}{Copy\+Inst}
\item 
class \hyperlink{classglow_1_1_c_p_u_backend}{C\+P\+U\+Backend}
\item 
class \hyperlink{classglow_1_1_c_p_u_conv_d_k_k_c8_inst}{C\+P\+U\+Conv\+D\+K\+K\+C8\+Inst}
\item 
class \hyperlink{classglow_1_1_c_p_u_conv_d_k_k_c8_node}{C\+P\+U\+Conv\+D\+K\+K\+C8\+Node}
\begin{DoxyCompactList}\small\item\em This is a cpu-\/specific convolution implementation where the filter is transposed to the shape \mbox{[}D/8, K, K, C, 8\mbox{]}. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_c_p_u_function}{C\+P\+U\+Function}
\begin{DoxyCompactList}\small\item\em A Glow IR function compiled for the C\+PU using L\+L\+VM. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_c_p_u_l_l_v_m_i_r_gen}{C\+P\+U\+L\+L\+V\+M\+I\+R\+Gen}
\item 
class \hyperlink{classglow_1_1_c_p_u_max_splat_inst}{C\+P\+U\+Max\+Splat\+Inst}
\item 
class \hyperlink{classglow_1_1_c_p_u_max_splat_node}{C\+P\+U\+Max\+Splat\+Node}
\begin{DoxyCompactList}\small\item\em A Max node with one splat input; C\+PU specific. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_cross_entropy_loss_grad_inst}{Cross\+Entropy\+Loss\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_cross_entropy_loss_grad_node}{Cross\+Entropy\+Loss\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_cross_entropy_loss_inst}{Cross\+Entropy\+Loss\+Inst}
\item 
class \hyperlink{classglow_1_1_cross_entropy_loss_node}{Cross\+Entropy\+Loss\+Node}
\begin{DoxyCompactList}\small\item\em Computes the average cross entropy loss of the input. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_dealloc_activation_inst}{Dealloc\+Activation\+Inst}
\item 
struct \hyperlink{structglow_1_1_debug_info}{Debug\+Info}
\begin{DoxyCompactList}\small\item\em A P\+OD struct that stores information related to debug info. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_debug_print_inst}{Debug\+Print\+Inst}
\item 
class \hyperlink{classglow_1_1_dequantize_inst}{Dequantize\+Inst}
\item 
class \hyperlink{classglow_1_1_dequantize_node}{Dequantize\+Node}
\begin{DoxyCompactList}\small\item\em Convert quantized input tensor into the float representation. x = Scale $\ast$ (x\+\_\+q -\/ Offset). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_description_builder}{Description\+Builder}
\begin{DoxyCompactList}\small\item\em A helper class that builds a textual descriptor of a group of parameters. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_device_bindings}{Device\+Bindings}
\item 
struct \hyperlink{structglow_1_1_device_config_helper}{Device\+Config\+Helper}
\begin{DoxyCompactList}\small\item\em Data structure used to read the yaml file for Device Configs. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_div_grad_node}{Div\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_div_node}{Div\+Node}
\begin{DoxyCompactList}\small\item\em Performs Div on the L\+HS and R\+HS operands. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_element_add_inst}{Element\+Add\+Inst}
\item 
class \hyperlink{classglow_1_1_element_cmp_e_q_inst}{Element\+Cmp\+E\+Q\+Inst}
\item 
class \hyperlink{classglow_1_1_element_cmp_l_t_e_inst}{Element\+Cmp\+L\+T\+E\+Inst}
\item 
class \hyperlink{classglow_1_1_element_cmp_l_t_inst}{Element\+Cmp\+L\+T\+Inst}
\item 
class \hyperlink{classglow_1_1_element_div_inst}{Element\+Div\+Inst}
\item 
class \hyperlink{classglow_1_1_element_exp_inst}{Element\+Exp\+Inst}
\item 
class \hyperlink{classglow_1_1_element_is_na_n_inst}{Element\+Is\+Na\+N\+Inst}
\item 
class \hyperlink{classglow_1_1_element_log_inst}{Element\+Log\+Inst}
\item 
class \hyperlink{classglow_1_1_element_max_inst}{Element\+Max\+Inst}
\item 
class \hyperlink{classglow_1_1_element_min_inst}{Element\+Min\+Inst}
\item 
class \hyperlink{classglow_1_1_element_mul_inst}{Element\+Mul\+Inst}
\item 
class \hyperlink{classglow_1_1_element_pow_inst}{Element\+Pow\+Inst}
\item 
class \hyperlink{classglow_1_1_element_select_inst}{Element\+Select\+Inst}
\item 
class \hyperlink{classglow_1_1_element_sub_inst}{Element\+Sub\+Inst}
\item 
class \hyperlink{classglow_1_1_execution_context}{Execution\+Context}
\item 
class \hyperlink{classglow_1_1_execution_engine}{Execution\+Engine}
\item 
class \hyperlink{classglow_1_1_exp_node}{Exp\+Node}
\begin{DoxyCompactList}\small\item\em Performs element-\/wise exponential to the Input. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_extract_tensor_inst}{Extract\+Tensor\+Inst}
\item 
class \hyperlink{classglow_1_1_factory_registry}{Factory\+Registry}
\item 
class \hyperlink{classglow_1_1_file_adapter}{File\+Adapter}
\item 
class \hyperlink{classglow_1_1float16}{float16}
\item 
class \hyperlink{classglow_1_1_fully_connected_grad_node}{Fully\+Connected\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_fully_connected_node}{Fully\+Connected\+Node}
\begin{DoxyCompactList}\small\item\em Creates a Fully\+Connected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_function}{Function}
\begin{DoxyCompactList}\small\item\em Represents the compute graph. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_function_converter}{Function\+Converter}
\item 
struct \hyperlink{structglow_1_1_function_name_comparator}{Function\+Name\+Comparator}
\item 
class \hyperlink{classglow_1_1_function_pass}{Function\+Pass}
\item 
class \hyperlink{classglow_1_1_function_pass_config}{Function\+Pass\+Config}
\item 
class \hyperlink{classglow_1_1_function_pass_manager}{Function\+Pass\+Manager}
\item 
class \hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline}
\begin{DoxyCompactList}\small\item\em Implementation of a pipeline for executing a series of Function\+Passes. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node}{Fused\+Rowwise\+Quantized\+Sparse\+Lengths\+Sum\+Node}
\begin{DoxyCompactList}\small\item\em Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). The input data is fused rowwise-\/quantized, where the Scales and Offsets are appended to the end of each row. Thus, Data must be a two-\/dimensional tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_inst}{Fused\+Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Inst}
\item 
class \hyperlink{classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node}{Fused\+Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Node}
\begin{DoxyCompactList}\small\item\em Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices). The input data is fused rowwise-\/quantized, where the Scales and Offsets are appended to the end of each row. Thus, Data must be a two-\/dimensional tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_gather_inst}{Gather\+Inst}
\item 
class \hyperlink{classglow_1_1_gather_node}{Gather\+Node}
\begin{DoxyCompactList}\small\item\em Gathers entries of the outer-\/most dimension of Data indexed by Indices, and concatenates them. Output tensor will have dimensions\+: \{I\+\_\+0, I\+\_\+1, ... I\+\_\+n, D\+\_\+1, D\+\_\+2, ... D\+\_\+m\}, where D\+\_\+i and I\+\_\+j denote Data and Indices dimensions respectively. If batch\+Dims is not zero, the gather operator will treat the first batch\+Dims as the batch and will concat the result of the gather operation on each sample in the batch. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_gather_ranges_inst}{Gather\+Ranges\+Inst}
\item 
class \hyperlink{classglow_1_1_gather_ranges_node}{Gather\+Ranges\+Node}
\begin{DoxyCompactList}\small\item\em Gathers entries of Data into Output in groups specified by the elements of Ranges. Each element of Ranges contains a list of pairs of indices of the form (index, length) which specify which entries of data to gather. The ordering of elements in Ranges and of pairs within an element is preserved in Output. Lengths contains the lengths of the ranges gathered by each list of pairs in Ranges. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_graph_grad_mapper}{Graph\+Grad\+Mapper}
\item 
struct \hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info}
\begin{DoxyCompactList}\small\item\em The memory usage of a subgraph (i.\+e. a list of nodes of a function). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_graph_post_order_visitor}{Graph\+Post\+Order\+Visitor}
\begin{DoxyCompactList}\small\item\em A helper class for ordering Graph nodes in a post-\/order order. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_graph_pre_order_visitor}{Graph\+Pre\+Order\+Visitor}
\begin{DoxyCompactList}\small\item\em A helper class for ordering Graph nodes in a pre-\/order order. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_habana_backend}{Habana\+Backend}
\item 
class \hyperlink{classglow_1_1_habana_bindings}{Habana\+Bindings}
\item 
class \hyperlink{classglow_1_1_habana_function}{Habana\+Function}
\item 
class \hyperlink{classglow_1_1_habana_i_o_buffer}{Habana\+I\+O\+Buffer}
\item 
class \hyperlink{classglow_1_1_habana_i_o_buffer_pool}{Habana\+I\+O\+Buffer\+Pool}
\item 
class \hyperlink{classglow_1_1_habana_wait_handle}{Habana\+Wait\+Handle}
\item 
class \hyperlink{classglow_1_1_handle}{Handle}
\item 
class \hyperlink{classglow_1_1_handle_iterator}{Handle\+Iterator}
\item 
struct \hyperlink{structglow_1_1_hooked_function}{Hooked\+Function}
\item 
class \hyperlink{classglow_1_1_i_n_n_p_i_node_importer}{I\+N\+N\+P\+I\+Node\+Importer}
\begin{DoxyCompactList}\small\item\em Interface class for all node specific importers. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_insert_tensor_inst}{Insert\+Tensor\+Inst}
\item 
class \hyperlink{classglow_1_1_insert_tensor_node}{Insert\+Tensor\+Node}
\begin{DoxyCompactList}\small\item\em Insert tensor Small into tensor Big given indices Start. Small is inserted Count times along Axis. The resulting \hyperlink{classglow_1_1_tensor}{Tensor} will have the same type as the input Big tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_instruction}{Instruction}
\begin{DoxyCompactList}\small\item\em This represents an instruction in our IR. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_instruction_numbering}{Instruction\+Numbering}
\begin{DoxyCompactList}\small\item\em A helper class used for instructions numbering. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_instruction_traits}{Instruction\+Traits}
\item 
class \hyperlink{classglow_1_1_interpreter}{Interpreter}
\item 
class \hyperlink{classglow_1_1_interpreter_function}{Interpreter\+Function}
\begin{DoxyCompactList}\small\item\em \hyperlink{classglow_1_1_function}{Function} \char`\"{}compiled\char`\"{} for execution by the interpreter. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_int_lookup_table_inst}{Int\+Lookup\+Table\+Inst}
\item 
class \hyperlink{classglow_1_1_int_lookup_table_node}{Int\+Lookup\+Table\+Node}
\begin{DoxyCompactList}\small\item\em Simple mapping between quantized numbers.\+This can be used as quantized sigmoid or tanh functions. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_i_r_builder}{I\+R\+Builder}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classglow_1_1_i_r_builder}{I\+R\+Builder} constructs the IR in the function. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function}
\begin{DoxyCompactList}\small\item\em A function that represents the compilation unit. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_i_r_gen_visitor}{I\+R\+Gen\+Visitor}
\item 
class \hyperlink{classglow_1_1_is_na_n_node}{Is\+Na\+N\+Node}
\begin{DoxyCompactList}\small\item\em Determines whether each element of the Input is NaN and generates a mask that can be consumed by a Select node. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_kernel_launch}{Kernel\+Launch}
\begin{DoxyCompactList}\small\item\em A helper struct with information about kernels launches. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_kinded}{Kinded}
\begin{DoxyCompactList}\small\item\em Subclasses of \hyperlink{classglow_1_1_value}{Value} have an enum that describe their kind. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_lengths_range_fill_inst}{Lengths\+Range\+Fill\+Inst}
\item 
class \hyperlink{classglow_1_1_lengths_range_fill_node}{Lengths\+Range\+Fill\+Node}
\begin{DoxyCompactList}\small\item\em Converts an input Lengths 1D vector into a range sequence. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_lengths_sum_inst}{Lengths\+Sum\+Inst}
\item 
class \hyperlink{classglow_1_1_lengths_sum_node}{Lengths\+Sum\+Node}
\begin{DoxyCompactList}\small\item\em Sums slices of the outermost dimension of Data in groups defined by Lengths. The first Lengths\mbox{[}0\mbox{]} slices are added together and stored in Result\mbox{[}0\mbox{]}, the subsequent Lengths\mbox{[}1\mbox{]} slices are added together and stored in Result\mbox{[}1\mbox{]}, etc. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_lengths_to_ranges_inst}{Lengths\+To\+Ranges\+Inst}
\item 
class \hyperlink{classglow_1_1_lengths_to_ranges_node}{Lengths\+To\+Ranges\+Node}
\begin{DoxyCompactList}\small\item\em Given a vector of segment lengths, calculates offsets of each segment and packs them next to the lengths. For the input vector of length N the output is a Nx2 matrix with (offset, lengths) packaged for each segment. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_l_l_v_m_backend}{L\+L\+V\+M\+Backend}
\item 
class \hyperlink{classglow_1_1_l_l_v_m_compiled_function}{L\+L\+V\+M\+Compiled\+Function}
\begin{DoxyCompactList}\small\item\em A Glow IR function compiled using L\+L\+VM. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_l_l_v_m_i_r_gen}{L\+L\+V\+M\+I\+R\+Gen}
\item 
class \hyperlink{classglow_1_1_loader}{Loader}
\item 
struct \hyperlink{structglow_1_1_load_weight_result}{Load\+Weight\+Result}
\item 
class \hyperlink{classglow_1_1_local_response_normalization_grad_inst}{Local\+Response\+Normalization\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_local_response_normalization_grad_node}{Local\+Response\+Normalization\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_local_response_normalization_inst}{Local\+Response\+Normalization\+Inst}
\item 
class \hyperlink{classglow_1_1_local_response_normalization_node}{Local\+Response\+Normalization\+Node}
\begin{DoxyCompactList}\small\item\em Performs local response normalization on the Input tensor with the provided Scale, Bias, Mean, Var, Channel\+Idx, Epsilon, and Momentum. Similar to Caffe2 and O\+N\+NX L\+RN. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_log_context}{Log\+Context}
\begin{DoxyCompactList}\small\item\em A class for logging all compilation related activities. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_log_create}{Log\+Create}
\item 
struct \hyperlink{structglow_1_1_log_delete}{Log\+Delete}
\item 
struct \hyperlink{structglow_1_1_log_event}{Log\+Event}
\item 
struct \hyperlink{structglow_1_1_log_input_change}{Log\+Input\+Change}
\item 
class \hyperlink{classglow_1_1_log_node}{Log\+Node}
\begin{DoxyCompactList}\small\item\em Performs element-\/wise natural log to the Input. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_log_scope}{Log\+Scope}
\item 
class \hyperlink{classglow_1_1_mat_mul_inst}{Mat\+Mul\+Inst}
\item 
class \hyperlink{classglow_1_1_mat_mul_node}{Mat\+Mul\+Node}
\begin{DoxyCompactList}\small\item\em Performs matrix multiplication between the L\+HS and R\+H\+S.\+Example\+: (A, Z) x (Z, B) =$>$ (A, B) \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_max_node}{Max\+Node}
\begin{DoxyCompactList}\small\item\em Performs Max on the L\+HS and R\+HS operands. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_max_pool_grad_node}{Max\+Pool\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_max_pool_inst}{Max\+Pool\+Inst}
\item 
class \hyperlink{classglow_1_1_max_pool_node}{Max\+Pool\+Node}
\begin{DoxyCompactList}\small\item\em Performs a Max Pool with Argmax operation on the Input given provided Kernels, Strides, and Pads. Argmax is a flattened index corresponding to respective max element. Supported layouts are defined in the Convolution\+Layout enum\+: N\+H\+WC and N\+C\+HW. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_max_pool_with_argmax_grad_inst}{Max\+Pool\+With\+Argmax\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_max_pool_with_argmax_inst}{Max\+Pool\+With\+Argmax\+Inst}
\item 
class \hyperlink{classglow_1_1_mean_var_normalization_node}{Mean\+Var\+Normalization\+Node}
\begin{DoxyCompactList}\small\item\em Calculates new normalized mean and variance based on the input mean, variance, and input. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_memory_allocator}{Memory\+Allocator}
\item 
class \hyperlink{classglow_1_1_min_node}{Min\+Node}
\begin{DoxyCompactList}\small\item\em Performs Min on the L\+HS and R\+HS operands. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_module}{Module}
\item 
class \hyperlink{classglow_1_1_modulo_inst}{Modulo\+Inst}
\item 
class \hyperlink{classglow_1_1_modulo_node}{Modulo\+Node}
\begin{DoxyCompactList}\small\item\em Performs elementwise modulo operation on the input where each element in the output is the corresponding element in the input data modulo Divisor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_mul_grad_node}{Mul\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_mul_node}{Mul\+Node}
\begin{DoxyCompactList}\small\item\em Performs Mul on the L\+HS and R\+HS operands. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_multi_line_str}{Multi\+Line\+Str}
\begin{DoxyCompactList}\small\item\em Data structure for multi string format used in yaml file. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_named}{Named}
\begin{DoxyCompactList}\small\item\em This add the capability to name subclasses. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_n_n_p_i_backend}{N\+N\+P\+I\+Backend}
\begin{DoxyCompactList}\small\item\em This is the Intel Neural-\/\+Network Processor for Inference (N\+N\+PI) backend. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_n_n_p_i_compiled_function}{N\+N\+P\+I\+Compiled\+Function}
\begin{DoxyCompactList}\small\item\em \hyperlink{classglow_1_1_function}{Function} \char`\"{}compiled\char`\"{} for execution by the N\+N\+PI backend. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_n_n_p_i_env_variables}{N\+N\+P\+I\+Env\+Variables}
\item 
class \hyperlink{classglow_1_1_n_n_p_i_importer}{N\+N\+P\+I\+Importer}
\begin{DoxyCompactList}\small\item\em This class imports Glow IR to the N\+N\+PI backend. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_n_n_p_i_message_logger}{N\+N\+P\+I\+Message\+Logger}
\begin{DoxyCompactList}\small\item\em N\+N\+PI logging stream controller. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_node}{Node}
\begin{DoxyCompactList}\small\item\em Represents a node in the compute graph. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_node_handle}{Node\+Handle}
\item 
class \hyperlink{classglow_1_1_node_info}{Node\+Info}
\item 
struct \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind}
\item 
struct \hyperlink{structglow_1_1_node_quantization_info}{Node\+Quantization\+Info}
\begin{DoxyCompactList}\small\item\em \hyperlink{classglow_1_1_tensor}{Tensor} quantization parameters for a given node. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map}
\item 
struct \hyperlink{structglow_1_1_node_use}{Node\+Use}
\begin{DoxyCompactList}\small\item\em A \textquotesingle{}\hyperlink{structglow_1_1_use}{Use}\textquotesingle{} is a use-\/list representation of a \hyperlink{classglow_1_1_node}{Node} operand. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_node_value}{Node\+Value}
\item 
class \hyperlink{classglow_1_1_node_value_array_ref}{Node\+Value\+Array\+Ref}
\item 
class \hyperlink{classglow_1_1_node_value_iterator_impl}{Node\+Value\+Iterator\+Impl}
\item 
class \hyperlink{classglow_1_1_node_visitor}{Node\+Visitor}
\item 
class \hyperlink{classglow_1_1_node_visitor_base}{Node\+Visitor\+Base}
\item 
class \hyperlink{classglow_1_1_node_walker}{Node\+Walker}
\begin{DoxyCompactList}\small\item\em A walker that recursively visits a node and its children. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_o_c_l_backend}{O\+C\+L\+Backend}
\begin{DoxyCompactList}\small\item\em This is the Open\+CL backend. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_one_err_only}{One\+Err\+Only}
\item 
class \hyperlink{classglow_1_1_o_n_n_x_i_f_i_model_loader}{O\+N\+N\+X\+I\+F\+I\+Model\+Loader}
\item 
class \hyperlink{classglow_1_1_o_n_n_x_model_loader}{O\+N\+N\+X\+Model\+Loader}
\begin{DoxyCompactList}\small\item\em Loads O\+N\+NX models. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_o_n_n_x_model_writer}{O\+N\+N\+X\+Model\+Writer}
\begin{DoxyCompactList}\small\item\em Writes O\+N\+NX models. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_open_c_l_function}{Open\+C\+L\+Function}
\begin{DoxyCompactList}\small\item\em A Glow IR function compiled for Open\+CL. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_optimization_options}{Optimization\+Options}
\begin{DoxyCompactList}\small\item\em Options relevant to optimizations during compilation. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_padding_t_l_b_r}{Padding\+T\+L\+BR}
\item 
struct \hyperlink{structglow_1_1_padding_t_l_n_b_r_f}{Padding\+T\+L\+N\+B\+RF}
\item 
class \hyperlink{classglow_1_1_pad_node}{Pad\+Node}
\begin{DoxyCompactList}\small\item\em Performs padding of a given input tensor. The Padding information must be specified for each dimension of the tensor in Pads (start and end padding). In case the padding is negative, it means that the tensor must be cropped. Mode defines how extra padding elements are created. Supported modes are defined in the Padding\+Mode enum\+: C\+O\+N\+S\+T\+A\+NT, R\+E\+F\+L\+E\+CT, E\+D\+GE. \hyperlink{classglow_1_1_value}{Value} is only used with the C\+O\+N\+S\+T\+A\+NT mode. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_partitioner}{Partitioner}
\item 
class \hyperlink{classglow_1_1_partitioner_base}{Partitioner\+Base}
\item 
class \hyperlink{classglow_1_1_placeholder}{Placeholder}
\item 
class \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings}
\item 
struct \hyperlink{structglow_1_1_placeholder_input_output_info}{Placeholder\+Input\+Output\+Info}
\begin{DoxyCompactList}\small\item\em Contains information for placeholder during allocation. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_post_order_visitor}{Post\+Order\+Visitor}
\begin{DoxyCompactList}\small\item\em A helper class for ordering the nodes in a post-\/order order. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_pow_node}{Pow\+Node}
\begin{DoxyCompactList}\small\item\em Performs elementwise pow(\+L\+H\+S, R\+H\+S). \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_precision_configuration}{Precision\+Configuration}
\begin{DoxyCompactList}\small\item\em Configuration for different precision modes. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_p_relu_node}{P\+Relu\+Node}
\begin{DoxyCompactList}\small\item\em Applies P\+Re\+LU, slope $\ast$ min(0, x) + max(0, x), to each element in the Input tensor. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_pre_order_visitor}{Pre\+Order\+Visitor}
\begin{DoxyCompactList}\small\item\em A helper class for ordering the nodes in a pre-\/order order. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_protobuf_loader}{Protobuf\+Loader}
\begin{DoxyCompactList}\small\item\em Loads model\+: graph and weights. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_protobuf_writer}{Protobuf\+Writer}
\begin{DoxyCompactList}\small\item\em Writes model\+: graph and weights. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_pseudo_r_n_g}{Pseudo\+R\+NG}
\item 
class \hyperlink{classglow_1_1_quantization_profile_inst}{Quantization\+Profile\+Inst}
\item 
class \hyperlink{classglow_1_1_quantization_profile_node}{Quantization\+Profile\+Node}
\begin{DoxyCompactList}\small\item\em Generate profile (distribution of values) of the Input tensor. This data is used for quantization of the tensor later on. Profiled\+Node\+Name contains the name of the node which is profiled by the Quantization\+Profile node. Profiled\+Node\+Name is helpful as lowering might transform the original graph. Profiled\+Output\+Number contains the position of the node\textquotesingle{}s output which gets profiled. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_quantization_transform32_to8}{Quantization\+Transform32\+To8}
\item 
class \hyperlink{classglow_1_1_quantize_inst}{Quantize\+Inst}
\item 
class \hyperlink{classglow_1_1_quantize_node}{Quantize\+Node}
\begin{DoxyCompactList}\small\item\em Quantize floating point tensor. This operation converts floating point numbers to integers based on the given Scale and Offset. Scale and Offset are deduced from the type of the output.\+x\+\_\+q = clip(round(x/\+Scale) + Offset, -\/128, 127) \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_register_factory}{Register\+Factory}
\item 
class \hyperlink{classglow_1_1_regression_grad_node}{Regression\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_regression_node}{Regression\+Node}
\begin{DoxyCompactList}\small\item\em Takes an Input tensor and creates a regression output layer. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_relu_grad_node}{Relu\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_relu_inst}{Relu\+Inst}
\item 
class \hyperlink{classglow_1_1_relu_node}{Relu\+Node}
\begin{DoxyCompactList}\small\item\em Applies Re\+LU, max(0, x), to each element in the Input tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_replace_na_n_node}{Replace\+Na\+N\+Node}
\begin{DoxyCompactList}\small\item\em Replaces Na\+Ns found in Input with \hyperlink{classglow_1_1_value}{Value}. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_rescale_quantized_inst}{Rescale\+Quantized\+Inst}
\item 
class \hyperlink{classglow_1_1_rescale_quantized_node}{Rescale\+Quantized\+Node}
\begin{DoxyCompactList}\small\item\em Rescale the input quantized tensor to a new Scale and Offset. The new Scale and Offset are specified by the output type passed to the constructor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_reshape_node}{Reshape\+Node}
\begin{DoxyCompactList}\small\item\em Reshape the Input tensor to shape Dims. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_resize_nearest_inst}{Resize\+Nearest\+Inst}
\item 
class \hyperlink{classglow_1_1_resize_nearest_node}{Resize\+Nearest\+Node}
\begin{DoxyCompactList}\small\item\em Given Input tensor of \mbox{[}N,H,W,C\mbox{]}, where N is the batch, C is the channel or depth, H is the height and W is the width, Generates an Output tensor with resized spatial dimensions using nearest neighbor interpolation. The Output tensor is of shape \mbox{[}N, floor(\+H$\ast$\+Height\+Scale), floor(\+W$\ast$\+Width\+Scale), C\mbox{]}. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_rowwise_quantized_fully_connected_inst}{Rowwise\+Quantized\+Fully\+Connected\+Inst}
\item 
class \hyperlink{classglow_1_1_rowwise_quantized_fully_connected_node}{Rowwise\+Quantized\+Fully\+Connected\+Node}
\begin{DoxyCompactList}\small\item\em Creates a Rowwise\+Quantized\+Fully\+Connected node where the Input matrix and the transpose of Weights matrix are multiplied, and then the Bias vector is broadcast-\/added to the result. Input, Bias and Result are regularly quantized, while Weights use row-\/wisequantization. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_inst}{Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Inst}
\item 
class \hyperlink{classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node}{Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Node}
\begin{DoxyCompactList}\small\item\em Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices). The input data is rowwise-\/quantized, where the Scales and Offsets are 1D tensors of length equal to the first dim of Data. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_save_node}{Save\+Node}
\begin{DoxyCompactList}\small\item\em Specifies a node whose Input will be copied to Output.\+This node prevents graph optimizations from eliminating this node and all of its ancestor nodes. Generally intended to save the final result of a network. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_scatter_data_inst}{Scatter\+Data\+Inst}
\item 
class \hyperlink{classglow_1_1_scatter_data_node}{Scatter\+Data\+Node}
\begin{DoxyCompactList}\small\item\em Copies each slice from Slices into Data at the corresponding index in Indices. For example, given input Data \{\{1,2\},\{3,4\},\{5,6\}\}, Slices \{\{-\/3,-\/4\}\}, and Indices \{\{1\}\}, the result is \{\{1,2\},\{-\/3,-\/4\},\{5,6\}\}. It also supports multi-\/dimensional indices. For example, given input Data \{\{1,2\},\{3,4\},\{5,6\}\}, Slices \{-\/3,-\/4\}, and Indices \{\{1,0\},\{1,1\}\} also produces \{\{1,2\},\{-\/3,-\/4\},\{5,6\}\}. If Cumulative is true, the node adds values from Slices to Data instead of copying. For example, given input Data \{\{1,2\},\{3,4\},\{5,6\}\}, Slices \{\{-\/3,-\/4\}\}, and Indices \{1\}, the result is \{\{1,2\},\{0,0\},\{5,6\}\}. If an index is specified several times, its updates will be added several times as well. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_scheduler}{Scheduler}
\item 
class \hyperlink{classglow_1_1_scoped_log_block}{Scoped\+Log\+Block}
\begin{DoxyCompactList}\small\item\em Helper class which traces the start and end of a compilation log scope. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_scoped_trace_block}{Scoped\+Trace\+Block}
\item 
class \hyperlink{classglow_1_1_segment}{Segment}
\begin{DoxyCompactList}\small\item\em A P\+OD struct that represents a single half-\/open allocation \mbox{[}start .. end). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_select_node}{Select\+Node}
\begin{DoxyCompactList}\small\item\em Selects between values on the L\+HS or R\+HS, depending on the value of Cond. Cond is generated by the compare instruction, and is target-\/ and type-\/specific. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_s_g_d_node}{S\+G\+D\+Node}
\begin{DoxyCompactList}\small\item\em Stochastic Gradient Descent node used during training. Produces the updated weight that needs to be used instead of Weight for the next iteration. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_shape_h_w}{Shape\+HW}
\item 
struct \hyperlink{structglow_1_1_shape_h_w_d}{Shape\+H\+WD}
\item 
struct \hyperlink{structglow_1_1_shape_n_c_h_w}{Shape\+N\+C\+HW}
\item 
struct \hyperlink{structglow_1_1_shape_n_h_w_c}{Shape\+N\+H\+WC}
\item 
struct \hyperlink{structglow_1_1_shape_n_h_w_d_c}{Shape\+N\+H\+W\+DC}
\item 
class \hyperlink{classglow_1_1_sigmoid_cross_entropy_with_logits_node}{Sigmoid\+Cross\+Entropy\+With\+Logits\+Node}
\begin{DoxyCompactList}\small\item\em Computes the sigmoid cross entropy between two inputs. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_sigmoid_grad_node}{Sigmoid\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_sigmoid_inst}{Sigmoid\+Inst}
\item 
class \hyperlink{classglow_1_1_sigmoid_node}{Sigmoid\+Node}
\begin{DoxyCompactList}\small\item\em Applies Sigmoid, 1 / (1 + exp(-\/x)), to each element in the Input tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_slice_node}{Slice\+Node}
\begin{DoxyCompactList}\small\item\em Produces a slice of the Input tensor. The Start vector defines the starting indices for each dimension from which the slice should be taken. The end index for each dimension is determined from the input type\textquotesingle{}s shape. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_soft_max_grad_inst}{Soft\+Max\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_soft_max_grad_node}{Soft\+Max\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_soft_max_inst}{Soft\+Max\+Inst}
\item 
class \hyperlink{classglow_1_1_soft_max_node}{Soft\+Max\+Node}
\begin{DoxyCompactList}\small\item\em Performs Soft\+Max normalization on the Input tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_space_to_depth_inst}{Space\+To\+Depth\+Inst}
\item 
class \hyperlink{classglow_1_1_space_to_depth_node}{Space\+To\+Depth\+Node}
\begin{DoxyCompactList}\small\item\em Given Input tensor of \mbox{[}N,H,W,C\mbox{]}, where N is the batch axis, C is the channel or depth, H is the height and W is the width. This produces Output tensor of \mbox{[}N, H/\+Block\+Size, W/\+Block\+Size, C $\ast$ Block\+Size $\ast$ Block\+Size\mbox{]}. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_sparse_lengths_sum_inst}{Sparse\+Lengths\+Sum\+Inst}
\item 
class \hyperlink{classglow_1_1_sparse_lengths_sum_node}{Sparse\+Lengths\+Sum\+Node}
\begin{DoxyCompactList}\small\item\em Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_sparse_lengths_weighted_sum_grad_inst}{Sparse\+Lengths\+Weighted\+Sum\+Grad\+Inst}
\item 
class \hyperlink{classglow_1_1_sparse_lengths_weighted_sum_grad_node}{Sparse\+Lengths\+Weighted\+Sum\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_sparse_lengths_weighted_sum_inst}{Sparse\+Lengths\+Weighted\+Sum\+Inst}
\item 
class \hyperlink{classglow_1_1_sparse_lengths_weighted_sum_node}{Sparse\+Lengths\+Weighted\+Sum\+Node}
\begin{DoxyCompactList}\small\item\em Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_sparse_lengths_weighted_sum_offsets_inst}{Sparse\+Lengths\+Weighted\+Sum\+Offsets\+Inst}
\item 
class \hyperlink{classglow_1_1_sparse_lengths_weighted_sum_offsets_node}{Sparse\+Lengths\+Weighted\+Sum\+Offsets\+Node}
\begin{DoxyCompactList}\small\item\em Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Offsets) entries\+: first slice between Offsets\mbox{[}0\mbox{]} and Offsets\mbox{[}1\mbox{]} (or total length if there\textquotesingle{}s only one elem in Offsets) are aggregated to Result\mbox{[}0\mbox{]}, etc. I.\+e. largest offset must be less than or equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_sparse_to_dense_inst}{Sparse\+To\+Dense\+Inst}
\item 
class \hyperlink{classglow_1_1_sparse_to_dense_mask_inst}{Sparse\+To\+Dense\+Mask\+Inst}
\item 
class \hyperlink{classglow_1_1_sparse_to_dense_mask_node}{Sparse\+To\+Dense\+Mask\+Node}
\begin{DoxyCompactList}\small\item\em Converts the sparse representation specified by the pair (Indices, Values) into a dense one, where compacted tensor only contains I\+Ds from given Mask. Indices cannot contain duplicate values. Lengths is used to distinguish elements from different examples of one batch. That is, first Lengths\mbox{[}0\mbox{]} index-\/value pairs belong to batch\textquotesingle{}s example 0, next Lengths\mbox{[}1\mbox{]} pairs belong to example 1, and so on. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_sparse_to_dense_node}{Sparse\+To\+Dense\+Node}
\begin{DoxyCompactList}\small\item\em Converts the sparse representation specified by the pair (Indices, Values) into a dense one. This dense representation contains each value from Values at the corresponding index specified in Indices. Unspecified indices are filled with zeroes. Indices may contain duplicate values and in this case, all of the corresponding values in Values are added together. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_splat_inst}{Splat\+Inst}
\item 
class \hyperlink{classglow_1_1_splat_node}{Splat\+Node}
\begin{DoxyCompactList}\small\item\em Generate a tensor of a specific type filled with \textquotesingle{}\hyperlink{classglow_1_1_value}{Value}\textquotesingle{}.Splat always keep floating point value internally but canquantize it based on the output type. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_stats_exporter}{Stats\+Exporter}
\item 
class \hyperlink{classglow_1_1_stats_exporter_registry}{Stats\+Exporter\+Registry}
\begin{DoxyCompactList}\small\item\em Registry of Stats\+Exporters. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_storage}{Storage}
\item 
class \hyperlink{classglow_1_1_str_check}{Str\+Check}
\item 
class \hyperlink{classglow_1_1_sub_grad_node}{Sub\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_sub_node}{Sub\+Node}
\begin{DoxyCompactList}\small\item\em Performs Sub on the L\+HS and R\+HS operands. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_tagged_list}{Tagged\+List}
\item 
class \hyperlink{classglow_1_1_tagged_list_node}{Tagged\+List\+Node}
\item 
struct \hyperlink{structglow_1_1_tagged_list_traits}{Tagged\+List\+Traits}
\item 
class \hyperlink{classglow_1_1_tanh_grad_node}{Tanh\+Grad\+Node}
\item 
class \hyperlink{classglow_1_1_tanh_inst}{Tanh\+Inst}
\item 
class \hyperlink{classglow_1_1_tanh_node}{Tanh\+Node}
\begin{DoxyCompactList}\small\item\em Applies hyperbolic tangent to each element in the Input tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_tensor}{Tensor}
\begin{DoxyCompactList}\small\item\em A class that represents a contiguous n-\/dimensional array (a tensor). \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_tensor_pool}{Tensor\+Pool}
\item 
struct \hyperlink{structglow_1_1_tensor_quantization_params}{Tensor\+Quantization\+Params}
\item 
class \hyperlink{classglow_1_1_tensor_view_inst}{Tensor\+View\+Inst}
\item 
class \hyperlink{classglow_1_1_thread_executor}{Thread\+Executor}
\begin{DoxyCompactList}\small\item\em An executor that runs Tasks on a single thread. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_thread_pool}{Thread\+Pool}
\begin{DoxyCompactList}\small\item\em Thread pool for asynchronous execution of generic functions. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_tile_node}{Tile\+Node}
\begin{DoxyCompactList}\small\item\em Tile an Input tensor Count times along Axis. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_top_k_inst}{Top\+K\+Inst}
\item 
class \hyperlink{classglow_1_1_top_k_node}{Top\+K\+Node}
\begin{DoxyCompactList}\small\item\em Finds the top K maximal elements for each vector in the tensor. Vectors are defined as the last dimension in the tensor. The input shape \{D\+\_\+0, D\+\_\+1, ... D\+\_\+n\} results in the outputs \{D\+\_\+0, D\+\_\+1, ... D\+\_\+n-\/1, K\}, sorted in non-\/decreasing order. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_topological_sort_based_scheduler}{Topological\+Sort\+Based\+Scheduler}
\item 
class \hyperlink{classglow_1_1_trace_context}{Trace\+Context}
\item 
struct \hyperlink{structglow_1_1_trace_event}{Trace\+Event}
\item 
class \hyperlink{classglow_1_1_trace_event_inst}{Trace\+Event\+Inst}
\item 
class \hyperlink{classglow_1_1_trace_event_node}{Trace\+Event\+Node}
\begin{DoxyCompactList}\small\item\em Inserts a \hyperlink{structglow_1_1_trace_event}{Trace\+Event} for profiling. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_trace_info}{Trace\+Info}
\item 
struct \hyperlink{structglow_1_1_training_config}{Training\+Config}
\item 
class \hyperlink{classglow_1_1_transpose_inst}{Transpose\+Inst}
\item 
class \hyperlink{classglow_1_1_transpose_node}{Transpose\+Node}
\begin{DoxyCompactList}\small\item\em Transpose the Input tensor based on the vector Shuffle, which assigns a new axis for each dimension in Input. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_type}{Type}
\begin{DoxyCompactList}\small\item\em A class that represents a type of a tensor. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_type_a_to_type_b_function_converter}{Type\+A\+To\+Type\+B\+Function\+Converter}
\item 
class \hyperlink{classglow_1_1_typed}{Typed}
\begin{DoxyCompactList}\small\item\em Subclasses of this class have a type associated with them. \end{DoxyCompactList}\item 
struct \hyperlink{structglow_1_1_use}{Use}
\item 
class \hyperlink{classglow_1_1_use_def}{Use\+Def}
\begin{DoxyCompactList}\small\item\em A \hyperlink{classglow_1_1_use_def}{Use\+Def} is something that can be an operand for an instruction. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_value}{Value}
\item 
class \hyperlink{classglow_1_1_value_uses}{Value\+Uses}
\item 
class \hyperlink{classglow_1_1_weight_var}{Weight\+Var}
\item 
class \hyperlink{classglow_1_1_zip_reader}{Zip\+Reader}
\begin{DoxyCompactList}\small\item\em Zip reader. \end{DoxyCompactList}\item 
class \hyperlink{classglow_1_1_zip_writer}{Zip\+Writer}
\begin{DoxyCompactList}\small\item\em Zip Writer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceglow_ab1c5bff83b098172f4dd1c9ba869e353}\label{namespaceglow_ab1c5bff83b098172f4dd1c9ba869e353}} 
using {\bfseries Contiguous\+Placeholders} = std\+::vector$<$ \hyperlink{structglow_1_1_placeholder_input_output_info}{Placeholder\+Input\+Output\+Info} $>$
\item 
\mbox{\Hypertarget{namespaceglow_a5ffc97cbc6f11ac585d36ce9b4bdd524}\label{namespaceglow_a5ffc97cbc6f11ac585d36ce9b4bdd524}} 
using {\bfseries Kind\+Set} = llvm\+::\+Small\+Set$<$ Kinded\+::\+Kind, 4 $>$
\item 
\mbox{\Hypertarget{namespaceglow_a9c621decc80700e6f5197522c3a710b6}\label{namespaceglow_a9c621decc80700e6f5197522c3a710b6}} 
using {\bfseries Type\+Ref} = const \hyperlink{structglow_1_1_type}{Type} $\ast$
\item 
using \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} = uint32\+\_\+t
\item 
\mbox{\Hypertarget{namespaceglow_a21d2b7b208b08479f97d30186bcaac1e}\label{namespaceglow_a21d2b7b208b08479f97d30186bcaac1e}} 
using {\bfseries float16\+\_\+t} = \hyperlink{classglow_1_1float16}{float16}
\item 
\mbox{\Hypertarget{namespaceglow_af9a8882a5c68517141911de7bf6662e6}\label{namespaceglow_af9a8882a5c68517141911de7bf6662e6}} 
using {\bfseries Shape\+Vector} = llvm\+::\+Small\+Vector$<$ size\+\_\+t, max\+\_\+tensor\+\_\+dimensions $>$
\item 
\mbox{\Hypertarget{namespaceglow_ac9d940b6582e442881018a0abfae6a17}\label{namespaceglow_ac9d940b6582e442881018a0abfae6a17}} 
using {\bfseries Trace\+Level} = \hyperlink{structglow_1_1_trace_event_a10132a384d74408a112510cbe1b7d978}{Trace\+Event\+::\+Trace\+Level}
\item 
\mbox{\Hypertarget{namespaceglow_a5ff2abbc85bc7a268f9927afc6ee607f}\label{namespaceglow_a5ff2abbc85bc7a268f9927afc6ee607f}} 
using \hyperlink{namespaceglow_a5ff2abbc85bc7a268f9927afc6ee607f}{Reported\+Nodes} = std\+::unordered\+\_\+set$<$ const \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$
\begin{DoxyCompactList}\small\item\em Unique set of visited nodes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a4128b6e54c614a0a53265ffdce7073db}\label{namespaceglow_a4128b6e54c614a0a53265ffdce7073db}} 
using \hyperlink{namespaceglow_a4128b6e54c614a0a53265ffdce7073db}{Types\+List} = std\+::list$<$ \hyperlink{structglow_1_1_type}{Type} $>$
\begin{DoxyCompactList}\small\item\em List of Types. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a4919b7ef01548e927f0a5acb3a7400b9}\label{namespaceglow_a4919b7ef01548e927f0a5acb3a7400b9}} 
using \hyperlink{namespaceglow_a4919b7ef01548e927f0a5acb3a7400b9}{Nodes\+List} = llvm\+::iplist$<$ \hyperlink{classglow_1_1_node}{glow\+::\+Node} $>$
\begin{DoxyCompactList}\small\item\em Intrusive list of Nodes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a40ec79a2f9c485bfa999ed31fd0854dd}\label{namespaceglow_a40ec79a2f9c485bfa999ed31fd0854dd}} 
using \hyperlink{namespaceglow_a40ec79a2f9c485bfa999ed31fd0854dd}{Nodes\+Ptr\+List} = std\+::list$<$ \hyperlink{classglow_1_1_node}{glow\+::\+Node} $\ast$ $>$
\begin{DoxyCompactList}\small\item\em List of pointers to Nodes. The nodes are not owned by the list. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ae6f6f350877931e8074457bbab671b5f}\label{namespaceglow_ae6f6f350877931e8074457bbab671b5f}} 
using \hyperlink{namespaceglow_ae6f6f350877931e8074457bbab671b5f}{Function\+List} = std\+::list$<$ \hyperlink{classglow_1_1_function}{Function} $\ast$ $>$
\begin{DoxyCompactList}\small\item\em List of Functions. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a72abfcd0a98a0493b2a86803a39331ae}\label{namespaceglow_a72abfcd0a98a0493b2a86803a39331ae}} 
using {\bfseries Const\+List} = std\+::list$<$ \hyperlink{classglow_1_1_constant}{Constant} $\ast$ $>$
\item 
\mbox{\Hypertarget{namespaceglow_a327eb2a1f49bd08fcbdd467b54f4f076}\label{namespaceglow_a327eb2a1f49bd08fcbdd467b54f4f076}} 
using {\bfseries Placeholder\+List} = std\+::list$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$ $>$
\item 
\mbox{\Hypertarget{namespaceglow_a162f58aa7c2d2d5adeb5644d90763c00}\label{namespaceglow_a162f58aa7c2d2d5adeb5644d90763c00}} 
using {\bfseries Unsigned\+Array\+Ref} = llvm\+::\+Array\+Ref$<$ size\+\_\+t $>$
\item 
\mbox{\Hypertarget{namespaceglow_afe305f16778f20f331d6b2016221a756}\label{namespaceglow_afe305f16778f20f331d6b2016221a756}} 
using \hyperlink{namespaceglow_afe305f16778f20f331d6b2016221a756}{Node\+Map} = llvm\+::\+Dense\+Map$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$, \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$
\begin{DoxyCompactList}\small\item\em Map from original Nodes to cloned Nodes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ac90b70bdd9c7f0b464aab1f5052ba32f}\label{namespaceglow_ac90b70bdd9c7f0b464aab1f5052ba32f}} 
using {\bfseries Variable\+Gradients\+List} = std\+::list$<$ std\+::pair$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$, \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$ $>$ $>$
\item 
\mbox{\Hypertarget{namespaceglow_a27f95b663529f09dd2ec740fa7de7651}\label{namespaceglow_a27f95b663529f09dd2ec740fa7de7651}} 
using {\bfseries Node\+Value\+Iterator} = \hyperlink{classglow_1_1_node_value_iterator_impl}{Node\+Value\+Iterator\+Impl}$<$ false $>$
\item 
\mbox{\Hypertarget{namespaceglow_a85803b3c7a157b062a37bc07816963a1}\label{namespaceglow_a85803b3c7a157b062a37bc07816963a1}} 
using {\bfseries Node\+Value\+Const\+Iterator} = \hyperlink{classglow_1_1_node_value_iterator_impl}{Node\+Value\+Iterator\+Impl}$<$ true $>$
\item 
\mbox{\Hypertarget{namespaceglow_a29fbdb5f438570d27e0c0b661b58b03e}\label{namespaceglow_a29fbdb5f438570d27e0c0b661b58b03e}} 
using {\bfseries Indices\+Set} = std\+::unordered\+\_\+set$<$ unsigned $>$
\item 
\mbox{\Hypertarget{namespaceglow_a2e94ce06bbb6343779020891e28a7058}\label{namespaceglow_a2e94ce06bbb6343779020891e28a7058}} 
using {\bfseries Instruction\+Operand} = std\+::pair$<$ \hyperlink{classglow_1_1_value}{Value} $\ast$, Operand\+Kind $>$
\item 
\mbox{\Hypertarget{namespaceglow_afe0dc15599ae28d8556999c9cf2a2643}\label{namespaceglow_afe0dc15599ae28d8556999c9cf2a2643}} 
using {\bfseries Const\+Instruction\+Operand} = const std\+::pair$<$ const \hyperlink{classglow_1_1_value}{Value} $\ast$, Operand\+Kind $>$
\item 
\mbox{\Hypertarget{namespaceglow_ab49ee75ee62d0543c929b88397878709}\label{namespaceglow_ab49ee75ee62d0543c929b88397878709}} 
using \hyperlink{namespaceglow_ab49ee75ee62d0543c929b88397878709}{Instr\+Iterator} = \hyperlink{classglow_1_1tagged__list__details_1_1_iterator}{I\+R\+Function\+::\+Instr\+Iterator}
\begin{DoxyCompactList}\small\item\em Iterator over inteructions. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a91cab7bdf4a5e1c4a1857b205e81b9b2}\label{namespaceglow_a91cab7bdf4a5e1c4a1857b205e81b9b2}} 
using {\bfseries Instr\+Const\+Iterator} = \hyperlink{classglow_1_1tagged__list__details_1_1_iterator}{I\+R\+Function\+::\+Instr\+Const\+Iterator}
\item 
\mbox{\Hypertarget{namespaceglow_a4b10fbca9c94f2c0d66386145e9b9d2b}\label{namespaceglow_a4b10fbca9c94f2c0d66386145e9b9d2b}} 
using {\bfseries Quantization\+Mode} = \hyperlink{structglow_1_1_precision_configuration_a9a40e5e2126e4c6f3e8fe3bab25ff12c}{Precision\+Configuration\+::\+Quantization\+Mode}
\item 
\mbox{\Hypertarget{namespaceglow_ad80a5ab10dc4435c6c8ba69a4b279d4b}\label{namespaceglow_ad80a5ab10dc4435c6c8ba69a4b279d4b}} 
using {\bfseries Compilation\+Mode} = \hyperlink{structglow_1_1_compilation_context_a92efb87746c0edf7756b84fdcd87014a}{Compilation\+Context\+::\+Compilation\+Mode}
\item 
using \hyperlink{namespaceglow_a32fc0e338408955f80a23cc7e0c0c82e}{Tensor\+Initializer} = std\+::function$<$ void(\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{classglow_1_1_node}{Node} $\ast$node, unsigned input\+Idx, \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$tensor)$>$
\item 
\mbox{\Hypertarget{namespaceglow_ad640073dcff44c25b1819e1cb420f701}\label{namespaceglow_ad640073dcff44c25b1819e1cb420f701}} 
using {\bfseries Nodes\+Set} = std\+::set$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$
\item 
\mbox{\Hypertarget{namespaceglow_a03e8d2f34b0b5876fd4f7abaf0a0d73d}\label{namespaceglow_a03e8d2f34b0b5876fd4f7abaf0a0d73d}} 
using \hyperlink{namespaceglow_a03e8d2f34b0b5876fd4f7abaf0a0d73d}{B\+F\+S\+Level} = std\+::vector$<$ std\+::vector$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$ $>$
\begin{DoxyCompactList}\small\item\em A list of $<$nodelist$>$ with B\+FS order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a872f72bd7c5e2f8cdc494b659b0b84c4}\label{namespaceglow_a872f72bd7c5e2f8cdc494b659b0b84c4}} 
using {\bfseries Function\+To\+Nodes\+Map} = std\+::map$<$ \hyperlink{classglow_1_1_function}{Function} $\ast$, Nodes\+Set, \hyperlink{structglow_1_1_function_name_comparator}{Function\+Name\+Comparator} $>$
\item 
\mbox{\Hypertarget{namespaceglow_a37c1a2b21677ddb0baeaff2029675698}\label{namespaceglow_a37c1a2b21677ddb0baeaff2029675698}} 
using {\bfseries Function\+To\+Backend\+Name\+Map} = std\+::map$<$ \hyperlink{classglow_1_1_function}{Function} $\ast$, std\+::string, \hyperlink{structglow_1_1_function_name_comparator}{Function\+Name\+Comparator} $>$
\item 
using \hyperlink{namespaceglow_a419aca63ca48becda137d774dd06493c}{Lowered\+Info\+Map} = llvm\+::\+String\+Map$<$ std\+::set$<$ \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} $>$ $>$
\item 
\mbox{\Hypertarget{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}\label{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}} 
using \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} = \hyperlink{classglow_1_1detail_1_1_glow_error}{detail\+::\+Glow\+Error}
\begin{DoxyCompactList}\small\item\em \hyperlink{structglow_1_1_type}{Type} aliases to decouple Error and Expected from underlying implementation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a19ac4a89f32c03c5721dce8c26d826c1}\label{namespaceglow_a19ac4a89f32c03c5721dce8c26d826c1}} 
using {\bfseries Error\+Success} = \hyperlink{classglow_1_1detail_1_1_glow_error_success}{detail\+::\+Glow\+Error\+Success}
\item 
\mbox{\Hypertarget{namespaceglow_a1bf5d74fc12bce2a8d3e50f8b50322e8}\label{namespaceglow_a1bf5d74fc12bce2a8d3e50f8b50322e8}} 
using {\bfseries Error\+Empty} = \hyperlink{classglow_1_1detail_1_1_glow_error_empty}{detail\+::\+Glow\+Error\+Empty}
\item 
\mbox{\Hypertarget{namespaceglow_a9342b33e8382dfa77f9f36abf16776de}\label{namespaceglow_a9342b33e8382dfa77f9f36abf16776de}} 
using {\bfseries Error\+Value} = \hyperlink{classglow_1_1detail_1_1_glow_error_value}{detail\+::\+Glow\+Error\+Value}
\item 
\mbox{\Hypertarget{namespaceglow_a7d81236adc8a9b6e32f0b1244d094ad8}\label{namespaceglow_a7d81236adc8a9b6e32f0b1244d094ad8}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries Expected} = \hyperlink{classglow_1_1detail_1_1_glow_expected}{detail\+::\+Glow\+Expected}$<$ T $>$
\item 
\mbox{\Hypertarget{namespaceglow_aef6c68d23f8def44c72bbab5ee153bb7}\label{namespaceglow_aef6c68d23f8def44c72bbab5ee153bb7}} 
using \hyperlink{namespaceglow_aef6c68d23f8def44c72bbab5ee153bb7}{Float16\+Storage} = uint16\+\_\+t
\begin{DoxyCompactList}\small\item\em \hyperlink{structglow_1_1_use}{Use} a proxy type in case we need to change it in the future. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a2e0b05ad621e4c545de25546f7093b81}\label{namespaceglow_a2e0b05ad621e4c545de25546f7093b81}} 
using {\bfseries Manual\+Event\+Map} = std\+::map$<$ std\+::string, std\+::pair$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$, const \hyperlink{structglow_1_1_trace_info_1_1_event}{Trace\+Info\+::\+Event} $\ast$ $>$ $>$
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceglow_af836699afb1d36a88df0d50d74fde931}\label{namespaceglow_af836699afb1d36a88df0d50d74fde931}} 
enum \hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode} \{ {\bfseries kneg1to1}, 
{\bfseries k0to1}, 
{\bfseries k0to255}, 
{\bfseries kneg128to127}
 \}\begin{DoxyCompactList}\small\item\em Pixel value ranges. \end{DoxyCompactList}
\item 
\mbox{\Hypertarget{namespaceglow_a06c384b9844d09e4dd277eb509728dce}\label{namespaceglow_a06c384b9844d09e4dd277eb509728dce}} 
enum \hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout} \{ {\bfseries N\+C\+HW}, 
{\bfseries N\+H\+WC}
 \}\begin{DoxyCompactList}\small\item\em Layout of image dimensions (batch, channels, height, width). \end{DoxyCompactList}
\item 
\mbox{\Hypertarget{namespaceglow_a2747942676633510584a944637b8eb59}\label{namespaceglow_a2747942676633510584a944637b8eb59}} 
enum \hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order} \{ {\bfseries B\+GR}, 
{\bfseries R\+GB}
 \}\begin{DoxyCompactList}\small\item\em Order of color channels (red, green, blue). \end{DoxyCompactList}
\item 
enum \hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} \+: unsigned char \{ \newline
{\bfseries Float\+Ty}, 
{\bfseries Float16\+Ty}, 
{\bfseries Int8\+Q\+Ty}, 
{\bfseries U\+Int8\+Q\+Ty}, 
\newline
{\bfseries Int16\+Q\+Ty}, 
{\bfseries Int32\+Q\+Ty}, 
{\bfseries Int32\+I\+Ty}, 
{\bfseries Int64\+I\+Ty}, 
\newline
{\bfseries U\+Int8\+Fused\+Q\+Ty}, 
{\bfseries U\+Int8\+Fused\+F\+P16\+Q\+Ty}, 
{\bfseries U\+Int4\+Fused\+F\+P16\+Q\+Ty}, 
{\bfseries Bool\+Ty}
 \}
\item 
enum \hyperlink{namespaceglow_a1c98da7214165b41c7d6b255503d4062}{Function\+State} \{ \hyperlink{namespaceglow_a1c98da7214165b41c7d6b255503d4062a3c96962620eddda2836d6203cf7ecfa0}{Function\+State\+::\+Func\+Created}, 
\hyperlink{namespaceglow_a1c98da7214165b41c7d6b255503d4062ae25a0b7e15a925b8bf4d8016db8d27ac}{Function\+State\+::\+Func\+Loaded}
 \}
\item 
\mbox{\Hypertarget{namespaceglow_a787f9659e35f7ac9a80cc9f3338fe7ea}\label{namespaceglow_a787f9659e35f7ac9a80cc9f3338fe7ea}} 
enum \hyperlink{namespaceglow_a787f9659e35f7ac9a80cc9f3338fe7ea}{Padding\+Mode} \{ {\bfseries C\+O\+N\+S\+T\+A\+NT} = 0, 
{\bfseries R\+E\+F\+L\+E\+CT}, 
{\bfseries E\+D\+GE}
 \}\begin{DoxyCompactList}\small\item\em Modes of the padding operation. \end{DoxyCompactList}
\item 
\mbox{\Hypertarget{namespaceglow_aa2f3a33e05699df0f42295c5c4bd1f77}\label{namespaceglow_aa2f3a33e05699df0f42295c5c4bd1f77}} 
enum \hyperlink{namespaceglow_aa2f3a33e05699df0f42295c5c4bd1f77}{Convolution\+Layout} \{ {\bfseries N\+H\+WC} = 0, 
{\bfseries N\+H\+WC}, 
{\bfseries N\+C\+HW}, 
{\bfseries N\+C\+HW}
 \}\begin{DoxyCompactList}\small\item\em Convolution Layouts. \end{DoxyCompactList}
\item 
\mbox{\Hypertarget{namespaceglow_ae88f2cc9ccac93130ee1cc326d968a21}\label{namespaceglow_ae88f2cc9ccac93130ee1cc326d968a21}} 
enum \hyperlink{namespaceglow_ae88f2cc9ccac93130ee1cc326d968a21}{Fused\+Activation} \{ {\bfseries N\+O\+NE} = 0, 
{\bfseries R\+E\+LU}, 
{\bfseries T\+A\+NH}, 
{\bfseries S\+I\+G\+M\+O\+ID}
 \}\begin{DoxyCompactList}\small\item\em Activations fused into Convolution\+Node (not supported on all backends). \end{DoxyCompactList}
\item 
\mbox{\Hypertarget{namespaceglow_ac310df6cfbec51a38b1cc46d1586eedc}\label{namespaceglow_ac310df6cfbec51a38b1cc46d1586eedc}} 
enum {\bfseries Operand\+Kind} \+: unsigned char \{ {\bfseries In}, 
{\bfseries In\+Out}, 
{\bfseries Out}
 \}
\item 
enum \hyperlink{namespaceglow_ab04a18d4367765236e5de54c47379e66}{Memory\+Area\+Kind} \{ {\bfseries Const\+Weights\+Memory\+Area}, 
{\bfseries Mutable\+Weights\+Memory\+Area}, 
{\bfseries Activations\+Memory\+Area}, 
{\bfseries Last\+Memory\+Area}
 \}
\item 
enum \hyperlink{namespaceglow_a3157945b92abd634c79fa9d4724472eb}{Function\+Pass\+ID} \{ {\bfseries F\+U\+N\+\_\+\+P\+A\+SS}
 \}
\item 
enum \hyperlink{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0}{Convergence\+Mode} \{ \hyperlink{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0accd4cef52fe08da3eeac0e4396a2aca2}{Convergence\+Mode\+::\+One\+Pass}, 
\hyperlink{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0a1a3fe1603e0a452b098a101b7d833f87}{Convergence\+Mode\+::\+Until\+Fixed\+Point}
 \}\begin{DoxyCompactList}\small\item\em Specifies convergence mode for a Function\+Pass. \end{DoxyCompactList}
\item 
enum \hyperlink{namespaceglow_a6b85539f22b3e3292adf202254f0da1e}{D\+C\+E\+Required\+Mode} \{ \hyperlink{namespaceglow_a6b85539f22b3e3292adf202254f0da1eaff7ad7af6ac42e36a5d538e74cde072d}{D\+C\+E\+Required\+Mode\+::\+Before\+Pass}, 
\hyperlink{namespaceglow_a6b85539f22b3e3292adf202254f0da1ea6adf97f83acf6453d4a6a4b1070f3754}{D\+C\+E\+Required\+Mode\+::\+None}
 \}\begin{DoxyCompactList}\small\item\em Specifies whether the pass requires D\+CE. \end{DoxyCompactList}
\item 
enum \hyperlink{namespaceglow_af5b11a9c44f948717d6a886891a58b11}{Scheduler\+Kind} \{ \hyperlink{namespaceglow_af5b11a9c44f948717d6a886891a58b11aca8f7fd5d3a60fdbaaa2f584621c7759}{Scheduler\+Kind\+::\+Child\+Mem\+Size\+Based}, 
\hyperlink{namespaceglow_af5b11a9c44f948717d6a886891a58b11afc2c746e636936c8ce50270012da3147}{Scheduler\+Kind\+::\+Topological\+Sort\+Based}
 \}\begin{DoxyCompactList}\small\item\em Specifies the kind of graph scheduling to perform. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceglow_a9cd2773ca12798a14e44f6f57c2ee826}\label{namespaceglow_a9cd2773ca12798a14e44f6f57c2ee826}} 
\hyperlink{classglow_1_1_backend}{Backend} $\ast$ \hyperlink{namespaceglow_a9cd2773ca12798a14e44f6f57c2ee826}{create\+Backend} (llvm\+::\+String\+Ref backend\+Name)
\begin{DoxyCompactList}\small\item\em Create a backend based on the registered backend name {\ttfamily backend\+Name}. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceglow_af18ed78d6c309a7061f1b1318b9d8aca}{is\+Output} (const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH, const \hyperlink{classglow_1_1_function}{Function} \&F)
\item 
bool \hyperlink{namespaceglow_afbc28cae078d0b91e0bda921554f3ae6}{is\+Input} (const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH, const \hyperlink{classglow_1_1_function}{Function} \&F)
\begin{DoxyCompactList}\small\item\em If {\ttfamily PH} is an input placeholder,. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceglow_a5a7a54e3291e2de0fa2c08e14cf1f36b}{is\+Output} (const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH, const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&F)
\item 
bool \hyperlink{namespaceglow_acb98192dd9bfc2315759db1806f01ad1}{is\+Input} (const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH, const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&F)
\begin{DoxyCompactList}\small\item\em If {\ttfamily PH} is an input placeholder in the function {\ttfamily F},. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$!has\+\_\+get\+Fused\+Activation$<$ T, Fused\+Activation $>$\+::value, int $>$  = 0$>$ }\\bool \hyperlink{namespaceglow_ab310f352073eee80ddb68b3cfaa14e12}{check\+No\+Fusion} (const T \&N)
\begin{DoxyCompactList}\small\item\em If {\ttfamily N} does not have fused activation. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceglow_ad4ca93d79211ec0bc67ed8524634e69a}{check\+No\+Fusion\+For\+Node} (const \hyperlink{classglow_1_1_node}{Node} \&N)
\begin{DoxyCompactList}\small\item\em If {\ttfamily N} does not have fused activation. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceglow_a740e326204223c25d80b8b07e99dac18}{check\+No\+Fusion\+For\+Instr} (const \hyperlink{classglow_1_1_instruction}{Instruction} \&I)
\begin{DoxyCompactList}\small\item\em If {\ttfamily I} does not have fused activation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F\+UN , typename A\+RR $>$ }\\Contiguous\+Placeholders \hyperlink{namespaceglow_ac81027b5844dd48c60ba42e8169f19c2}{get\+Contiguous\+Place\+Holder} (const A\+RR \&holders, const F\+UN \&F)
\item 
std\+::tuple$<$ \hyperlink{structglow_1_1_node_value}{Node\+Value}, \hyperlink{structglow_1_1_node_value}{Node\+Value}, \hyperlink{structglow_1_1_node_value}{Node\+Value} $>$ \hyperlink{namespaceglow_a277fade8bad1b16fc8c084ce52ba6f92}{convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad} (\hyperlink{classglow_1_1_convolution_grad_node}{Convolution\+Grad\+Node} $\ast$C\+GN, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\hyperlink{classglow_1_1_node}{Node} $\ast$ \hyperlink{namespaceglow_aeac40bd989fd3bcb403ecfbf8c120600}{convert\+Conv\+To\+N\+C\+H\+W\+Conv} (\hyperlink{classglow_1_1_convolution_node}{Convolution\+Node} $\ast$CN, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
std\+::pair$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$, \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$ \hyperlink{namespaceglow_a67b90e6ec31547354c4e796d906cebd0}{convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool} (\hyperlink{classglow_1_1_max_pool_node}{Max\+Pool\+Node} $\ast$PN, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\mbox{\Hypertarget{namespaceglow_a2f2b1618bc713e16d13254ae32174ea5}\label{namespaceglow_a2f2b1618bc713e16d13254ae32174ea5}} 
\hyperlink{classglow_1_1_node}{Node} $\ast$ {\bfseries convert\+Max\+Pool\+Grad\+To\+N\+C\+H\+W\+Pool} (\hyperlink{classglow_1_1_max_pool_grad_node}{Max\+Pool\+Grad\+Node} $\ast$P\+GN, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\mbox{\Hypertarget{namespaceglow_a6f8026f99cd2e11a8470cd308c4ee9fb}\label{namespaceglow_a6f8026f99cd2e11a8470cd308c4ee9fb}} 
\hyperlink{classglow_1_1_node}{Node} $\ast$ {\bfseries convert\+Avg\+Pool\+To\+N\+C\+H\+W\+Pool} (\hyperlink{classglow_1_1_avg_pool_node}{Avg\+Pool\+Node} $\ast$PN, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\mbox{\Hypertarget{namespaceglow_acde6a998376eec40dbaaa3f5c0678dfa}\label{namespaceglow_acde6a998376eec40dbaaa3f5c0678dfa}} 
\hyperlink{classglow_1_1_node}{Node} $\ast$ {\bfseries convert\+Avg\+Pool\+Grad\+To\+N\+C\+H\+W\+Pool} (\hyperlink{classglow_1_1_avg_pool_grad_node}{Avg\+Pool\+Grad\+Node} $\ast$P\+GN, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
std\+::pair$<$ float, float $>$ \hyperlink{namespaceglow_a300f3c7eeb3e5ee04d177a2acc6ac4db}{norm\+Mode\+To\+Range} (\hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode} mode)
\begin{DoxyCompactList}\small\item\em Convert the normalization to numeric floating poing ranges. \end{DoxyCompactList}\item 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, bool $>$ \hyperlink{namespaceglow_a8a01d4f862cb83ad8979bfa1c5794930}{get\+Png\+Info} (const char $\ast$filename)
\item 
bool \hyperlink{namespaceglow_a23bf5dcbdf3e69fcee124d73bc4ecace}{read\+Png\+Image} (\hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T, const char $\ast$filename, std\+::pair$<$ float, float $>$ range, llvm\+::\+Array\+Ref$<$ float $>$ mean=zero\+Mean, llvm\+::\+Array\+Ref$<$ float $>$ stddev=one\+Std)
\item 
bool \hyperlink{namespaceglow_acfb0a7a5b75a41f5ba57843e7f242338}{write\+Png\+Image} (\hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T, const char $\ast$filename, std\+::pair$<$ float, float $>$ range, llvm\+::\+Array\+Ref$<$ float $>$ mean=zero\+Mean, llvm\+::\+Array\+Ref$<$ float $>$ stddev=one\+Std)
\item 
\hyperlink{classglow_1_1_tensor}{Tensor} \hyperlink{namespaceglow_aa05ae0a1df66d2a01e935bcfa21e1874}{read\+Png\+Image\+And\+Preprocess} (llvm\+::\+String\+Ref filename, \hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode} \hyperlink{namespaceglow_ad1aa614344d723c1b14942f55e0a92b4}{image\+Norm\+Mode}, \hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order} \hyperlink{namespaceglow_a3f89e6d465a90abbf0dd62935035c1de}{image\+Channel\+Order}, \hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout} \hyperlink{namespaceglow_a53107002ac2c9f4c49145ee80843a1da}{image\+Layout}, llvm\+::\+Array\+Ref$<$ float $>$ mean=zero\+Mean, llvm\+::\+Array\+Ref$<$ float $>$ stddev=one\+Std)
\item 
void \hyperlink{namespaceglow_a4355b249e26c8744ca54250df4d12f89}{read\+Png\+Image\+And\+Preprocess} (\hyperlink{classglow_1_1_tensor}{Tensor} \&image\+Data, llvm\+::\+String\+Ref filename, \hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode} \hyperlink{namespaceglow_ad1aa614344d723c1b14942f55e0a92b4}{image\+Norm\+Mode}, \hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order} \hyperlink{namespaceglow_a3f89e6d465a90abbf0dd62935035c1de}{image\+Channel\+Order}, \hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout} \hyperlink{namespaceglow_a53107002ac2c9f4c49145ee80843a1da}{image\+Layout}, llvm\+::\+Array\+Ref$<$ float $>$ mean=zero\+Mean, llvm\+::\+Array\+Ref$<$ float $>$ stddev=one\+Std)
\item 
void \hyperlink{namespaceglow_ae5f1717e58e71e730005473efae8c91a}{load\+Images\+And\+Preprocess} (const llvm\+::\+Array\+Ref$<$ std\+::string $>$ \&filenames, \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$input\+Image\+Data, \hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode} \hyperlink{namespaceglow_ad1aa614344d723c1b14942f55e0a92b4}{image\+Norm\+Mode}, \hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order} \hyperlink{namespaceglow_a3f89e6d465a90abbf0dd62935035c1de}{image\+Channel\+Order}, \hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout} \hyperlink{namespaceglow_a53107002ac2c9f4c49145ee80843a1da}{image\+Layout})
\item 
void \hyperlink{namespaceglow_a5605652aaef5081976134120c3dcd4d5}{write\+To\+File} (const \hyperlink{classglow_1_1_tensor}{Tensor} \&T, llvm\+::\+String\+Ref filename)
\item 
void \hyperlink{namespaceglow_a327fb998231805cf69b6753e763e683f}{read\+From\+File} (\hyperlink{classglow_1_1_tensor}{Tensor} \&T, llvm\+::\+String\+Ref filename)
\item 
void \hyperlink{namespaceglow_a44d3450f4f150909deaf8e5939537d51}{generic\+Transpose} (const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$src, \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$dest, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ shuffle)
\item 
Shape\+Vector \hyperlink{namespaceglow_a384dccb23b7bc3ade84b8f5c64b1f136}{expand\+Dims\+To\+Max} (llvm\+::\+Array\+Ref$<$ size\+\_\+t $>$ curr\+Dims)
\item 
\mbox{\Hypertarget{namespaceglow_a649c3f6ae28e295be486fb5917a8d885}\label{namespaceglow_a649c3f6ae28e295be486fb5917a8d885}} 
void {\bfseries dump\+Ascii\+Impl} (const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T, llvm\+::raw\+\_\+ostream \&os)
\item 
\mbox{\Hypertarget{namespaceglow_adb053ad1d1927c2af92cf37b53682c8d}\label{namespaceglow_adb053ad1d1927c2af92cf37b53682c8d}} 
void {\bfseries dump\+Ascii\+Impl} (const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T)
\item 
\mbox{\Hypertarget{namespaceglow_a96c48cfb635307b862968dc772c85369}\label{namespaceglow_a96c48cfb635307b862968dc772c85369}} 
void {\bfseries dump\+Impl} (const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T, llvm\+::raw\+\_\+ostream \&os, unsigned max\+Num\+Elem=M\+A\+X\+\_\+\+D\+U\+M\+P\+\_\+\+E\+L\+E\+MS)
\item 
\mbox{\Hypertarget{namespaceglow_a2c3020f7d0d4e127202551ea4d6d5f18}\label{namespaceglow_a2c3020f7d0d4e127202551ea4d6d5f18}} 
void {\bfseries dump\+Impl} (const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T, unsigned max\+Num\+Elem)
\item 
\mbox{\Hypertarget{namespaceglow_a360ade90e7b5a953f3ecd3843e502dbb}\label{namespaceglow_a360ade90e7b5a953f3ecd3843e502dbb}} 
void {\bfseries dump\+Impl} (const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T)
\item 
\mbox{\Hypertarget{namespaceglow_a7ad1c389473834361bddd094fa014da5}\label{namespaceglow_a7ad1c389473834361bddd094fa014da5}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_tensor}{Tensor} \&t)
\item 
\mbox{\Hypertarget{namespaceglow_a9c06a31226910e776a2134f48daebdc1}\label{namespaceglow_a9c06a31226910e776a2134f48daebdc1}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$t)
\item 
std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$ \hyperlink{namespaceglow_a47d2c5f23a3db76b44bbf76e2d41f60d}{flatten\+Cdr} (llvm\+::\+Array\+Ref$<$ size\+\_\+t $>$ dims, \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} n=1)
\item 
\mbox{\Hypertarget{namespaceglow_aade8f76ee6a51f702ae0c3842b09f740}\label{namespaceglow_aade8f76ee6a51f702ae0c3842b09f740}} 
bool {\bfseries operator==} (const \hyperlink{structglow_1_1_shape_n_h_w_c}{Shape\+N\+H\+WC} \&L\+HS, const \hyperlink{structglow_1_1_shape_n_h_w_c}{Shape\+N\+H\+WC} \&R\+HS)
\item 
\mbox{\Hypertarget{namespaceglow_a8c9744bfd19e6cb92b7704a46eafe2e8}\label{namespaceglow_a8c9744bfd19e6cb92b7704a46eafe2e8}} 
bool {\bfseries operator==} (const \hyperlink{structglow_1_1_shape_n_c_h_w}{Shape\+N\+C\+HW} \&L\+HS, const \hyperlink{structglow_1_1_shape_n_c_h_w}{Shape\+N\+C\+HW} \&R\+HS)
\item 
\mbox{\Hypertarget{namespaceglow_a652773bb012a43c21f460b9d110e1f63}\label{namespaceglow_a652773bb012a43c21f460b9d110e1f63}} 
bool {\bfseries operator==} (const \hyperlink{structglow_1_1_shape_n_h_w_d_c}{Shape\+N\+H\+W\+DC} \&L\+HS, const \hyperlink{structglow_1_1_shape_n_h_w_d_c}{Shape\+N\+H\+W\+DC} \&R\+HS)
\item 
bool \hyperlink{namespaceglow_a67fc7f0b501763e06363d035e472238c}{is\+Quantized\+Elem\+Kind} (\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} e)
\item 
bool \hyperlink{namespaceglow_aeea823a4b44883f04b3cd7ba5eebb9ef}{is\+Fused\+Quantized\+Elem\+Kind} (\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} e)
\item 
\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} \hyperlink{namespaceglow_aaee7b49ad6e84bdb1a42ac3e5bff797e}{get\+Scale\+Offset\+Elem\+Kind\+From\+Fused} (\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} e)
\item 
\mbox{\Hypertarget{namespaceglow_a9abd8ccc93a8963092c57a669d6035a0}\label{namespaceglow_a9abd8ccc93a8963092c57a669d6035a0}} 
bool {\bfseries operator==} (const \hyperlink{structglow_1_1_type}{Type} \&L\+HS, const \hyperlink{structglow_1_1_type}{Type} \&R\+HS)
\item 
\mbox{\Hypertarget{namespaceglow_a0e6e7356de0d3ed109bc3b95d9753d8d}\label{namespaceglow_a0e6e7356de0d3ed109bc3b95d9753d8d}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{structglow_1_1_type}{Type} \&type)
\item 
void \hyperlink{namespaceglow_aef265ed4d4604e471d8b5662c3f5a423}{convert\+Function\+To\+Float16} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, const \hyperlink{structglow_1_1_precision_configuration}{Precision\+Configuration} \&prec\+Config)
\item 
void \hyperlink{namespaceglow_a24661dfe4d11f5c1cf0db592389a43fc}{update\+Input\+Placeholders} (\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$$>$ ph, llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$$>$ inputs)
\item 
void \hyperlink{namespaceglow_afe843dcf46487faf7eecfb58d8e15c04}{update\+Input\+Placeholders\+By\+Name} (\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, \hyperlink{classglow_1_1_module}{Module} $\ast$mod, llvm\+::\+Array\+Ref$<$ llvm\+::\+String\+Ref $>$ ph, llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$$>$ inputs)
\item 
void \hyperlink{namespaceglow_a2d7264d309f534807df9015c8bccda87}{run\+Batch} (\hyperlink{classglow_1_1_execution_engine}{Execution\+Engine} \&EE, \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, size\+\_\+t iterations, size\+\_\+t \&sample\+Counter, llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$$>$ ph, llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$$>$ inputs, llvm\+::\+String\+Ref name=\char`\"{}\char`\"{})
\item 
void \hyperlink{namespaceglow_ad7385d41afaa1bd063dfa1b74e693ad1}{eval\+Batch} (\hyperlink{classglow_1_1_execution_engine}{Execution\+Engine} \&EE, \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, size\+\_\+t num\+Minibatch\+Runs, size\+\_\+t \&sample\+Counter, \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$input\+PH, \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$output\+PH, \hyperlink{classglow_1_1_tensor}{Tensor} \&samples\+Input, \hyperlink{classglow_1_1_tensor}{Tensor} \&labels\+Input, llvm\+::\+String\+Ref name, std\+::function$<$ void(const \hyperlink{classglow_1_1_tensor}{Tensor} \&sample\+In, const \hyperlink{classglow_1_1_tensor}{Tensor} \&sample\+Out, const \hyperlink{classglow_1_1_tensor}{Tensor} \&label, size\+\_\+t sample\+Index)$>$ \&\&cb)
\item 
\hyperlink{classglow_1_1_function}{Function} $\ast$ \hyperlink{namespaceglow_a8d2a21b045e4c1595f1da56d34750169}{differentiate} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, const \hyperlink{structglow_1_1_training_config}{Training\+Config} \&config, llvm\+::\+String\+Ref new\+Func\+Name=\char`\"{}\char`\"{}, Variable\+Gradients\+List $\ast$var\+Grads=nullptr)
\item 
\hyperlink{classglow_1_1_save_node}{Save\+Node} $\ast$ \hyperlink{namespaceglow_a493b517e027e3c2689248c644f3747b5}{get\+Output\+Save} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH)
\item 
\hyperlink{classglow_1_1_node}{Node} $\ast$ \hyperlink{namespaceglow_a4089f87152e44934daec43bb106d9858}{recursive\+Clone} (\hyperlink{classglow_1_1_function}{Function} $\ast$newF, \hyperlink{classglow_1_1_node}{Node} $\ast$node, \hyperlink{namespaceglow_afe305f16778f20f331d6b2016221a756}{Node\+Map} \&curr\+To\+New)
\item 
\mbox{\Hypertarget{namespaceglow_af5ca558a2ae84f7c93983f608b3d2f0a}\label{namespaceglow_af5ca558a2ae84f7c93983f608b3d2f0a}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_module}{Module} \&mod)
\item 
\mbox{\Hypertarget{namespaceglow_ada49a44492f70626c2cf9fa74ddf8d2f}\label{namespaceglow_ada49a44492f70626c2cf9fa74ddf8d2f}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_module}{Module} $\ast$mod)
\item 
\mbox{\Hypertarget{namespaceglow_af45e63412051b164953d915339f08778}\label{namespaceglow_af45e63412051b164953d915339f08778}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_function}{Function} \&F)
\item 
\mbox{\Hypertarget{namespaceglow_adc599c16f44200c3ae527f8dae185ec4}\label{namespaceglow_adc599c16f44200c3ae527f8dae185ec4}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\mbox{\Hypertarget{namespaceglow_ad87dc70f9ca570ed9bfb6f43f62ef253}\label{namespaceglow_ad87dc70f9ca570ed9bfb6f43f62ef253}} 
\hyperlink{structglow_1_1_hooked_function}{Hooked\+Function} {\bfseries hook\+Output} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{classglow_1_1_node}{Node} $\ast$node)
\item 
\mbox{\Hypertarget{namespaceglow_a8b62431330eac17d2e68decaa124a090}\label{namespaceglow_a8b62431330eac17d2e68decaa124a090}} 
\hyperlink{structglow_1_1_hooked_function}{Hooked\+Function} {\bfseries hook\+Output} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, llvm\+::\+String\+Ref node\+Name)
\item 
\mbox{\Hypertarget{namespaceglow_aaee890b8f51f27f6d9b3cf7766d5aff6}\label{namespaceglow_aaee890b8f51f27f6d9b3cf7766d5aff6}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_node}{Node} \&node)
\item 
\mbox{\Hypertarget{namespaceglow_a62a0bf543041a50cfef1b5c3e64fd0ec}\label{namespaceglow_a62a0bf543041a50cfef1b5c3e64fd0ec}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_node}{Node} $\ast$node)
\item 
Kinded\+::\+Kind \hyperlink{namespaceglow_af5d8953e310c3650356892fa4e866ce3}{get\+Kind\+From\+Node\+Name} (llvm\+::\+String\+Ref node\+Name)
\item 
std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$ \hyperlink{namespaceglow_a3623979e9cf3437802bf2f23d15b425e}{calculate\+Conv\+Pool\+Output\+Dims} (size\+\_\+t sx, size\+\_\+t sy, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ kernels, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ strides, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ pads, \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} dilation=1)
\item 
\hyperlink{structglow_1_1_shape_h_w_d}{Shape\+H\+WD} \hyperlink{namespaceglow_a110f6a4f4c9801ecca0c96826b3888ff}{calculate3\+D\+Conv\+Pool\+Output\+Dims} (size\+\_\+t inH, size\+\_\+t inW, size\+\_\+t inD, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ kernels, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ strides, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$ pads)
\item 
\mbox{\Hypertarget{namespaceglow_afe6fb0f683a9b1d0649e7f742b9151c4}\label{namespaceglow_afe6fb0f683a9b1d0649e7f742b9151c4}} 
llvm\+::raw\+\_\+ostream \& \hyperlink{namespaceglow_afe6fb0f683a9b1d0649e7f742b9151c4}{operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, \hyperlink{namespaceglow_aa2f3a33e05699df0f42295c5c4bd1f77}{Convolution\+Layout} layout)
\begin{DoxyCompactList}\small\item\em Define output operators. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a419566d4026797c72c141815595efd47}\label{namespaceglow_a419566d4026797c72c141815595efd47}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, \hyperlink{namespaceglow_ae88f2cc9ccac93130ee1cc326d968a21}{Fused\+Activation} fused\+Activation)
\item 
size\+\_\+t \hyperlink{namespaceglow_a81686f1483028ad3045a94ef9760a3b6}{to\+Binary} (float f)
\begin{DoxyCompactList}\small\item\em Convert a float into an unsigned integer binary representation. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ \hyperlink{namespaceglow_a13cf69ac6cea3abdeffaf975e3f9f02d}{to\+Binary} (llvm\+::\+Array\+Ref$<$ float $>$ vec)
\item 
\mbox{\Hypertarget{namespaceglow_a416a5368f277fbdfd5cb8462943ac14e}\label{namespaceglow_a416a5368f277fbdfd5cb8462943ac14e}} 
llvm\+::hash\+\_\+code {\bfseries hash\+\_\+value} (const \hyperlink{classglow_1_1_tensor}{glow\+::\+Tensor} \&T)
\item 
\mbox{\Hypertarget{namespaceglow_a7ed1766ebf7725a0051413415a1434f6}\label{namespaceglow_a7ed1766ebf7725a0051413415a1434f6}} 
llvm\+::hash\+\_\+code {\bfseries hash\+\_\+value} (const \hyperlink{structglow_1_1_type}{glow\+::\+Type} $\ast$T)
\item 
\mbox{\Hypertarget{namespaceglow_ad2898079dcd9fda7ffc7bed25a65a5b3}\label{namespaceglow_ad2898079dcd9fda7ffc7bed25a65a5b3}} 
llvm\+::hash\+\_\+code {\bfseries hash\+\_\+value} (\hyperlink{classglow_1_1_node}{glow\+::\+Node} $\ast$T)
\item 
\mbox{\Hypertarget{namespaceglow_a72d748f20bbabccdd3116d10d66ab877}\label{namespaceglow_a72d748f20bbabccdd3116d10d66ab877}} 
llvm\+::hash\+\_\+code {\bfseries hash\+\_\+value} (const \hyperlink{structglow_1_1_node_value}{glow\+::\+Node\+Value} \&T)
\item 
\mbox{\Hypertarget{namespaceglow_a45143d1e6bebb3fadd2d86d6fa83aa98}\label{namespaceglow_a45143d1e6bebb3fadd2d86d6fa83aa98}} 
llvm\+::hash\+\_\+code {\bfseries hash\+\_\+value} (const \hyperlink{structglow_1_1_node_handle}{glow\+::\+Node\+Handle} \&T)
\item 
{\footnotesize template$<$typename Ty $>$ }\\void \hyperlink{namespaceglow_a5efbd9d8157489eb3b55e5c9fafb5fb7}{report\+Context} (const Ty \&a)
\item 
\mbox{\Hypertarget{namespaceglow_a8673fd40721984ef7418c441016ec644}\label{namespaceglow_a8673fd40721984ef7418c441016ec644}} 
{\footnotesize template$<$typename Ty $>$ }\\void {\bfseries report\+Context} (const llvm\+::\+Array\+Ref$<$ Ty $>$ \&array\+Ref)
\item 
\mbox{\Hypertarget{namespaceglow_a0a0cb928a5fe2c37d8a523c701f5bc32}\label{namespaceglow_a0a0cb928a5fe2c37d8a523c701f5bc32}} 
void {\bfseries report\+Context} (\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} Ty)
\item 
\mbox{\Hypertarget{namespaceglow_a943e19401858c2091596c5e6ff2b8745}\label{namespaceglow_a943e19401858c2091596c5e6ff2b8745}} 
void {\bfseries report\+Context} (const \hyperlink{structglow_1_1_shape_n_h_w_c}{Shape\+N\+H\+WC} \&shape\+N\+H\+WC)
\item 
\mbox{\Hypertarget{namespaceglow_af0e9d65b269de76dda093a6237fd34b4}\label{namespaceglow_af0e9d65b269de76dda093a6237fd34b4}} 
void {\bfseries report\+Context} (const \hyperlink{structglow_1_1_shape_n_c_h_w}{Shape\+N\+C\+HW} \&shape\+N\+C\+HW)
\item 
\mbox{\Hypertarget{namespaceglow_ae4bc79983c10b531ddd8836146c76011}\label{namespaceglow_ae4bc79983c10b531ddd8836146c76011}} 
void {\bfseries report\+Context} (const \hyperlink{classglow_1_1_node}{Node} $\ast$node)
\item 
\mbox{\Hypertarget{namespaceglow_a09afe64a1783afbb51ba0cd5ae2634a6}\label{namespaceglow_a09afe64a1783afbb51ba0cd5ae2634a6}} 
void {\bfseries report\+Context} (const \hyperlink{classglow_1_1_function}{Function} $\ast$function)
\item 
{\footnotesize template$<$typename Input\+Ty , typename Parent\+Ty $>$ }\\bool \hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} (const char $\ast$msg, const Input\+Ty \&a, const Input\+Ty \&b, const Parent\+Ty $\ast$parent, const \hyperlink{structglow_1_1_compare_with_name}{Compare\+With\+Name}$<$ Input\+Ty $>$ \&comp=\hyperlink{structglow_1_1_compare_operator_equal}{Compare\+Operator\+Equal}$<$ Input\+Ty $>$())
\item 
{\footnotesize template$<$typename Input\+Ty $>$ }\\bool \hyperlink{namespaceglow_a77a6fef6be3a014626580088a1a72842}{expect\+Compare\+True} (const char $\ast$msg, const Input\+Ty \&a, llvm\+::\+Array\+Ref$<$ Input\+Ty $>$ b, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent, const \hyperlink{structglow_1_1_compare_with_name}{Compare\+With\+Name}$<$ Input\+Ty $>$ \&comp=\hyperlink{structglow_1_1_compare_operator_equal}{Compare\+Operator\+Equal}$<$ Input\+Ty $>$())
\item 
bool \hyperlink{namespaceglow_a1963e99917ffdb1fdd70911811002792}{check\+Same\+Type} (\hyperlink{structglow_1_1_node_value}{Node\+Value} A, \hyperlink{structglow_1_1_node_value}{Node\+Value} B, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_ae06ad0f896240c6ccea6cb9472e57e2a}{check\+Same\+Shape} (\hyperlink{structglow_1_1_node_value}{Node\+Value} A, \hyperlink{structglow_1_1_node_value}{Node\+Value} B, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_a5321bd4a40acf901a0d9b8eb2e25f4ae}{check\+Type} (\hyperlink{structglow_1_1_node_value}{Node\+Value} A, \hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} expected\+Type, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_a06107a1368ca70c82884f7a7863a0599}{check\+Type} (\hyperlink{structglow_1_1_node_value}{Node\+Value} A, llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} $>$ expected\+Types, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_a9d3dd221c6d43bfa4d2e54ff8640604b}{check\+Same\+Is\+Quantized} (const \hyperlink{structglow_1_1_type}{Type\+Ref} A, const \hyperlink{structglow_1_1_type}{Type\+Ref} B, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_a4b41db469b7a600c65a7e57665a72474}{check\+Not\+Quantized\+Or\+Same\+Params} (const \hyperlink{structglow_1_1_type}{Type\+Ref} A, float scale, int32\+\_\+t offset, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_a3b27e9f4187aa476d1a4f3414b4f5dcb}{check\+Not\+Quantized\+Or\+Same\+Params} (const \hyperlink{structglow_1_1_type}{Type\+Ref} A, const \hyperlink{structglow_1_1_type}{Type\+Ref} B, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
bool \hyperlink{namespaceglow_abfafc7403160bca58a7672d68c2d944d}{check\+Type\+Ignore\+Shape} (\hyperlink{structglow_1_1_node_value}{Node\+Value} A, \hyperlink{structglow_1_1_node_value}{Node\+Value} B, const \hyperlink{classglow_1_1_node}{Node} $\ast$parent)
\item 
\mbox{\Hypertarget{namespaceglow_a55a18c587cbe10ce4663291671b3c14a}\label{namespaceglow_a55a18c587cbe10ce4663291671b3c14a}} 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_a55a18c587cbe10ce4663291671b3c14a}{load\+Tensor} (const O\+N\+N\+X\+\_\+\+N\+A\+M\+E\+S\+P\+A\+C\+E\+::\+Tensor\+Proto \&in, \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$T)
\begin{DoxyCompactList}\small\item\em Loads tensor {\ttfamily T} from the input {\ttfamily in}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ab78b8ac2f8153ff363a1a6d85d4546cd}\label{namespaceglow_ab78b8ac2f8153ff363a1a6d85d4546cd}} 
void \hyperlink{namespaceglow_ab78b8ac2f8153ff363a1a6d85d4546cd}{set\+Constant\+Fold\+Loader\+Ops\+Flag} (bool flag)
\begin{DoxyCompactList}\small\item\em Enables or disables constant-\/folding of \hyperlink{classglow_1_1_loader}{Loader} Ops with {\ttfamily flag}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a66faefdb52d7d51fa930bf0b04d45b7e}\label{namespaceglow_a66faefdb52d7d51fa930bf0b04d45b7e}} 
bool \hyperlink{namespaceglow_a66faefdb52d7d51fa930bf0b04d45b7e}{get\+Constant\+Fold\+Loader\+Ops\+Flag} ()
\begin{DoxyCompactList}\small\item\em Returns true if constant-\/folding for loader Ops is enabled. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a8ea47c0e13dc7e7a9938412b4b56cdf9}\label{namespaceglow_a8ea47c0e13dc7e7a9938412b4b56cdf9}} 
bool \hyperlink{namespaceglow_a8ea47c0e13dc7e7a9938412b4b56cdf9}{is\+Array\+Constant} (const llvm\+::\+Array\+Ref$<$ size\+\_\+t $>$ a)
\begin{DoxyCompactList}\small\item\em Returns true iff all elements of {\ttfamily a} are the same. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string \hyperlink{namespaceglow_ad735d6bafe7a0cb3ffb5482656235b2e}{unexpected\+Node\+Error\+Message} (const T \&node, llvm\+::\+String\+Ref message)
\item 
\mbox{\Hypertarget{namespaceglow_aae369f3c48005ee720d64611cfd152ef}\label{namespaceglow_aae369f3c48005ee720d64611cfd152ef}} 
{\footnotesize template$<$typename Elem\+Ty  = size\+\_\+t, typename Attr\+Type $>$ }\\std\+::vector$<$ Elem\+Ty $>$ \hyperlink{namespaceglow_aae369f3c48005ee720d64611cfd152ef}{get\+Shape} (const Attr\+Type $\ast$arg)
\begin{DoxyCompactList}\small\item\em Load the \textquotesingle{}shape\textquotesingle{} record into a vector of sizes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Attr\+Type $>$ }\\std\+::vector$<$ float $>$ \hyperlink{namespaceglow_ad9cf5d13b978aa755ff9b01edad65466}{get\+Floats} (const Attr\+Type $\ast$arg)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string \hyperlink{namespaceglow_a7fbe04791f94ae9ed38fa4c0166e6709}{load\+Operator\+Name} (const T \&op)
\item 
{\footnotesize template$<$class Loader\+Type , class Op\+Type $>$ }\\\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_a6f10f8f52d528b3ceb40892376bc1fb9}{constant\+Fold\+In\+Loader} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, Loader\+Type \&tmp\+Loader, Loader\+Type $\ast$loader, const Op\+Type \&op)
\item 
\mbox{\Hypertarget{namespaceglow_a35b5eaed4bae1f27356fcac28824077d}\label{namespaceglow_a35b5eaed4bae1f27356fcac28824077d}} 
const char $\ast$ {\bfseries get\+Operand\+Kind\+Str} (Operand\+Kind CC)
\item 
\mbox{\Hypertarget{namespaceglow_a867c5c159e56b6fef437144cfb4e82b6}\label{namespaceglow_a867c5c159e56b6fef437144cfb4e82b6}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_value}{Value} \&V)
\item 
\mbox{\Hypertarget{namespaceglow_a5980fcd2be554da44ec79f3a5a873ecd}\label{namespaceglow_a5980fcd2be554da44ec79f3a5a873ecd}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_value}{Value} $\ast$V)
\item 
\mbox{\Hypertarget{namespaceglow_a5f5720dde6a04852e0bdef39ba68ee76}\label{namespaceglow_a5f5720dde6a04852e0bdef39ba68ee76}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&irf)
\item 
\mbox{\Hypertarget{namespaceglow_a1d048d8c4d0955710c23ffb035a16d04}\label{namespaceglow_a1d048d8c4d0955710c23ffb035a16d04}} 
llvm\+::raw\+\_\+ostream \& {\bfseries operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} $\ast$irf)
\item 
bool \hyperlink{namespaceglow_aafa588b030c2f1fbed648b8477d7b444}{is\+Tensor\+View} (\hyperlink{classglow_1_1_value}{Value} $\ast$v)
\item 
\hyperlink{classglow_1_1_value}{Value} $\ast$ \hyperlink{namespaceglow_ab32aaca1a37daa0543ca953df2110b63}{get\+Allocation\+Origin} (\hyperlink{classglow_1_1_value}{Value} $\ast$V)
\item 
\hyperlink{classglow_1_1_value}{Value} $\ast$ \hyperlink{namespaceglow_a455ad0b5511a75c369f14b06c1de37fd}{get\+Origin} (\hyperlink{classglow_1_1_value}{Value} $\ast$V)
\item 
size\+\_\+t \hyperlink{namespaceglow_a7ec2658c25c6fddc1b6788888a930d71}{get\+Origin\+Offset} (\hyperlink{classglow_1_1_value}{Value} $\ast$V)
\item 
const \hyperlink{classglow_1_1_value}{Value} $\ast$ \hyperlink{namespaceglow_a582b647d0167e2bd46758cf24a691ac3}{get\+Origin} (const \hyperlink{classglow_1_1_value}{Value} $\ast$V)
\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_function_pass}{Function\+Pass} $>$ \hyperlink{namespaceglow_a77f32741a0e156b7bd043992d6eedc6c}{create\+Function\+Pass} (\hyperlink{namespaceglow_a3157945b92abd634c79fa9d4724472eb}{Function\+Pass\+ID} pass\+ID)
\begin{DoxyCompactList}\small\item\em Helper that creates and. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a902cda054ebe738e9395e218ae09f291}\label{namespaceglow_a902cda054ebe738e9395e218ae09f291}} 
void \hyperlink{namespaceglow_a902cda054ebe738e9395e218ae09f291}{optimize} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx)
\begin{DoxyCompactList}\small\item\em Perform optimizations on the graph representation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_aa4b890b671b9e9a2e7cb5f3b45f6b5d9}\label{namespaceglow_aa4b890b671b9e9a2e7cb5f3b45f6b5d9}} 
void {\bfseries optimize} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context_a92efb87746c0edf7756b84fdcd87014a}{Compilation\+Mode} mode)
\item 
\mbox{\Hypertarget{namespaceglow_a3b05ee22e66e0ac0c56f9623b1038bdd}\label{namespaceglow_a3b05ee22e66e0ac0c56f9623b1038bdd}} 
void {\bfseries optimize} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx, const \hyperlink{classglow_1_1_backend}{Backend} \&B)
\item 
\mbox{\Hypertarget{namespaceglow_a1af90308823b5fb36b860a8a73aaa923}\label{namespaceglow_a1af90308823b5fb36b860a8a73aaa923}} 
void \hyperlink{namespaceglow_a1af90308823b5fb36b860a8a73aaa923}{fold} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx)
\begin{DoxyCompactList}\small\item\em Fold nodes that were expressed lowered in the input model. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a8e16dd4467be5a31fb8647f8199d4d5a}\label{namespaceglow_a8e16dd4467be5a31fb8647f8199d4d5a}} 
void {\bfseries fold} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context_a92efb87746c0edf7756b84fdcd87014a}{Compilation\+Mode} mode)
\item 
void \hyperlink{namespaceglow_a0069e8261c2e2ddf94d4697de80150ad}{lower} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx, const \hyperlink{classglow_1_1_backend}{Backend} $\ast$B=nullptr, const Kind\+Set \&do\+Not\+Lower\+Kinds=\{\})
\item 
void \hyperlink{namespaceglow_a7c4fddd8b31e37460f88d44f076a2863}{convert\+Placeholders\+To\+Constants} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, const \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$$>$ vars)
\item 
void \hyperlink{namespaceglow_a8e9d4a9dc79cc3c3010bc99e93b08fc7}{profile\+Quantization} (\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_af6b48e8310d02c29962b5469885b3a75}{optimize\+Function} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, const \hyperlink{classglow_1_1_backend}{Backend} \&B, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx)
\item 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_a2bc58f10ed9c082dab795b43217a2d51}{optimize\+Function\+Before\+Lowering} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx)
\item 
std\+::vector$<$ \hyperlink{classglow_1_1_constant}{Constant} $\ast$ $>$ \hyperlink{namespaceglow_a0e523cb23b972dda0c52eb9c841a1d33}{constant\+Fold} (\hyperlink{classglow_1_1_node}{Node} $\ast$N)
\item 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_a6bf1f1f5a7c61022904299bfeee07b34}{execute\+Constant\+Function} (\hyperlink{classglow_1_1_backend}{Backend} \&backend, \hyperlink{classglow_1_1_function}{Function} \&F, \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx)
\item 
bool \hyperlink{namespaceglow_a130f47cd21711d9244adfb418ffbe9f7}{execute\+Vertical\+F\+C\+Weights\+Split} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, unsigned num\+Of\+Chunks, unsigned min\+K\+To\+Split)
\item 
bool \hyperlink{namespaceglow_a70f636287069c1f7f97e401c440ae580}{run\+D\+C\+E\+Pass} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&cctx)
\begin{DoxyCompactList}\small\item\em Helper to run a D\+CE pass on {\ttfamily F} given {\ttfamily cctx}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a4919335ab33be32c994fc590a146f819}\label{namespaceglow_a4919335ab33be32c994fc590a146f819}} 
\hyperlink{namespaceglow_a32fc0e338408955f80a23cc7e0c0c82e}{Tensor\+Initializer} \hyperlink{namespaceglow_a4919335ab33be32c994fc590a146f819}{get\+Default\+Tensor\+Initializer} ()
\begin{DoxyCompactList}\small\item\em Method generates and returns the default tensor initializer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_afab8032d084eac6febc76e522aec8564}\label{namespaceglow_afab8032d084eac6febc76e522aec8564}} 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_afab8032d084eac6febc76e522aec8564}{prepare\+Function\+For\+Training} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&bindings, \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$\&selected, \hyperlink{namespaceglow_a32fc0e338408955f80a23cc7e0c0c82e}{Tensor\+Initializer} \&\&initializer=\hyperlink{namespaceglow_a4919335ab33be32c994fc590a146f819}{get\+Default\+Tensor\+Initializer}())
\begin{DoxyCompactList}\small\item\em \hyperlink{classglow_1_1_function}{Function} takes \hyperlink{classglow_1_1_function}{glow\+::\+Function} {\ttfamily F}, {\ttfamily bindings}, {\ttfamily selected} placeholder,. \end{DoxyCompactList}\item 
\hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline} \hyperlink{namespaceglow_afd7544cbea4219b8f3c720d6a4e19481}{create\+Default\+Graph\+Optimization\+Pass\+Pipeline} ()
\item 
\hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline} \hyperlink{namespaceglow_a2cba8b151906d972e63ced04b7e02242}{create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline} ()
\item 
\hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline} \hyperlink{namespaceglow_a9e0b594543fb42b8b6ad0cc556ee9829}{create\+Default\+Fold\+Pass\+Pipeline} ()
\item 
\hyperlink{classglow_1_1_function_pass_config}{Function\+Pass\+Config} \hyperlink{namespaceglow_a4fef74193703ceb204297b6993af8081}{get\+D\+C\+E\+Pass\+Config} ()
\item 
llvm\+::\+String\+Ref \hyperlink{namespaceglow_a6195ce22fbeafd894c0ce148bb7a8a9a}{get\+Name\+Of\+Pass} (\hyperlink{namespaceglow_a3157945b92abd634c79fa9d4724472eb}{Function\+Pass\+ID} pass\+ID)
\item 
\mbox{\Hypertarget{namespaceglow_ac26012881301f2ecb24de4db2c87acf1}\label{namespaceglow_ac26012881301f2ecb24de4db2c87acf1}} 
void \hyperlink{namespaceglow_ac26012881301f2ecb24de4db2c87acf1}{optimize} (\hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&M, bool should\+Share\+Buffers)
\begin{DoxyCompactList}\small\item\em Perform optimizations on the IR representation. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} $>$ \hyperlink{namespaceglow_a100064cb8d6d8c2aae54f4a114cf48f4}{generate\+And\+Optimize\+IR} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, const \hyperlink{classglow_1_1_backend}{Backend} \&B, bool should\+Share\+Buffers)
\item 
void \hyperlink{namespaceglow_a07bee061556f83b0349d96ad196f0faf}{optimize\+Communication\+Cost} (\hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&partitions, Function\+To\+Nodes\+Map \&nodes\+Set, \hyperlink{classglow_1_1_module}{Module} $\ast$mod, uint64\+\_\+t available\+Memory)
\item 
void \hyperlink{namespaceglow_aab6afbd888776074c6bd9285aa3d9fd8}{partitions\+Combine} (\hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&partitions, Function\+To\+Nodes\+Map \&nodes\+Set, \hyperlink{classglow_1_1_module}{Module} $\ast$mod, uint64\+\_\+t available\+Memory)
\item 
Device\+I\+D\+Ty \hyperlink{namespaceglow_adce5a7edd1093d119dbed94a5dce5cdf}{assign\+Logical\+Device\+ID} (\hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&mapping, const std\+::map$<$ std\+::string, \hyperlink{structglow_1_1_backend_info}{Backend\+Info} $>$ \&backend\+Map)
\item 
\mbox{\Hypertarget{namespaceglow_a6fba690abc1f8a3660e73f6e6c9959bd}\label{namespaceglow_a6fba690abc1f8a3660e73f6e6c9959bd}} 
bool {\bfseries operator==} (const \hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} \&L\+HS, const \hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} \&R\+HS)
\item 
\hyperlink{namespaceglow_a03e8d2f34b0b5876fd4f7abaf0a0d73d}{B\+F\+S\+Level} \hyperlink{namespaceglow_acfa7d1d30cd1420a7a651fa3d63b33e6}{get\+B\+F\+S\+Level} (\hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
std\+::vector$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$ \hyperlink{namespaceglow_ace2ce9f3fea11d339cd0605fe8ece061}{get\+Out\+Users} (const Nodes\+Set \&nodes)
\begin{DoxyCompactList}\small\item\em Given {\ttfamily nodes}, return a list of nodes who use any node in this set. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$ \hyperlink{namespaceglow_a352ec64282f28b5487a23bf2d805a528}{get\+Out\+Users\+With\+One\+Predecessor} (const Nodes\+Set \&nodes)
\item 
uint64\+\_\+t \hyperlink{namespaceglow_a4c7ea6df70770cd2ccf2bbfb85077539}{get\+Out\+Mem\+Per\+Node} (const Nodes\+Set \&nodes, const \hyperlink{classglow_1_1_node}{Node} $\ast$node)
\item 
Nodes\+Set \hyperlink{namespaceglow_a589ee9d58bb8726a5e764b1dd74f8070}{get\+Inputs} (const \hyperlink{classglow_1_1_node}{Node} $\ast$node)
\begin{DoxyCompactList}\small\item\em Given a node,. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a126aa14fbeafec59916bb142ecac0541}\label{namespaceglow_a126aa14fbeafec59916bb142ecac0541}} 
float \hyperlink{namespaceglow_a126aa14fbeafec59916bb142ecac0541}{get\+Node\+Compute\+Time} (const \hyperlink{classglow_1_1_node}{Node} $\ast$node, const \hyperlink{structglow_1_1_backend_info}{Backend\+Info} \&backend\+Info)
\begin{DoxyCompactList}\small\item\em Return the estimated op computation time based on {\ttfamily backend\+Info}. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceglow_a59d8826ffac432ffcebc8dcd11a85816}{get\+Node\+Mem\+Usage} (const \hyperlink{classglow_1_1_node}{Node} $\ast$node)
\begin{DoxyCompactList}\small\item\em Given a node,. \end{DoxyCompactList}\item 
\hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} \hyperlink{namespaceglow_aa54619319c88d7ceb184f4dd70af8ccf}{update\+Graph\+Mem\+Info\+By\+Adding\+Node} (const Nodes\+Set \&curr\+Nodes, const \hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} \&info, \hyperlink{classglow_1_1_node}{Node} $\ast$new\+Node)
\item 
\mbox{\Hypertarget{namespaceglow_af21f64a0aca1ada898039dbe69053bfd}\label{namespaceglow_af21f64a0aca1ada898039dbe69053bfd}} 
\hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} \hyperlink{namespaceglow_af21f64a0aca1ada898039dbe69053bfd}{get\+Graph\+Mem\+Info} (const Nodes\+Set \&nodes)
\begin{DoxyCompactList}\small\item\em Return the memory usage of a given nodes set. \end{DoxyCompactList}\item 
std\+::set$<$ Kinded\+::\+Kind $>$ \hyperlink{namespaceglow_a9d06550bdaa17730cb67e8a086db767c}{generate\+Node\+Kinds\+Set} (llvm\+::\+String\+Ref names)
\item 
\mbox{\Hypertarget{namespaceglow_a52aab7cde0b8f39f6420e1c47c57ff34}\label{namespaceglow_a52aab7cde0b8f39f6420e1c47c57ff34}} 
void \hyperlink{namespaceglow_a52aab7cde0b8f39f6420e1c47c57ff34}{log\+Partition\+Info} (const \hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&partitions)
\begin{DoxyCompactList}\small\item\em Log the info of current partition {\ttfamily partitions}. \end{DoxyCompactList}\item 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_a85a9500a329d096bf03201016353f1dd}{logical\+Devices\+Validation} (const \hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&partitions, const std\+::map$<$ std\+::string, \hyperlink{structglow_1_1_backend_info}{Backend\+Info} $>$ \&backend\+Map)
\item 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_a07a0a4dcd72e491d512294eec2ba422a}{memory\+Usage\+Validation} (const \hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&partitions, const std\+::map$<$ std\+::string, \hyperlink{structglow_1_1_backend_info}{Backend\+Info} $>$ \&backend\+Map)
\item 
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{namespaceglow_ad40999bf88c854e1ca4bcbfa9efbd119}{dag\+Validation} (const \hyperlink{structglow_1_1runtime_1_1_d_a_g}{D\+AG} \&dag)
\item 
\mbox{\Hypertarget{namespaceglow_a159a23dd0c029682e58c8634f5866539}\label{namespaceglow_a159a23dd0c029682e58c8634f5866539}} 
bool \hyperlink{namespaceglow_a159a23dd0c029682e58c8634f5866539}{operator$<$} (const \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} \&x, const \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} \&y)
\begin{DoxyCompactList}\small\item\em Overload $<$ operator for \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} to allow for usage with std\+::set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a3bb55fda5495f592ea57c2a223c4e0a7}\label{namespaceglow_a3bb55fda5495f592ea57c2a223c4e0a7}} 
bool \hyperlink{namespaceglow_a3bb55fda5495f592ea57c2a223c4e0a7}{operator==} (const \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} \&x, const \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} \&y)
\begin{DoxyCompactList}\small\item\em Overload == operator for \hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind} to allow for usage with std\+::set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a5c38c04977c3b94eec8b306c5a01bea1}\label{namespaceglow_a5c38c04977c3b94eec8b306c5a01bea1}} 
void \hyperlink{namespaceglow_a5c38c04977c3b94eec8b306c5a01bea1}{serialize\+To\+Yaml} (llvm\+::\+String\+Ref file\+Name, llvm\+::\+Array\+Ref$<$ \hyperlink{structglow_1_1_node_quantization_info}{Node\+Quantization\+Info} $>$ quantization\+Infos)
\begin{DoxyCompactList}\small\item\em Serialize {\ttfamily quantization\+Infos} into the file named {\ttfamily file\+Name}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a40c0a9d395ccc24594fbc8935d24fd0d}\label{namespaceglow_a40c0a9d395ccc24594fbc8935d24fd0d}} 
std\+::vector$<$ \hyperlink{structglow_1_1_node_quantization_info}{Node\+Quantization\+Info} $>$ \hyperlink{namespaceglow_a40c0a9d395ccc24594fbc8935d24fd0d}{deserialize\+From\+Yaml} (llvm\+::\+String\+Ref file\+Name)
\begin{DoxyCompactList}\small\item\em Deserialize quantization infos from the file {\ttfamily file\+Name}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_aba68dabd93fccc2d7c95db1688338f48}\label{namespaceglow_aba68dabd93fccc2d7c95db1688338f48}} 
\hyperlink{classglow_1_1_stats_exporter_registry}{Stats\+Exporter\+Registry} $\ast$ \hyperlink{namespaceglow_aba68dabd93fccc2d7c95db1688338f48}{Stats} ()
\begin{DoxyCompactList}\small\item\em Global singleton \hyperlink{classglow_1_1_stats_exporter}{Stats\+Exporter}. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceglow_a5192591d333ee1a71b03325bb3d9f80a}{is\+Current\+Debug\+Type} (const char $\ast$type)
\item 
\mbox{\Hypertarget{namespaceglow_aebce7475aa5021b9b6c5092b14f96e22}\label{namespaceglow_aebce7475aa5021b9b6c5092b14f96e22}} 
std\+::ostream \& \hyperlink{namespaceglow_aebce7475aa5021b9b6c5092b14f96e22}{operator$<$$<$} (std\+::ostream \&os, const \hyperlink{classglow_1_1float16}{float16} \&b)
\begin{DoxyCompactList}\small\item\em Allow float16\+\_\+t to be passed to an ostream. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ac962e2d08e102e7eb14c728068067e71}\label{namespaceglow_ac962e2d08e102e7eb14c728068067e71}} 
void $\ast$ \hyperlink{namespaceglow_ac962e2d08e102e7eb14c728068067e71}{aligned\+Alloc} (size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Allocate {\ttfamily size} bytes of memory aligned to {\ttfamily align} bytes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_aa1285b944f655c06ff1accf71d3ea9a5}\label{namespaceglow_aa1285b944f655c06ff1accf71d3ea9a5}} 
void \hyperlink{namespaceglow_aa1285b944f655c06ff1accf71d3ea9a5}{aligned\+Free} (void $\ast$p)
\begin{DoxyCompactList}\small\item\em Free aligned memory. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_abd4bd0099a5796fa484ffce3d628bdea}\label{namespaceglow_abd4bd0099a5796fa484ffce3d628bdea}} 
size\+\_\+t \hyperlink{namespaceglow_abd4bd0099a5796fa484ffce3d628bdea}{aligned\+Size} (size\+\_\+t size, size\+\_\+t alignment)
\begin{DoxyCompactList}\small\item\em Rounds up {\ttfamily size} to the nearest {\ttfamily alignment}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_af4cc5003864817f305e3351f82dbef78}\label{namespaceglow_af4cc5003864817f305e3351f82dbef78}} 
llvm\+::raw\+\_\+ostream \& \hyperlink{namespaceglow_af4cc5003864817f305e3351f82dbef78}{operator$<$$<$} (llvm\+::raw\+\_\+ostream \&os, void $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Convert the ptr {\ttfamily ptr} into an ascii representation in the format \char`\"{}0x\+F\+F\+F...\char`\"{}. \end{DoxyCompactList}\item 
llvm\+::raw\+\_\+ostream \& \hyperlink{namespaceglow_ae095c93d366edde27fb624fe8963e2d7}{outs} ()
\item 
llvm\+::raw\+\_\+ostream \& \hyperlink{namespaceglow_ad5afe057375ea161648698052cdeef25}{errs} ()
\item 
llvm\+::raw\+\_\+ostream \& \hyperlink{namespaceglow_a64763ac9b2b790fea832124d0b2d401a}{dbgs} ()
\item 
\mbox{\Hypertarget{namespaceglow_a3149373d4dc6e9cf35f07ce89806adb2}\label{namespaceglow_a3149373d4dc6e9cf35f07ce89806adb2}} 
{\footnotesize template$<$typename Stream , typename E $>$ }\\Stream \& \hyperlink{namespaceglow_a3149373d4dc6e9cf35f07ce89806adb2}{operator$<$$<$} (Stream \&os, const llvm\+::\+Array\+Ref$<$ E $>$ list)
\begin{DoxyCompactList}\small\item\em Stream L\+L\+VM\textquotesingle{}s Array\+Ref into the given output stream. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespaceglow_a0c9f98855ca17db059deb4688e051e61}{escape\+Dotty\+String} (const std\+::string \&str)
\item 
const char $\ast$ \hyperlink{namespaceglow_abdedf715e997af0b1a4ad4b1882bed49}{get\+Dot\+File\+Node\+Color} (size\+\_\+t index)
\item 
\mbox{\Hypertarget{namespaceglow_a321c329e831eeefea18601ae9ce56f00}\label{namespaceglow_a321c329e831eeefea18601ae9ce56f00}} 
std\+::string \hyperlink{namespaceglow_a321c329e831eeefea18601ae9ce56f00}{quote} (const std\+::string \&in)
\begin{DoxyCompactList}\small\item\em Add quotes to the string {\ttfamily in}. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespaceglow_a697c3d30b72e51fbe7d1a027a77f530c}{tolower} (const std\+::string \&in)
\item 
\mbox{\Hypertarget{namespaceglow_a9d164b45d9fb735f448cd7985bcdf203}\label{namespaceglow_a9d164b45d9fb735f448cd7985bcdf203}} 
void \hyperlink{namespaceglow_a9d164b45d9fb735f448cd7985bcdf203}{report} (const char $\ast$msg)
\begin{DoxyCompactList}\small\item\em Print {\ttfamily msg} on the error stream. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ab1b24dfac70824545414756a61885717}\label{namespaceglow_ab1b24dfac70824545414756a61885717}} 
void {\bfseries report} (const std\+::string \&str)
\item 
\mbox{\Hypertarget{namespaceglow_a9318e385e95e64e916620a62ee3310d3}\label{namespaceglow_a9318e385e95e64e916620a62ee3310d3}} 
void {\bfseries report} (llvm\+::\+String\+Ref str)
\item 
std\+::string \hyperlink{namespaceglow_aa2799bdee5e14247b8699a8dfd8f6ae9}{legalize\+Name} (llvm\+::\+String\+Ref name)
\item 
\mbox{\Hypertarget{namespaceglow_ab661c0cc5604b2acbbf8194bae5979ed}\label{namespaceglow_ab661c0cc5604b2acbbf8194bae5979ed}} 
std\+::vector$<$ \hyperlink{structglow_1_1_device_config_helper}{Device\+Config\+Helper} $>$ \hyperlink{namespaceglow_ab661c0cc5604b2acbbf8194bae5979ed}{deserialize\+Device\+Config\+From\+Yaml} (llvm\+::\+String\+Ref file\+Name)
\begin{DoxyCompactList}\small\item\em Deserialize quantization infos from the file {\ttfamily file\+Name}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a38ec6a162752e477489d4c5cbff6be28}\label{namespaceglow_a38ec6a162752e477489d4c5cbff6be28}} 
std\+::map$<$ std\+::string, std\+::string $>$ \hyperlink{namespaceglow_a38ec6a162752e477489d4c5cbff6be28}{deserialize\+Str\+Str\+Map\+From\+Yaml} (llvm\+::\+String\+Ref file\+Name)
\begin{DoxyCompactList}\small\item\em Deserialize string to string map from the file {\ttfamily file\+Name}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a6d8dd211016444e5c6014f63452c1a8a}\label{namespaceglow_a6d8dd211016444e5c6014f63452c1a8a}} 
const std\+::string \hyperlink{namespaceglow_a6d8dd211016444e5c6014f63452c1a8a}{str\+Format} (const char $\ast$format,...) \+\_\+\+\_\+attribute\+\_\+\+\_\+((\+\_\+\+\_\+format\+\_\+\+\_\+(\+\_\+\+\_\+printf\+\_\+\+\_\+
\begin{DoxyCompactList}\small\item\em Printf-\/like formatting for std\+::string. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\const std\+::string constexpr unsigned \hyperlink{namespaceglow_ab2669a16ac3c54145c294457d6554cb4}{convert\+Enum\+To\+Unsigned} (T e)
\item 
bool \hyperlink{namespaceglow_ab3c36fb4023b57b7f2ea10ac4fe9c459}{is\+Output} (const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH, const std\+::vector$<$ const \hyperlink{classglow_1_1_function}{Function} $\ast$$>$ \&funcs)
\item 
bool \hyperlink{namespaceglow_aac10131240fff18a61a4f525541fe765}{is\+Input} (const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$PH, const std\+::vector$<$ const \hyperlink{classglow_1_1_function}{Function} $\ast$$>$ \&funcs)
\item 
\mbox{\Hypertarget{namespaceglow_a57baaa229ed26f9593c1310e626b39d3}\label{namespaceglow_a57baaa229ed26f9593c1310e626b39d3}} 
{\bfseries R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+G\+L\+O\+W\+\_\+\+B\+A\+C\+K\+E\+N\+D\+\_\+\+F\+A\+C\+T\+O\+RY} (C\+P\+U\+Factory, \hyperlink{classglow_1_1_c_p_u_backend}{C\+P\+U\+Backend})
\item 
\mbox{\Hypertarget{namespaceglow_a6150442fd9a79c89605e8e0a723fad58}\label{namespaceglow_a6150442fd9a79c89605e8e0a723fad58}} 
{\bfseries R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+G\+L\+O\+W\+\_\+\+B\+A\+C\+K\+E\+N\+D\+\_\+\+F\+A\+C\+T\+O\+RY} (Habana\+Factory, \hyperlink{classglow_1_1_habana_backend}{Habana\+Backend})
\item 
\mbox{\Hypertarget{namespaceglow_a8dd862f2c2d0fa00b3d1bd9a3fdf35e4}\label{namespaceglow_a8dd862f2c2d0fa00b3d1bd9a3fdf35e4}} 
const char $\ast$ {\bfseries status\+Str} (syn\+Status status)
\item 
bool \hyperlink{namespaceglow_a9052142cd801c37c1dd49a3b139682d9}{allows64\+To32\+Downcast} (const \hyperlink{classglow_1_1_node}{Node} $\ast$src, const \hyperlink{classglow_1_1_node}{Node} $\ast$dst)
\item 
bool \hyperlink{namespaceglow_ac2c06e353dbcd4a5d2af024633fdaadb}{allows64\+To32\+Downcast} (const \hyperlink{classglow_1_1_storage}{Storage} $\ast$V, const \hyperlink{classglow_1_1_function}{Function} $\ast$F)
\item 
\mbox{\Hypertarget{namespaceglow_a627577fc0d983b88da24a4b104fd3c96}\label{namespaceglow_a627577fc0d983b88da24a4b104fd3c96}} 
{\bfseries R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+G\+L\+O\+W\+\_\+\+B\+A\+C\+K\+E\+N\+D\+\_\+\+F\+A\+C\+T\+O\+RY} (Interpreter\+Factory, \hyperlink{classglow_1_1_interpreter}{Interpreter})
\item 
\mbox{\Hypertarget{namespaceglow_aa35623fe1e4a06a0b10087a66fbed8df}\label{namespaceglow_aa35623fe1e4a06a0b10087a66fbed8df}} 
std\+::string {\bfseries I\+C\+E\+T\+Filename} ()
\item 
\mbox{\Hypertarget{namespaceglow_a9d9490be40b9bc4366d81159a7745126}\label{namespaceglow_a9d9490be40b9bc4366d81159a7745126}} 
bool {\bfseries Use\+IceT} ()
\item 
\mbox{\Hypertarget{namespaceglow_a4e0df717153aee9e88b3b93b9e7b1f20}\label{namespaceglow_a4e0df717153aee9e88b3b93b9e7b1f20}} 
bool {\bfseries Use\+Inference\+A\+PI} ()
\item 
\mbox{\Hypertarget{namespaceglow_a3ce26479e4fabd44848f6189a24ebd83}\label{namespaceglow_a3ce26479e4fabd44848f6189a24ebd83}} 
std\+::string {\bfseries Env\+Device\+Version} ()
\item 
\mbox{\Hypertarget{namespaceglow_aa1fe70fd305c5fefdd6cda83473d6c0e}\label{namespaceglow_aa1fe70fd305c5fefdd6cda83473d6c0e}} 
bool {\bfseries Symlowp\+WA} ()
\item 
\mbox{\Hypertarget{namespaceglow_ab301723a3318bf652b369645666612a8}\label{namespaceglow_ab301723a3318bf652b369645666612a8}} 
\hyperlink{classglow_1_1_backend}{Backend} $\ast$ {\bfseries create\+N\+N\+P\+I\+Backend} (const \hyperlink{structglow_1_1runtime_1_1_device_config}{runtime\+::\+Device\+Config} \&device\+Config)
\item 
\mbox{\Hypertarget{namespaceglow_a74ccf066abc84dfe97555dd2602d8724}\label{namespaceglow_a74ccf066abc84dfe97555dd2602d8724}} 
{\bfseries R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+G\+L\+O\+W\+\_\+\+B\+A\+C\+K\+E\+N\+D\+\_\+\+F\+A\+C\+T\+O\+RY} (N\+N\+P\+I\+Factory, \hyperlink{classglow_1_1_n_n_p_i_backend}{N\+N\+P\+I\+Backend})
\item 
\mbox{\Hypertarget{namespaceglow_a40768582ed3a9a8a7d8f826d4b9cd372}\label{namespaceglow_a40768582ed3a9a8a7d8f826d4b9cd372}} 
{\bfseries R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+G\+L\+O\+W\+\_\+\+B\+A\+C\+K\+E\+N\+D\+\_\+\+F\+A\+C\+T\+O\+RY} (Open\+C\+L\+Factory, \hyperlink{classglow_1_1_o_c_l_backend}{O\+C\+L\+Backend})
\item 
\mbox{\Hypertarget{namespaceglow_a1c5b3c359f0cbd0285d9f94acc95a152}\label{namespaceglow_a1c5b3c359f0cbd0285d9f94acc95a152}} 
llvm\+::cl\+::\+Option\+Category {\bfseries image\+Cat} (\char`\"{}Image Processing Options\char`\"{})
\item 
\mbox{\Hypertarget{namespaceglow_ad8bb2533645823cd73d1ed421e90de3a}\label{namespaceglow_ad8bb2533645823cd73d1ed421e90de3a}} 
llvm\+::cl\+::list$<$ float $>$ {\bfseries mean\+Values} (\char`\"{}mean\char`\"{}, llvm\+::cl\+::desc(\char`\"{}Mean values m1,m2,m3...\char`\"{} \char`\"{}Count must be equal to number of input channels.\char`\"{}), llvm\+::cl\+::value\+\_\+desc(\char`\"{}float\char`\"{}), llvm\+::cl\+::\+Zero\+Or\+More, llvm\+::cl\+::\+Comma\+Separated, llvm\+::cl\+::cat(image\+Cat))
\item 
\mbox{\Hypertarget{namespaceglow_ab005bac048df0db93a0b0b245db7a379}\label{namespaceglow_ab005bac048df0db93a0b0b245db7a379}} 
llvm\+::cl\+::list$<$ float $>$ {\bfseries stddev\+Values} (\char`\"{}stddev\char`\"{}, llvm\+::cl\+::desc(\char`\"{}Standard deviation values s1,s2,s3...\char`\"{} \char`\"{}Count must be equal to number of input channels.\char`\"{}), llvm\+::cl\+::value\+\_\+desc(\char`\"{}float\char`\"{}), llvm\+::cl\+::\+Zero\+Or\+More, llvm\+::cl\+::\+Comma\+Separated, llvm\+::cl\+::cat(image\+Cat))
\item 
\mbox{\Hypertarget{namespaceglow_aabfb8efde0ba1a6d79ba47862d4262f7}\label{namespaceglow_aabfb8efde0ba1a6d79ba47862d4262f7}} 
void {\bfseries write\+Metadata\+Helper} (llvm\+::raw\+\_\+fd\+\_\+ostream \&file, llvm\+::\+String\+Ref type, int id, llvm\+::\+String\+Ref name)
\item 
\mbox{\Hypertarget{namespaceglow_a137433bcd25bd8810ab15790e0122d52}\label{namespaceglow_a137433bcd25bd8810ab15790e0122d52}} 
{\footnotesize template$<$$>$ }\\std\+::string \hyperlink{namespaceglow_a137433bcd25bd8810ab15790e0122d52}{load\+Operator\+Name$<$ caffe2\+::\+Operator\+Def $>$} (const caffe2\+::\+Operator\+Def \&op)
\begin{DoxyCompactList}\small\item\em Template specialization of load\+Operator\+Name for \hyperlink{namespacecaffe2}{caffe2}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a66bd78e6895c5d8403fb158dfcfdc3e1}\label{namespaceglow_a66bd78e6895c5d8403fb158dfcfdc3e1}} 
llvm\+::cl\+::\+Option\+Category {\bfseries loader\+Opt\+Cat} (\char`\"{}Model \hyperlink{classglow_1_1_loader}{Loader} Options\char`\"{})
\item 
\mbox{\Hypertarget{namespaceglow_a96f58b65e79d719f8f99b784bc475ab9}\label{namespaceglow_a96f58b65e79d719f8f99b784bc475ab9}} 
\hyperlink{classglow_1_1_scheduler}{Scheduler} $\ast$ {\bfseries create\+Scheduler} (\hyperlink{namespaceglow_af5b11a9c44f948717d6a886891a58b11}{Scheduler\+Kind} scheduler\+Kind, \hyperlink{classglow_1_1_function}{Function} \&G, \hyperlink{namespaceglow_a40ec79a2f9c485bfa999ed31fd0854dd}{Nodes\+Ptr\+List} \&scheduled)
\item 
\mbox{\Hypertarget{namespaceglow_aa9c8b77b4e7f8471121f521d2440a8fb}\label{namespaceglow_aa9c8b77b4e7f8471121f521d2440a8fb}} 
bool {\bfseries sort\+Min\+Memory} (const std\+::pair$<$ \hyperlink{classglow_1_1_function}{Function} $\ast$, uint64\+\_\+t $>$ \&a, const std\+::pair$<$ \hyperlink{classglow_1_1_function}{Function} $\ast$, uint64\+\_\+t $>$ \&b)
\item 
\mbox{\Hypertarget{namespaceglow_a4e729945d88b4bfa527188a544be28ae}\label{namespaceglow_a4e729945d88b4bfa527188a544be28ae}} 
size\+\_\+t {\bfseries istream\+Read\+Func} (void $\ast$p\+Opaque, mz\+\_\+uint64 file\+\_\+ofs, void $\ast$p\+Buf, size\+\_\+t n)
\item 
\mbox{\Hypertarget{namespaceglow_a3117c43e5a5db4bb0b77626d02db0e1c}\label{namespaceglow_a3117c43e5a5db4bb0b77626d02db0e1c}} 
size\+\_\+t {\bfseries ostream\+Write\+Func} (void $\ast$p\+Opaque, mz\+\_\+uint64 file\+\_\+ofs, const void $\ast$p\+Buf, size\+\_\+t n)
\item 
bool \hyperlink{namespaceglow_a2f4b45dc331a5845df9ca8e95503c09b}{emitting\+Bundle} ()
\item 
bool \hyperlink{namespaceglow_a1945e52546b506e9c6692b42e6ff78bd}{profiling\+Graph} ()
\item 
\mbox{\Hypertarget{namespaceglow_aefc23c570ca5e61718fee9c00d1c49ee}\label{namespaceglow_aefc23c570ca5e61718fee9c00d1c49ee}} 
void \hyperlink{namespaceglow_aefc23c570ca5e61718fee9c00d1c49ee}{parse\+Command\+Line} (int argc, char $\ast$$\ast$argv)
\begin{DoxyCompactList}\small\item\em Parse/verify command line parameters. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceglow_aead878efec317164091814dc580e53bf}\label{namespaceglow_aead878efec317164091814dc580e53bf}} 
constexpr const char $\ast$ \hyperlink{namespaceglow_aead878efec317164091814dc580e53bf}{profiling\+Backend} = \char`\"{}Interpreter\char`\"{}
\begin{DoxyCompactList}\small\item\em The backend name used in Glow quantization profiling. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ad1aa614344d723c1b14942f55e0a92b4}\label{namespaceglow_ad1aa614344d723c1b14942f55e0a92b4}} 
\hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode} \hyperlink{namespaceglow_ad1aa614344d723c1b14942f55e0a92b4}{image\+Norm\+Mode}
\begin{DoxyCompactList}\small\item\em -\/image-\/mode flag. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a3f89e6d465a90abbf0dd62935035c1de}\label{namespaceglow_a3f89e6d465a90abbf0dd62935035c1de}} 
\hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order} \hyperlink{namespaceglow_a3f89e6d465a90abbf0dd62935035c1de}{image\+Channel\+Order}
\begin{DoxyCompactList}\small\item\em -\/image-\/channel-\/order flag. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a53107002ac2c9f4c49145ee80843a1da}\label{namespaceglow_a53107002ac2c9f4c49145ee80843a1da}} 
\hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout} \hyperlink{namespaceglow_a53107002ac2c9f4c49145ee80843a1da}{image\+Layout}
\begin{DoxyCompactList}\small\item\em -\/image-\/layout flag. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ae2953fbb5442af152c75ab1643f856d6}\label{namespaceglow_ae2953fbb5442af152c75ab1643f856d6}} 
bool \hyperlink{namespaceglow_ae2953fbb5442af152c75ab1643f856d6}{use\+Imagenet\+Normalization}
\begin{DoxyCompactList}\small\item\em -\/use-\/imagenet-\/normalization flag. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_a3510e99ab11ddcc872188167c4df8f4f}\label{namespaceglow_a3510e99ab11ddcc872188167c4df8f4f}} 
constexpr unsigned {\bfseries M\+A\+X\+\_\+\+D\+U\+M\+P\+\_\+\+E\+L\+E\+MS} = 100
\item 
\mbox{\Hypertarget{namespaceglow_a7f08a2140a5cc78d31a81f4562f89af5}\label{namespaceglow_a7f08a2140a5cc78d31a81f4562f89af5}} 
constexpr unsigned {\bfseries max\+\_\+tensor\+\_\+dimensions} = 6
\item 
bool \hyperlink{namespaceglow_ad352d0b626337dc5b2e9ef7593268075}{Debug\+Flag} = false
\begin{DoxyCompactList}\small\item\em Set to true if \textquotesingle{}-\/debug-\/glow\textquotesingle{} command line option is specified. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_ad1e03f233498b5c733d2c0a68ffe2d57}\label{namespaceglow_ad1e03f233498b5c733d2c0a68ffe2d57}} 
constexpr unsigned \hyperlink{namespaceglow_ad1e03f233498b5c733d2c0a68ffe2d57}{Tensor\+Alignment} = 64
\begin{DoxyCompactList}\small\item\em The tensor payload is allocated to be aligned to this value. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceglow_af9609dfd219f56d45c74ba38656f8dca}\label{namespaceglow_af9609dfd219f56d45c74ba38656f8dca}} 
bool {\bfseries Glow\+Enable\+Load\+Balanced\+Partitioning} = false
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Copyright (c) Glow Contributors. See C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS file.

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at \begin{DoxyVerb}http://www.apache.org/licenses/LICENSE-2.0
\end{DoxyVerb}


Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

Copyright (c) Glow Contributors. See C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS file.

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License.\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at \begin{DoxyVerb}http://www.apache.org/licenses/LICENSE-2.0
\end{DoxyVerb}


Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

Copyright (c) Glow Contributors. See C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS file.

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at \begin{DoxyVerb}http://www.apache.org/licenses/LICENSE-2.0
\end{DoxyVerb}


Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\+This file describes the A\+PI used for graph verification. These are mainly helper class/functions for printing errors and the related context and doing checks.

Copyright (c) Glow Contributors. See C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS file.

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at \begin{DoxyVerb}http://www.apache.org/licenses/LICENSE-2.0
\end{DoxyVerb}


Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\+N\+O\+TE\+: please only use code and macros that resides outside of the detail namespace in \hyperlink{_error_8h_source}{Error.\+h} and Error.\+cpp so as to preserve a layer of abstraction between Error/\+Expected types and the specific classes that implement them.

These hash functions are required for using llvm\+::hash\+\_\+combine. hash\+\_\+value functions should be defined in the same namespace as the types they apply to. 

\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespaceglow_a419aca63ca48becda137d774dd06493c}\label{namespaceglow_a419aca63ca48becda137d774dd06493c}} 
\index{glow@{glow}!Lowered\+Info\+Map@{Lowered\+Info\+Map}}
\index{Lowered\+Info\+Map@{Lowered\+Info\+Map}!glow@{glow}}
\subsubsection{\texorpdfstring{Lowered\+Info\+Map}{LoweredInfoMap}}
{\footnotesize\ttfamily using \hyperlink{namespaceglow_a419aca63ca48becda137d774dd06493c}{glow\+::\+Lowered\+Info\+Map} = typedef llvm\+::\+String\+Map$<$std\+::set$<$\hyperlink{structglow_1_1_node_name_and_kind}{Node\+Name\+And\+Kind}$>$ $>$}

Used to keep track of the origin of lowered Nodes via output names as determined by \hyperlink{structglow_1_1_node_quantization_info_a95eecb61266bd5b736d50b7904a6c95d}{Node\+Quantization\+Info\+::generate\+Node\+Output\+Name()}. For example if some \hyperlink{structglow_1_1_node_value}{Node\+Value} X is lowered from some \hyperlink{structglow_1_1_node_value}{Node\+Value} Y, then the output name of X is a key which maps to a set of names which contains the output name of Y. \mbox{\Hypertarget{namespaceglow_a32fc0e338408955f80a23cc7e0c0c82e}\label{namespaceglow_a32fc0e338408955f80a23cc7e0c0c82e}} 
\index{glow@{glow}!Tensor\+Initializer@{Tensor\+Initializer}}
\index{Tensor\+Initializer@{Tensor\+Initializer}!glow@{glow}}
\subsubsection{\texorpdfstring{Tensor\+Initializer}{TensorInitializer}}
{\footnotesize\ttfamily using \hyperlink{namespaceglow_a32fc0e338408955f80a23cc7e0c0c82e}{glow\+::\+Tensor\+Initializer} = typedef std\+::function$<$void( \hyperlink{classglow_1_1_function}{Function} $\ast$F, \hyperlink{classglow_1_1_node}{Node} $\ast$node, unsigned input\+Idx, \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$tensor)$>$}

\hyperlink{classglow_1_1_function}{Function} for {\ttfamily tensor} initialization. Method gets following parameters Glow \hyperlink{classglow_1_1_function}{Function} {\ttfamily F}, current {\ttfamily node}, {\ttfamily input\+Idx}, and fills out {\ttfamily tensor}. \mbox{\Hypertarget{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}\label{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}} 
\index{glow@{glow}!unsigned\+\_\+t@{unsigned\+\_\+t}}
\index{unsigned\+\_\+t@{unsigned\+\_\+t}!glow@{glow}}
\subsubsection{\texorpdfstring{unsigned\+\_\+t}{unsigned\_t}}
{\footnotesize\ttfamily using \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{glow\+::unsigned\+\_\+t} = typedef uint32\+\_\+t}

This type is used to implement the \hyperlink{classglow_1_1_node}{Node} and \hyperlink{classglow_1_1_instruction}{Instruction} builder\textquotesingle{}s Member\+Type\+::\+Unsigned and Member\+Type\+::\+Vector\+Unsigned. Thus it should be used when handling members of these classes, e.\+g. a convolution Node/\+Instr\textquotesingle{}s get\+Group() (Unsigned), or get\+Kernels() (Unsigned\+Vector). 

\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0}\label{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0}} 
\index{glow@{glow}!Convergence\+Mode@{Convergence\+Mode}}
\index{Convergence\+Mode@{Convergence\+Mode}!glow@{glow}}
\subsubsection{\texorpdfstring{Convergence\+Mode}{ConvergenceMode}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0}{glow\+::\+Convergence\+Mode}\hspace{0.3cm}{\ttfamily [strong]}}



Specifies convergence mode for a \hyperlink{classglow_1_1_function_pass}{Function\+Pass}. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{One\+Pass@{One\+Pass}!glow@{glow}}\index{glow@{glow}!One\+Pass@{One\+Pass}}}\mbox{\Hypertarget{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0accd4cef52fe08da3eeac0e4396a2aca2}\label{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0accd4cef52fe08da3eeac0e4396a2aca2}} 
One\+Pass&Run a single pass over the \hyperlink{classglow_1_1_function}{Function}. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Until\+Fixed\+Point@{Until\+Fixed\+Point}!glow@{glow}}\index{glow@{glow}!Until\+Fixed\+Point@{Until\+Fixed\+Point}}}\mbox{\Hypertarget{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0a1a3fe1603e0a452b098a101b7d833f87}\label{namespaceglow_a56845b9c860fa69d01d2084361d7c1f0a1a3fe1603e0a452b098a101b7d833f87}} 
Until\+Fixed\+Point&Run the pass over the \hyperlink{classglow_1_1_function}{Function} until a fixed point is reached. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{namespaceglow_a6b85539f22b3e3292adf202254f0da1e}\label{namespaceglow_a6b85539f22b3e3292adf202254f0da1e}} 
\index{glow@{glow}!D\+C\+E\+Required\+Mode@{D\+C\+E\+Required\+Mode}}
\index{D\+C\+E\+Required\+Mode@{D\+C\+E\+Required\+Mode}!glow@{glow}}
\subsubsection{\texorpdfstring{D\+C\+E\+Required\+Mode}{DCERequiredMode}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_a6b85539f22b3e3292adf202254f0da1e}{glow\+::\+D\+C\+E\+Required\+Mode}\hspace{0.3cm}{\ttfamily [strong]}}



Specifies whether the pass requires D\+CE. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Before\+Pass@{Before\+Pass}!glow@{glow}}\index{glow@{glow}!Before\+Pass@{Before\+Pass}}}\mbox{\Hypertarget{namespaceglow_a6b85539f22b3e3292adf202254f0da1eaff7ad7af6ac42e36a5d538e74cde072d}\label{namespaceglow_a6b85539f22b3e3292adf202254f0da1eaff7ad7af6ac42e36a5d538e74cde072d}} 
Before\+Pass&Require that D\+CE is run before the pass. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{None@{None}!glow@{glow}}\index{glow@{glow}!None@{None}}}\mbox{\Hypertarget{namespaceglow_a6b85539f22b3e3292adf202254f0da1ea6adf97f83acf6453d4a6a4b1070f3754}\label{namespaceglow_a6b85539f22b3e3292adf202254f0da1ea6adf97f83acf6453d4a6a4b1070f3754}} 
None&Signify the pass has no requirement/dependence on D\+CE. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}\label{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}} 
\index{glow@{glow}!Elem\+Kind@{Elem\+Kind}}
\index{Elem\+Kind@{Elem\+Kind}!glow@{glow}}
\subsubsection{\texorpdfstring{Elem\+Kind}{ElemKind}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{glow\+::\+Elem\+Kind} \+: unsigned char\hspace{0.3cm}{\ttfamily [strong]}}

An enum representing the type used by the elements of a tensor. The types of Handles for these tensors should match the element kind. When adding new type, note that this enum definition must match with Elem\+Kind definition in Glow/lib/\+Backends/\+C\+P\+U/libjit/libjit.\+cpp \mbox{\Hypertarget{namespaceglow_a3157945b92abd634c79fa9d4724472eb}\label{namespaceglow_a3157945b92abd634c79fa9d4724472eb}} 
\index{glow@{glow}!Function\+Pass\+ID@{Function\+Pass\+ID}}
\index{Function\+Pass\+ID@{Function\+Pass\+ID}!glow@{glow}}
\subsubsection{\texorpdfstring{Function\+Pass\+ID}{FunctionPassID}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_a3157945b92abd634c79fa9d4724472eb}{glow\+::\+Function\+Pass\+ID}\hspace{0.3cm}{\ttfamily [strong]}}

Define an enum to identify all Function\+Passes, used to declare inside a \hyperlink{classglow_1_1_function_pass_config}{Function\+Pass\+Config} for a Pipeline. \mbox{\Hypertarget{namespaceglow_a1c98da7214165b41c7d6b255503d4062}\label{namespaceglow_a1c98da7214165b41c7d6b255503d4062}} 
\index{glow@{glow}!Function\+State@{Function\+State}}
\index{Function\+State@{Function\+State}!glow@{glow}}
\subsubsection{\texorpdfstring{Function\+State}{FunctionState}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_a1c98da7214165b41c7d6b255503d4062}{glow\+::\+Function\+State}\hspace{0.3cm}{\ttfamily [strong]}}

State of a function. This can be used to control optimizations which depend on the state of the \hyperlink{classglow_1_1_function}{Function}. This is a temporary workaround until GH Issue \#3213 is complete. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Func\+Created@{Func\+Created}!glow@{glow}}\index{glow@{glow}!Func\+Created@{Func\+Created}}}\mbox{\Hypertarget{namespaceglow_a1c98da7214165b41c7d6b255503d4062a3c96962620eddda2836d6203cf7ecfa0}\label{namespaceglow_a1c98da7214165b41c7d6b255503d4062a3c96962620eddda2836d6203cf7ecfa0}} 
Func\+Created&Indicates that the function has been created but not completely loaded. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Func\+Loaded@{Func\+Loaded}!glow@{glow}}\index{glow@{glow}!Func\+Loaded@{Func\+Loaded}}}\mbox{\Hypertarget{namespaceglow_a1c98da7214165b41c7d6b255503d4062ae25a0b7e15a925b8bf4d8016db8d27ac}\label{namespaceglow_a1c98da7214165b41c7d6b255503d4062ae25a0b7e15a925b8bf4d8016db8d27ac}} 
Func\+Loaded&Indicates that the function has been completely loaded. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{namespaceglow_ab04a18d4367765236e5de54c47379e66}\label{namespaceglow_ab04a18d4367765236e5de54c47379e66}} 
\index{glow@{glow}!Memory\+Area\+Kind@{Memory\+Area\+Kind}}
\index{Memory\+Area\+Kind@{Memory\+Area\+Kind}!glow@{glow}}
\subsubsection{\texorpdfstring{Memory\+Area\+Kind}{MemoryAreaKind}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_ab04a18d4367765236e5de54c47379e66}{glow\+::\+Memory\+Area\+Kind}}

Different kinds of memory areas used by the emitted L\+L\+VM function. The order is important. It should match the order of base addresses arguments passed to \char`\"{}main\char`\"{}. \mbox{\Hypertarget{namespaceglow_af5b11a9c44f948717d6a886891a58b11}\label{namespaceglow_af5b11a9c44f948717d6a886891a58b11}} 
\index{glow@{glow}!Scheduler\+Kind@{Scheduler\+Kind}}
\index{Scheduler\+Kind@{Scheduler\+Kind}!glow@{glow}}
\subsubsection{\texorpdfstring{Scheduler\+Kind}{SchedulerKind}}
{\footnotesize\ttfamily enum \hyperlink{namespaceglow_af5b11a9c44f948717d6a886891a58b11}{glow\+::\+Scheduler\+Kind}\hspace{0.3cm}{\ttfamily [strong]}}



Specifies the kind of graph scheduling to perform. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Child\+Mem\+Size\+Based@{Child\+Mem\+Size\+Based}!glow@{glow}}\index{glow@{glow}!Child\+Mem\+Size\+Based@{Child\+Mem\+Size\+Based}}}\mbox{\Hypertarget{namespaceglow_af5b11a9c44f948717d6a886891a58b11aca8f7fd5d3a60fdbaaa2f584621c7759}\label{namespaceglow_af5b11a9c44f948717d6a886891a58b11aca8f7fd5d3a60fdbaaa2f584621c7759}} 
Child\+Mem\+Size\+Based&This is a heuristics that tries to minimize memory usage. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Topological\+Sort\+Based@{Topological\+Sort\+Based}!glow@{glow}}\index{glow@{glow}!Topological\+Sort\+Based@{Topological\+Sort\+Based}}}\mbox{\Hypertarget{namespaceglow_af5b11a9c44f948717d6a886891a58b11afc2c746e636936c8ce50270012da3147}\label{namespaceglow_af5b11a9c44f948717d6a886891a58b11afc2c746e636936c8ce50270012da3147}} 
Topological\+Sort\+Based&Performs a standard topological search. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceglow_a9052142cd801c37c1dd49a3b139682d9}\label{namespaceglow_a9052142cd801c37c1dd49a3b139682d9}} 
\index{glow@{glow}!allows64\+To32\+Downcast@{allows64\+To32\+Downcast}}
\index{allows64\+To32\+Downcast@{allows64\+To32\+Downcast}!glow@{glow}}
\subsubsection{\texorpdfstring{allows64\+To32\+Downcast()}{allows64To32Downcast()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool glow\+::allows64\+To32\+Downcast (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{src,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{dst }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if {\ttfamily dst} allows {\ttfamily src} to be converted from 64 to 32 bits. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ac2c06e353dbcd4a5d2af024633fdaadb}\label{namespaceglow_ac2c06e353dbcd4a5d2af024633fdaadb}} 
\index{glow@{glow}!allows64\+To32\+Downcast@{allows64\+To32\+Downcast}}
\index{allows64\+To32\+Downcast@{allows64\+To32\+Downcast}!glow@{glow}}
\subsubsection{\texorpdfstring{allows64\+To32\+Downcast()}{allows64To32Downcast()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool glow\+::allows64\+To32\+Downcast (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_storage}{Storage} $\ast$}]{V,  }\item[{const \hyperlink{classglow_1_1_function}{Function} $\ast$}]{F }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if {\ttfamily V} can be converted from a 64 to 32 bit value at runtime. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_adce5a7edd1093d119dbed94a5dce5cdf}\label{namespaceglow_adce5a7edd1093d119dbed94a5dce5cdf}} 
\index{glow@{glow}!assign\+Logical\+Device\+ID@{assign\+Logical\+Device\+ID}}
\index{assign\+Logical\+Device\+ID@{assign\+Logical\+Device\+ID}!glow@{glow}}
\subsubsection{\texorpdfstring{assign\+Logical\+Device\+I\+D()}{assignLogicalDeviceID()}}
{\footnotesize\ttfamily Device\+I\+D\+Ty glow\+::assign\+Logical\+Device\+ID (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&}]{mapping,  }\item[{const std\+::map$<$ std\+::string, \hyperlink{structglow_1_1_backend_info}{Backend\+Info} $>$ \&}]{backend\+Map }\end{DoxyParamCaption})}

Assign the logical\+Device ID to each partition. The partitions with the same logical\+Device ID will be assigned on the same physical devices. E.\+g\+: there are 3 partitions node1(6\+G\+B) -\/$>$ node2(14\+G\+B) -\/$>$ node3(6\+G\+B). But we only have 2 devices with 16\+GB memory. The logical\+Device ID assigning rules are\+:
\begin{DoxyEnumerate}
\item For each type of backend, if the number of available physical devices is equal or larger than the number of partitions, different partitions are assigned with a different logical\+Device ID(i.\+e. each partition will be put on a different physical device for execution). E.\+g. we have 3 partitions node1-\/$>$node2-\/$>$node3, and 3 devices, the logical\+Device ID for each partition with be (node1, 0), (node2, 1), and (node3, 2).
\item For each type of backend, if the number of available physical devices is smaller than the number of partitions, and we can find a way to put all partitions on those pysical devices, this assignment will be applied and the partitions on the same physical devices will be assigned the same logical\+Device ID. E.\+g\+: there are 3 partitions node1(6\+G\+B) -\/$>$ node2(14\+G\+B) -\/$>$ node3(6\+G\+B). But we only have 2 devices with 16\+GB memory. The assignment will be \+: (node1, 0), (node2, 1), (node3, 0).
\item For each type of backend, if the number of available physical devices is smaller than the number of partitions, and we can not find a way to put all partitions on those pysical devices, we assign defferent partitions with different logical\+Device ID. E.\+g\+: there are 3 partitions node1(6\+G\+B) -\/$>$ node2(14\+G\+B) -\/$>$ node3(6\+G\+B). But we only have 1 device with 16\+GB memory. The assignment will be \+: (node1, 0), (node2, 1), (node3, 2). That is, even we can put node1 and node3 on the same device, we won\textquotesingle{}t do it. 
\end{DoxyEnumerate}\mbox{\Hypertarget{namespaceglow_a110f6a4f4c9801ecca0c96826b3888ff}\label{namespaceglow_a110f6a4f4c9801ecca0c96826b3888ff}} 
\index{glow@{glow}!calculate3\+D\+Conv\+Pool\+Output\+Dims@{calculate3\+D\+Conv\+Pool\+Output\+Dims}}
\index{calculate3\+D\+Conv\+Pool\+Output\+Dims@{calculate3\+D\+Conv\+Pool\+Output\+Dims}!glow@{glow}}
\subsubsection{\texorpdfstring{calculate3\+D\+Conv\+Pool\+Output\+Dims()}{calculate3DConvPoolOutputDims()}}
{\footnotesize\ttfamily \hyperlink{structglow_1_1_shape_h_w_d}{Shape\+H\+WD} glow\+::calculate3\+D\+Conv\+Pool\+Output\+Dims (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{inH,  }\item[{size\+\_\+t}]{inW,  }\item[{size\+\_\+t}]{inD,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{kernels,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{strides,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{pads }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Calculate the size of the output tensor based on the 3D convolution/pooling parameters {\ttfamily inH} {\ttfamily inW}, {\ttfamily inT} which are the input\textquotesingle{}s height, width, and depth respectively. \mbox{\Hypertarget{namespaceglow_a3623979e9cf3437802bf2f23d15b425e}\label{namespaceglow_a3623979e9cf3437802bf2f23d15b425e}} 
\index{glow@{glow}!calculate\+Conv\+Pool\+Output\+Dims@{calculate\+Conv\+Pool\+Output\+Dims}}
\index{calculate\+Conv\+Pool\+Output\+Dims@{calculate\+Conv\+Pool\+Output\+Dims}!glow@{glow}}
\subsubsection{\texorpdfstring{calculate\+Conv\+Pool\+Output\+Dims()}{calculateConvPoolOutputDims()}}
{\footnotesize\ttfamily std\+::pair$<$size\+\_\+t, size\+\_\+t$>$ glow\+::calculate\+Conv\+Pool\+Output\+Dims (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{sx,  }\item[{size\+\_\+t}]{sy,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{kernels,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{strides,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{pads,  }\item[{\hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t}}]{dilation = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Calculate the size of the output tensor based on the convolution/pooling parameters. \mbox{\Hypertarget{namespaceglow_ab310f352073eee80ddb68b3cfaa14e12}\label{namespaceglow_ab310f352073eee80ddb68b3cfaa14e12}} 
\index{glow@{glow}!check\+No\+Fusion@{check\+No\+Fusion}}
\index{check\+No\+Fusion@{check\+No\+Fusion}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+No\+Fusion()}{checkNoFusion()}}
{\footnotesize\ttfamily template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$!has\+\_\+get\+Fused\+Activation$<$ T, Fused\+Activation $>$\+::value, int $>$  = 0$>$ \\
bool glow\+::check\+No\+Fusion (\begin{DoxyParamCaption}\item[{const T \&}]{N }\end{DoxyParamCaption})}



If {\ttfamily N} does not have fused activation. 

\begin{DoxyReturn}{Returns}
true. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a740e326204223c25d80b8b07e99dac18}\label{namespaceglow_a740e326204223c25d80b8b07e99dac18}} 
\index{glow@{glow}!check\+No\+Fusion\+For\+Instr@{check\+No\+Fusion\+For\+Instr}}
\index{check\+No\+Fusion\+For\+Instr@{check\+No\+Fusion\+For\+Instr}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+No\+Fusion\+For\+Instr()}{checkNoFusionForInstr()}}
{\footnotesize\ttfamily bool glow\+::check\+No\+Fusion\+For\+Instr (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_instruction}{Instruction} \&}]{I }\end{DoxyParamCaption})}



If {\ttfamily I} does not have fused activation. 

\begin{DoxyReturn}{Returns}
true. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ad4ca93d79211ec0bc67ed8524634e69a}\label{namespaceglow_ad4ca93d79211ec0bc67ed8524634e69a}} 
\index{glow@{glow}!check\+No\+Fusion\+For\+Node@{check\+No\+Fusion\+For\+Node}}
\index{check\+No\+Fusion\+For\+Node@{check\+No\+Fusion\+For\+Node}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+No\+Fusion\+For\+Node()}{checkNoFusionForNode()}}
{\footnotesize\ttfamily bool glow\+::check\+No\+Fusion\+For\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node}{Node} \&}]{N }\end{DoxyParamCaption})}



If {\ttfamily N} does not have fused activation. 

\begin{DoxyReturn}{Returns}
true. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a4b41db469b7a600c65a7e57665a72474}\label{namespaceglow_a4b41db469b7a600c65a7e57665a72474}} 
\index{glow@{glow}!check\+Not\+Quantized\+Or\+Same\+Params@{check\+Not\+Quantized\+Or\+Same\+Params}}
\index{check\+Not\+Quantized\+Or\+Same\+Params@{check\+Not\+Quantized\+Or\+Same\+Params}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Not\+Quantized\+Or\+Same\+Params()}{checkNotQuantizedOrSameParams()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool glow\+::check\+Not\+Quantized\+Or\+Same\+Params (\begin{DoxyParamCaption}\item[{const \hyperlink{structglow_1_1_type}{Type\+Ref}}]{A,  }\item[{float}]{scale,  }\item[{int32\+\_\+t}]{offset,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
True if {\ttfamily A} is not quantized or has its quantization parameters match {\ttfamily scale} and {\ttfamily offset}. False otherwise. {\ttfamily parent} is used to print the context of that check in case the it fails. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_a3b27e9f4187aa476d1a4f3414b4f5dcb}\label{namespaceglow_a3b27e9f4187aa476d1a4f3414b4f5dcb}} 
\index{glow@{glow}!check\+Not\+Quantized\+Or\+Same\+Params@{check\+Not\+Quantized\+Or\+Same\+Params}}
\index{check\+Not\+Quantized\+Or\+Same\+Params@{check\+Not\+Quantized\+Or\+Same\+Params}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Not\+Quantized\+Or\+Same\+Params()}{checkNotQuantizedOrSameParams()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool glow\+::check\+Not\+Quantized\+Or\+Same\+Params (\begin{DoxyParamCaption}\item[{const \hyperlink{structglow_1_1_type}{Type\+Ref}}]{A,  }\item[{const \hyperlink{structglow_1_1_type}{Type\+Ref}}]{B,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
True if {\ttfamily A} is not quantized or matches {\ttfamily B} quantization parameters. False otherwise. In particular, this returns false if {\ttfamily A} is quantized and {\ttfamily B} is not. The opposite is not true. {\ttfamily parent} is used to print the context of that check in case the it fails. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_a9d3dd221c6d43bfa4d2e54ff8640604b}\label{namespaceglow_a9d3dd221c6d43bfa4d2e54ff8640604b}} 
\index{glow@{glow}!check\+Same\+Is\+Quantized@{check\+Same\+Is\+Quantized}}
\index{check\+Same\+Is\+Quantized@{check\+Same\+Is\+Quantized}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Same\+Is\+Quantized()}{checkSameIsQuantized()}}
{\footnotesize\ttfamily bool glow\+::check\+Same\+Is\+Quantized (\begin{DoxyParamCaption}\item[{const \hyperlink{structglow_1_1_type}{Type\+Ref}}]{A,  }\item[{const \hyperlink{structglow_1_1_type}{Type\+Ref}}]{B,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

Check if {\ttfamily A} and {\ttfamily B} have the same value for is\+Quantized. {\ttfamily parent} is used to print the context of that check in case the it fails. \begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_ae06ad0f896240c6ccea6cb9472e57e2a}\label{namespaceglow_ae06ad0f896240c6ccea6cb9472e57e2a}} 
\index{glow@{glow}!check\+Same\+Shape@{check\+Same\+Shape}}
\index{check\+Same\+Shape@{check\+Same\+Shape}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Same\+Shape()}{checkSameShape()}}
{\footnotesize\ttfamily bool glow\+::check\+Same\+Shape (\begin{DoxyParamCaption}\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{A,  }\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{B,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

Check that the shape of the first operand {\ttfamily A} matches the shape of the second operand {\ttfamily B}. {\ttfamily parent} is used to print the context of that check in case the it fails. \begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_a1963e99917ffdb1fdd70911811002792}\label{namespaceglow_a1963e99917ffdb1fdd70911811002792}} 
\index{glow@{glow}!check\+Same\+Type@{check\+Same\+Type}}
\index{check\+Same\+Type@{check\+Same\+Type}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Same\+Type()}{checkSameType()}}
{\footnotesize\ttfamily bool glow\+::check\+Same\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{A,  }\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{B,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

Check that the type of the first operand {\ttfamily A} matches the type of the second operand {\ttfamily B}. {\ttfamily parent} is used to print the context of that check in case the it fails. \begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_a5321bd4a40acf901a0d9b8eb2e25f4ae}\label{namespaceglow_a5321bd4a40acf901a0d9b8eb2e25f4ae}} 
\index{glow@{glow}!check\+Type@{check\+Type}}
\index{check\+Type@{check\+Type}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Type()}{checkType()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool glow\+::check\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{A,  }\item[{\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind}}]{expected\+Type,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

Check that the element type of the operand {\ttfamily A} matches expected type {\ttfamily expected\+Type}. {\ttfamily parent} is used to print the context of that check in case the it fails. \begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_a06107a1368ca70c82884f7a7863a0599}\label{namespaceglow_a06107a1368ca70c82884f7a7863a0599}} 
\index{glow@{glow}!check\+Type@{check\+Type}}
\index{check\+Type@{check\+Type}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Type()}{checkType()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool glow\+::check\+Type (\begin{DoxyParamCaption}\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{A,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} $>$}]{expected\+Types,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

Check that the element type of the operand {\ttfamily A} matches any of the expected types {\ttfamily expected\+Types}. {\ttfamily parent} is used to print the context of that check in case the it fails. \begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_abfafc7403160bca58a7672d68c2d944d}\label{namespaceglow_abfafc7403160bca58a7672d68c2d944d}} 
\index{glow@{glow}!check\+Type\+Ignore\+Shape@{check\+Type\+Ignore\+Shape}}
\index{check\+Type\+Ignore\+Shape@{check\+Type\+Ignore\+Shape}!glow@{glow}}
\subsubsection{\texorpdfstring{check\+Type\+Ignore\+Shape()}{checkTypeIgnoreShape()}}
{\footnotesize\ttfamily bool glow\+::check\+Type\+Ignore\+Shape (\begin{DoxyParamCaption}\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{A,  }\item[{\hyperlink{structglow_1_1_node_value}{Node\+Value}}]{B,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent }\end{DoxyParamCaption})}

Check that the type of the first operand {\ttfamily A} matches the type of the second operand {\ttfamily B} but ignore the actual shape. \hyperlink{structglow_1_1_use}{Use} only element type and quantization parameters in comparison. {\ttfamily parent} is used to print the context of that check in case the it fails. \begin{DoxySeeAlso}{See also}
\hyperlink{namespaceglow_afd8e77c649bf3668467058ae071bb875}{expect\+Compare\+True} for more details. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{namespaceglow_a0e523cb23b972dda0c52eb9c841a1d33}\label{namespaceglow_a0e523cb23b972dda0c52eb9c841a1d33}} 
\index{glow@{glow}!constant\+Fold@{constant\+Fold}}
\index{constant\+Fold@{constant\+Fold}!glow@{glow}}
\subsubsection{\texorpdfstring{constant\+Fold()}{constantFold()}}
{\footnotesize\ttfamily std\+::vector$<$ \hyperlink{classglow_1_1_constant}{Constant} $\ast$ $>$ glow\+::constant\+Fold (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_node}{Node} $\ast$}]{N }\end{DoxyParamCaption})}

Perform a compile-\/time constant folding of the node {\ttfamily N}. \begin{DoxyReturn}{Returns}
list of constants which are the result of the constant-\/folding. These constants correspond to results of the node. If no constant folding was possible an empty vector will be returned. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a6f10f8f52d528b3ceb40892376bc1fb9}\label{namespaceglow_a6f10f8f52d528b3ceb40892376bc1fb9}} 
\index{glow@{glow}!constant\+Fold\+In\+Loader@{constant\+Fold\+In\+Loader}}
\index{constant\+Fold\+In\+Loader@{constant\+Fold\+In\+Loader}!glow@{glow}}
\subsubsection{\texorpdfstring{constant\+Fold\+In\+Loader()}{constantFoldInLoader()}}
{\footnotesize\ttfamily template$<$class Loader\+Type , class Op\+Type $>$ \\
\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::constant\+Fold\+In\+Loader (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{Loader\+Type \&}]{tmp\+Loader,  }\item[{Loader\+Type $\ast$}]{loader,  }\item[{const Op\+Type \&}]{op }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
success if the folding of operator {\ttfamily op} in the loader {\ttfamily loader} is successful. The folding utility uses temporary loader {\ttfamily tmp\+Loader}, and associated temporary function {\ttfamily F}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a277fade8bad1b16fc8c084ce52ba6f92}\label{namespaceglow_a277fade8bad1b16fc8c084ce52ba6f92}} 
\index{glow@{glow}!convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad@{convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad}}
\index{convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad@{convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad}!glow@{glow}}
\subsubsection{\texorpdfstring{convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad()}{convertConvGradToNCHWConvGrad()}}
{\footnotesize\ttfamily std\+::tuple$<$\hyperlink{structglow_1_1_node_value}{Node\+Value}, \hyperlink{structglow_1_1_node_value}{Node\+Value}, \hyperlink{structglow_1_1_node_value}{Node\+Value}$>$ glow\+::convert\+Conv\+Grad\+To\+N\+C\+H\+W\+Conv\+Grad (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_convolution_grad_node}{Convolution\+Grad\+Node} $\ast$}]{C\+GN,  }\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Convert regular \hyperlink{classglow_1_1_convolution_grad_node}{Convolution\+Grad\+Node} that uses N\+H\+WC into a \hyperlink{classglow_1_1_convolution_grad_node}{Convolution\+Grad\+Node} that uses N\+C\+HW. \mbox{\Hypertarget{namespaceglow_aeac40bd989fd3bcb403ecfbf8c120600}\label{namespaceglow_aeac40bd989fd3bcb403ecfbf8c120600}} 
\index{glow@{glow}!convert\+Conv\+To\+N\+C\+H\+W\+Conv@{convert\+Conv\+To\+N\+C\+H\+W\+Conv}}
\index{convert\+Conv\+To\+N\+C\+H\+W\+Conv@{convert\+Conv\+To\+N\+C\+H\+W\+Conv}!glow@{glow}}
\subsubsection{\texorpdfstring{convert\+Conv\+To\+N\+C\+H\+W\+Conv()}{convertConvToNCHWConv()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_node}{Node}$\ast$ glow\+::convert\+Conv\+To\+N\+C\+H\+W\+Conv (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_convolution_node}{Convolution\+Node} $\ast$}]{CN,  }\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Convert regular convolution nodes (that use N\+H\+WC) into a backend-\/specific convolution nodes using N\+C\+HW. \mbox{\Hypertarget{namespaceglow_ab2669a16ac3c54145c294457d6554cb4}\label{namespaceglow_ab2669a16ac3c54145c294457d6554cb4}} 
\index{glow@{glow}!convert\+Enum\+To\+Unsigned@{convert\+Enum\+To\+Unsigned}}
\index{convert\+Enum\+To\+Unsigned@{convert\+Enum\+To\+Unsigned}!glow@{glow}}
\subsubsection{\texorpdfstring{convert\+Enum\+To\+Unsigned()}{convertEnumToUnsigned()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
const std\+::string constexpr unsigned glow\+::convert\+Enum\+To\+Unsigned (\begin{DoxyParamCaption}\item[{T}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Helper that converts and \begin{DoxyReturn}{Returns}
an enum class to an unsigned. Useful when using an enum class in a bitset. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aef265ed4d4604e471d8b5662c3f5a423}\label{namespaceglow_aef265ed4d4604e471d8b5662c3f5a423}} 
\index{glow@{glow}!convert\+Function\+To\+Float16@{convert\+Function\+To\+Float16}}
\index{convert\+Function\+To\+Float16@{convert\+Function\+To\+Float16}!glow@{glow}}
\subsubsection{\texorpdfstring{convert\+Function\+To\+Float16()}{convertFunctionToFloat16()}}
{\footnotesize\ttfamily void glow\+::convert\+Function\+To\+Float16 (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{const \hyperlink{structglow_1_1_precision_configuration}{Precision\+Configuration} \&}]{prec\+Config }\end{DoxyParamCaption})}

Converts all inputs and outputs of a function {\ttfamily F} from Float to Float16, and from U\+Int8\+Fused\+Q\+Ty to U\+Int8\+Fused\+F\+P16\+Q\+Ty, based on {\ttfamily prec\+Config}. \mbox{\Hypertarget{namespaceglow_a67b90e6ec31547354c4e796d906cebd0}\label{namespaceglow_a67b90e6ec31547354c4e796d906cebd0}} 
\index{glow@{glow}!convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool@{convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool}}
\index{convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool@{convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool}!glow@{glow}}
\subsubsection{\texorpdfstring{convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool()}{convertMaxPoolToNCHWPool()}}
{\footnotesize\ttfamily std\+::pair$<$\hyperlink{classglow_1_1_node}{Node} $\ast$, \hyperlink{classglow_1_1_node}{Node} $\ast$$>$ glow\+::convert\+Max\+Pool\+To\+N\+C\+H\+W\+Pool (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_max_pool_node}{Max\+Pool\+Node} $\ast$}]{PN,  }\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Convert regular max pool nodes (that use N\+H\+WC) into backend-\/specific nodes using N\+C\+HW. \begin{DoxyReturn}{Returns}
a pair containing the new Max\+Pool result and argmax that the result and argmax of the original Max\+Pool should be replaced with. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a7c4fddd8b31e37460f88d44f076a2863}\label{namespaceglow_a7c4fddd8b31e37460f88d44f076a2863}} 
\index{glow@{glow}!convert\+Placeholders\+To\+Constants@{convert\+Placeholders\+To\+Constants}}
\index{convert\+Placeholders\+To\+Constants@{convert\+Placeholders\+To\+Constants}!glow@{glow}}
\subsubsection{\texorpdfstring{convert\+Placeholders\+To\+Constants()}{convertPlaceholdersToConstants()}}
{\footnotesize\ttfamily void glow\+::convert\+Placeholders\+To\+Constants (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{const \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$$>$}]{vars }\end{DoxyParamCaption})}

Convert placeholders in \hyperlink{classglow_1_1_module}{Module} {\ttfamily M} to constants based on the values in {\ttfamily bindings}. Do not convert any placeholders explicitly listed in {\ttfamily vars}. \mbox{\Hypertarget{namespaceglow_a9e0b594543fb42b8b6ad0cc556ee9829}\label{namespaceglow_a9e0b594543fb42b8b6ad0cc556ee9829}} 
\index{glow@{glow}!create\+Default\+Fold\+Pass\+Pipeline@{create\+Default\+Fold\+Pass\+Pipeline}}
\index{create\+Default\+Fold\+Pass\+Pipeline@{create\+Default\+Fold\+Pass\+Pipeline}!glow@{glow}}
\subsubsection{\texorpdfstring{create\+Default\+Fold\+Pass\+Pipeline()}{createDefaultFoldPassPipeline()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline} glow\+::create\+Default\+Fold\+Pass\+Pipeline (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the default fold pipeline. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_afd7544cbea4219b8f3c720d6a4e19481}\label{namespaceglow_afd7544cbea4219b8f3c720d6a4e19481}} 
\index{glow@{glow}!create\+Default\+Graph\+Optimization\+Pass\+Pipeline@{create\+Default\+Graph\+Optimization\+Pass\+Pipeline}}
\index{create\+Default\+Graph\+Optimization\+Pass\+Pipeline@{create\+Default\+Graph\+Optimization\+Pass\+Pipeline}!glow@{glow}}
\subsubsection{\texorpdfstring{create\+Default\+Graph\+Optimization\+Pass\+Pipeline()}{createDefaultGraphOptimizationPassPipeline()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline} glow\+::create\+Default\+Graph\+Optimization\+Pass\+Pipeline (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the default, target-\/independent graph optimization pipeline 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a2cba8b151906d972e63ced04b7e02242}\label{namespaceglow_a2cba8b151906d972e63ced04b7e02242}} 
\index{glow@{glow}!create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline@{create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline}}
\index{create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline@{create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline}!glow@{glow}}
\subsubsection{\texorpdfstring{create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline()}{createFP16GraphOptimizationPassPipeline()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_function_pass_pipeline}{Function\+Pass\+Pipeline} glow\+::create\+F\+P16\+Graph\+Optimization\+Pass\+Pipeline (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the fp16 specific optimization pipeline 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a77f32741a0e156b7bd043992d6eedc6c}\label{namespaceglow_a77f32741a0e156b7bd043992d6eedc6c}} 
\index{glow@{glow}!create\+Function\+Pass@{create\+Function\+Pass}}
\index{create\+Function\+Pass@{create\+Function\+Pass}!glow@{glow}}
\subsubsection{\texorpdfstring{create\+Function\+Pass()}{createFunctionPass()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$\hyperlink{classglow_1_1_function_pass}{Function\+Pass}$>$ glow\+::create\+Function\+Pass (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceglow_a3157945b92abd634c79fa9d4724472eb}{Function\+Pass\+ID}}]{pass\+ID }\end{DoxyParamCaption})}



Helper that creates and. 

Copyright (c) Glow Contributors. See C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS file.

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at \begin{DoxyVerb}http://www.apache.org/licenses/LICENSE-2.0
\end{DoxyVerb}


Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. \begin{DoxyReturn}{Returns}
a \hyperlink{classglow_1_1_function_pass}{Function\+Pass} given a provided {\ttfamily pass\+ID}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ad40999bf88c854e1ca4bcbfa9efbd119}\label{namespaceglow_ad40999bf88c854e1ca4bcbfa9efbd119}} 
\index{glow@{glow}!dag\+Validation@{dag\+Validation}}
\index{dag\+Validation@{dag\+Validation}!glow@{glow}}
\subsubsection{\texorpdfstring{dag\+Validation()}{dagValidation()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::dag\+Validation (\begin{DoxyParamCaption}\item[{const \hyperlink{structglow_1_1runtime_1_1_d_a_g}{D\+AG} \&}]{dag }\end{DoxyParamCaption})}

Check if the current partition is a valid D\+AG. This check can only be called after a real partition is created and the D\+AG is generated. \mbox{\Hypertarget{namespaceglow_a64763ac9b2b790fea832124d0b2d401a}\label{namespaceglow_a64763ac9b2b790fea832124d0b2d401a}} 
\index{glow@{glow}!dbgs@{dbgs}}
\index{dbgs@{dbgs}!glow@{glow}}
\subsubsection{\texorpdfstring{dbgs()}{dbgs()}}
{\footnotesize\ttfamily llvm\+::raw\+\_\+ostream \& glow\+::dbgs (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
output stream for debug messages. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a8d2a21b045e4c1595f1da56d34750169}\label{namespaceglow_a8d2a21b045e4c1595f1da56d34750169}} 
\index{glow@{glow}!differentiate@{differentiate}}
\index{differentiate@{differentiate}!glow@{glow}}
\subsubsection{\texorpdfstring{differentiate()}{differentiate()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_function}{Function} $\ast$ glow\+::differentiate (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{const \hyperlink{structglow_1_1_training_config}{Training\+Config} \&}]{config,  }\item[{llvm\+::\+String\+Ref}]{new\+Func\+Name = {\ttfamily \char`\"{}\char`\"{}},  }\item[{Variable\+Gradients\+List $\ast$}]{var\+Grads = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Create a new \hyperlink{classglow_1_1_function}{Function} that \textquotesingle{}trains\textquotesingle{} the input \hyperlink{classglow_1_1_function}{Function}. We differentiate the nodes and insert code to update the weights based on the {\ttfamily config} parameters. If {\ttfamily var\+Grads} is set then instead of inserting code to update the weights, the procedure adds code to record the last gradient value\+: a list of (var, grad\+\_\+var) pairs associating variables with their gradient variables. This feature is used by the gradient-\/check unit tests. \begin{DoxyReturn}{Returns}
a new function with the name {\ttfamily new\+Func\+Name}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a2f4b45dc331a5845df9ca8e95503c09b}\label{namespaceglow_a2f4b45dc331a5845df9ca8e95503c09b}} 
\index{glow@{glow}!emitting\+Bundle@{emitting\+Bundle}}
\index{emitting\+Bundle@{emitting\+Bundle}!glow@{glow}}
\subsubsection{\texorpdfstring{emitting\+Bundle()}{emittingBundle()}}
{\footnotesize\ttfamily bool glow\+::emitting\+Bundle (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if emit bundle mode is enabled. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ad5afe057375ea161648698052cdeef25}\label{namespaceglow_ad5afe057375ea161648698052cdeef25}} 
\index{glow@{glow}!errs@{errs}}
\index{errs@{errs}!glow@{glow}}
\subsubsection{\texorpdfstring{errs()}{errs()}}
{\footnotesize\ttfamily llvm\+::raw\+\_\+ostream \& glow\+::errs (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
output stream for stderr. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a0c9f98855ca17db059deb4688e051e61}\label{namespaceglow_a0c9f98855ca17db059deb4688e051e61}} 
\index{glow@{glow}!escape\+Dotty\+String@{escape\+Dotty\+String}}
\index{escape\+Dotty\+String@{escape\+Dotty\+String}!glow@{glow}}
\subsubsection{\texorpdfstring{escape\+Dotty\+String()}{escapeDottyString()}}
{\footnotesize\ttfamily std\+::string glow\+::escape\+Dotty\+String (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the escaped content of string {\ttfamily str}. The char \textquotesingle{}~\newline
\textquotesingle{} becomes \textquotesingle{}\textbackslash{}\textquotesingle{}+\textquotesingle{}n\textquotesingle{} and quotes are handled correctly. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ad7385d41afaa1bd063dfa1b74e693ad1}\label{namespaceglow_ad7385d41afaa1bd063dfa1b74e693ad1}} 
\index{glow@{glow}!eval\+Batch@{eval\+Batch}}
\index{eval\+Batch@{eval\+Batch}!glow@{glow}}
\subsubsection{\texorpdfstring{eval\+Batch()}{evalBatch()}}
{\footnotesize\ttfamily void glow\+::eval\+Batch (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_execution_engine}{Execution\+Engine} \&}]{EE,  }\item[{\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{size\+\_\+t}]{num\+Minibatch\+Runs,  }\item[{size\+\_\+t \&}]{sample\+Counter,  }\item[{\hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{input\+PH,  }\item[{\hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{output\+PH,  }\item[{\hyperlink{classglow_1_1_tensor}{Tensor} \&}]{samples\+Input,  }\item[{\hyperlink{classglow_1_1_tensor}{Tensor} \&}]{labels\+Input,  }\item[{llvm\+::\+String\+Ref}]{name,  }\item[{std\+::function$<$ void(const \hyperlink{classglow_1_1_tensor}{Tensor} \&sample\+In, const \hyperlink{classglow_1_1_tensor}{Tensor} \&sample\+Out, const \hyperlink{classglow_1_1_tensor}{Tensor} \&label, size\+\_\+t sample\+Index)$>$ \&\&}]{cb }\end{DoxyParamCaption})}

Runs {\ttfamily num\+Minibatch\+Runs} iterations of the compiled function called {\ttfamily name}. The method updates a global counter and future invocations of this method continue running iterations of the batch at the next available slice. The provided callback function {\ttfamily cb} is invoked on each sample. \mbox{\Hypertarget{namespaceglow_a6bf1f1f5a7c61022904299bfeee07b34}\label{namespaceglow_a6bf1f1f5a7c61022904299bfeee07b34}} 
\index{glow@{glow}!execute\+Constant\+Function@{execute\+Constant\+Function}}
\index{execute\+Constant\+Function@{execute\+Constant\+Function}!glow@{glow}}
\subsubsection{\texorpdfstring{execute\+Constant\+Function()}{executeConstantFunction()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::execute\+Constant\+Function (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_backend}{Backend} \&}]{backend,  }\item[{\hyperlink{classglow_1_1_function}{Function} \&}]{F,  }\item[{\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{\hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&}]{cctx }\end{DoxyParamCaption})}

Execute function {\ttfamily F} by the {\ttfamily backend} using the provided {\ttfamily bindings} and the compilation context {\ttfamily cctx}. \begin{DoxyReturn}{Returns}
error if function is not a constant function. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a130f47cd21711d9244adfb418ffbe9f7}\label{namespaceglow_a130f47cd21711d9244adfb418ffbe9f7}} 
\index{glow@{glow}!execute\+Vertical\+F\+C\+Weights\+Split@{execute\+Vertical\+F\+C\+Weights\+Split}}
\index{execute\+Vertical\+F\+C\+Weights\+Split@{execute\+Vertical\+F\+C\+Weights\+Split}!glow@{glow}}
\subsubsection{\texorpdfstring{execute\+Vertical\+F\+C\+Weights\+Split()}{executeVerticalFCWeightsSplit()}}
{\footnotesize\ttfamily bool glow\+::execute\+Vertical\+F\+C\+Weights\+Split (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{unsigned}]{num\+Of\+Chunks,  }\item[{unsigned}]{min\+K\+To\+Split }\end{DoxyParamCaption})}

Perform vertical split of FC weights in a given function. Optimization could facilitate parallel execution of F\+Cs on multiple device cores. \begin{DoxyReturn}{Returns}
true in case split took place. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em F} & function to optimize. \\
\hline
\mbox{\tt in}  & {\em num\+Of\+Chunks} & number of chunks to split weights and bias into. \\
\hline
\mbox{\tt in}  & {\em min\+K\+To\+Split} & minimum size of the second dimension of weights when the split is applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceglow_a384dccb23b7bc3ade84b8f5c64b1f136}\label{namespaceglow_a384dccb23b7bc3ade84b8f5c64b1f136}} 
\index{glow@{glow}!expand\+Dims\+To\+Max@{expand\+Dims\+To\+Max}}
\index{expand\+Dims\+To\+Max@{expand\+Dims\+To\+Max}!glow@{glow}}
\subsubsection{\texorpdfstring{expand\+Dims\+To\+Max()}{expandDimsToMax()}}
{\footnotesize\ttfamily Shape\+Vector glow\+::expand\+Dims\+To\+Max (\begin{DoxyParamCaption}\item[{llvm\+::\+Array\+Ref$<$ size\+\_\+t $>$}]{curr\+Dims }\end{DoxyParamCaption})}

Helper function that \begin{DoxyReturn}{Returns}
a Shape\+Vector of those dimensions in {\ttfamily curr\+Dims} expanded with dimension = 1 until the maximum tensor dimension is reached. The number of elements in the input dims is the same as in the returned dims. For example, input \{2,1,4\} would result in \{2,1,4,1,1,1\}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_afd8e77c649bf3668467058ae071bb875}\label{namespaceglow_afd8e77c649bf3668467058ae071bb875}} 
\index{glow@{glow}!expect\+Compare\+True@{expect\+Compare\+True}}
\index{expect\+Compare\+True@{expect\+Compare\+True}!glow@{glow}}
\subsubsection{\texorpdfstring{expect\+Compare\+True()}{expectCompareTrue()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Input\+Ty , typename Parent\+Ty $>$ \\
bool glow\+::expect\+Compare\+True (\begin{DoxyParamCaption}\item[{const char $\ast$}]{msg,  }\item[{const Input\+Ty \&}]{a,  }\item[{const Input\+Ty \&}]{b,  }\item[{const Parent\+Ty $\ast$}]{parent,  }\item[{const \hyperlink{structglow_1_1_compare_with_name}{Compare\+With\+Name}$<$ Input\+Ty $>$ \&}]{comp = {\ttfamily \hyperlink{structglow_1_1_compare_operator_equal}{Compare\+Operator\+Equal}$<$InputTy$>$()} }\end{DoxyParamCaption})}

Main A\+PI of the verifier. Check whether {\ttfamily comp}({\ttfamily a}, {\ttfamily b}) is true. If that check fails, {\ttfamily msg} is printed out using \hyperlink{namespaceglow_a9d164b45d9fb735f448cd7985bcdf203}{glow\+::report} and {\ttfamily parent} (if not nullptr), {\ttfamily a}, and {\ttfamily b} are printed out using \hyperlink{namespaceglow_a5efbd9d8157489eb3b55e5c9fafb5fb7}{glow\+::report\+Context}. \begin{DoxyReturn}{Returns}
{\ttfamily comp}({\ttfamily a}, {\ttfamily b}). 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a77a6fef6be3a014626580088a1a72842}\label{namespaceglow_a77a6fef6be3a014626580088a1a72842}} 
\index{glow@{glow}!expect\+Compare\+True@{expect\+Compare\+True}}
\index{expect\+Compare\+True@{expect\+Compare\+True}!glow@{glow}}
\subsubsection{\texorpdfstring{expect\+Compare\+True()}{expectCompareTrue()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Input\+Ty $>$ \\
bool glow\+::expect\+Compare\+True (\begin{DoxyParamCaption}\item[{const char $\ast$}]{msg,  }\item[{const Input\+Ty \&}]{a,  }\item[{llvm\+::\+Array\+Ref$<$ Input\+Ty $>$}]{b,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{parent,  }\item[{const \hyperlink{structglow_1_1_compare_with_name}{Compare\+With\+Name}$<$ Input\+Ty $>$ \&}]{comp = {\ttfamily \hyperlink{structglow_1_1_compare_operator_equal}{Compare\+Operator\+Equal}$<$InputTy$>$()} }\end{DoxyParamCaption})}

Check whether \$\+V\+\_\+\{0,n\}\{comp({\ttfamily a}, {\ttfamily b\+\_\+i})\}\$ is true. If that check fails, {\ttfamily msg} is printed out using \hyperlink{namespaceglow_a9d164b45d9fb735f448cd7985bcdf203}{glow\+::report} and {\ttfamily parent} (if not nullptr), {\ttfamily a}, and {\ttfamily b} are printed out using \hyperlink{namespaceglow_a5efbd9d8157489eb3b55e5c9fafb5fb7}{glow\+::report\+Context}. \begin{DoxyReturn}{Returns}
{\ttfamily comp}({\ttfamily a}, {\ttfamily b\+\_\+0}) v ... v comp({\ttfamily a}, {\ttfamily b\+\_\+i}). 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a47d2c5f23a3db76b44bbf76e2d41f60d}\label{namespaceglow_a47d2c5f23a3db76b44bbf76e2d41f60d}} 
\index{glow@{glow}!flatten\+Cdr@{flatten\+Cdr}}
\index{flatten\+Cdr@{flatten\+Cdr}!glow@{glow}}
\subsubsection{\texorpdfstring{flatten\+Cdr()}{flattenCdr()}}
{\footnotesize\ttfamily std\+::pair$<$size\+\_\+t, size\+\_\+t$>$ glow\+::flatten\+Cdr (\begin{DoxyParamCaption}\item[{llvm\+::\+Array\+Ref$<$ size\+\_\+t $>$}]{dims,  }\item[{\hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t}}]{n = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Collapse a tensor shape into two sizes\+: the first n dimensions and the size of the rest of the dimensions. For example, (\mbox{[}7, 3, 4, 2\mbox{]}, 1) -\/$>$ \mbox{[}7, 24\mbox{]} \mbox{\Hypertarget{namespaceglow_a100064cb8d6d8c2aae54f4a114cf48f4}\label{namespaceglow_a100064cb8d6d8c2aae54f4a114cf48f4}} 
\index{glow@{glow}!generate\+And\+Optimize\+IR@{generate\+And\+Optimize\+IR}}
\index{generate\+And\+Optimize\+IR@{generate\+And\+Optimize\+IR}!glow@{glow}}
\subsubsection{\texorpdfstring{generate\+And\+Optimize\+I\+R()}{generateAndOptimizeIR()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} $>$ glow\+::generate\+And\+Optimize\+IR (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{const \hyperlink{classglow_1_1_backend}{Backend} \&}]{B,  }\item[{bool}]{should\+Share\+Buffers }\end{DoxyParamCaption})}

Helper to generate and optimize IR from given \hyperlink{classglow_1_1_function}{Function} {\ttfamily F}. {\ttfamily should\+Share\+Buffers} signifies whether to use the share buffers optimization. \hyperlink{classglow_1_1_backend}{Backend} /p B is used to allow for custom lowering from \hyperlink{classglow_1_1_node}{Node} to \hyperlink{classglow_1_1_instruction}{Instruction} IR. \mbox{\Hypertarget{namespaceglow_a9d06550bdaa17730cb67e8a086db767c}\label{namespaceglow_a9d06550bdaa17730cb67e8a086db767c}} 
\index{glow@{glow}!generate\+Node\+Kinds\+Set@{generate\+Node\+Kinds\+Set}}
\index{generate\+Node\+Kinds\+Set@{generate\+Node\+Kinds\+Set}!glow@{glow}}
\subsubsection{\texorpdfstring{generate\+Node\+Kinds\+Set()}{generateNodeKindsSet()}}
{\footnotesize\ttfamily std\+::set$<$ Kinded\+::\+Kind $>$ glow\+::generate\+Node\+Kinds\+Set (\begin{DoxyParamCaption}\item[{llvm\+::\+String\+Ref}]{names }\end{DoxyParamCaption})}

Parse a node name string (e.\+g. \char`\"{}\+Div,\+Add\char`\"{}) {\ttfamily names}, \begin{DoxyReturn}{Returns}
a set of Node\+Kinds corresponding to the names in the string. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a44d3450f4f150909deaf8e5939537d51}\label{namespaceglow_a44d3450f4f150909deaf8e5939537d51}} 
\index{glow@{glow}!generic\+Transpose@{generic\+Transpose}}
\index{generic\+Transpose@{generic\+Transpose}!glow@{glow}}
\subsubsection{\texorpdfstring{generic\+Transpose()}{genericTranspose()}}
{\footnotesize\ttfamily void glow\+::generic\+Transpose (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$}]{src,  }\item[{\hyperlink{classglow_1_1_tensor}{Tensor} $\ast$}]{dest,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{namespaceglow_a0ca574644e1e42ef193a9947fb4d8911}{unsigned\+\_\+t} $>$}]{shuffle }\end{DoxyParamCaption})}

Dump a textual representation of a specific number of elements in the \hyperlink{classglow_1_1_tensor}{Tensor} to std\+::string. \mbox{\Hypertarget{namespaceglow_ab32aaca1a37daa0543ca953df2110b63}\label{namespaceglow_ab32aaca1a37daa0543ca953df2110b63}} 
\index{glow@{glow}!get\+Allocation\+Origin@{get\+Allocation\+Origin}}
\index{get\+Allocation\+Origin@{get\+Allocation\+Origin}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Allocation\+Origin()}{getAllocationOrigin()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_value}{Value} $\ast$ glow\+::get\+Allocation\+Origin (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_value}{Value} $\ast$}]{V }\end{DoxyParamCaption})}

Get the allocation corrsponding to th value {\ttfamily V}. It can look through tensorview instructions. \begin{DoxyReturn}{Returns}
found allocation or nullptr. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_acfa7d1d30cd1420a7a651fa3d63b33e6}\label{namespaceglow_acfa7d1d30cd1420a7a651fa3d63b33e6}} 
\index{glow@{glow}!get\+B\+F\+S\+Level@{get\+B\+F\+S\+Level}}
\index{get\+B\+F\+S\+Level@{get\+B\+F\+S\+Level}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+B\+F\+S\+Level()}{getBFSLevel()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_a03e8d2f34b0b5876fd4f7abaf0a0d73d}{B\+F\+S\+Level} glow\+::get\+B\+F\+S\+Level (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F }\end{DoxyParamCaption})}

Visit nodes if \hyperlink{classglow_1_1_function}{Function} {\ttfamily F} in B\+FS order and return the nodes by levels (the longest distance between one node and the root).

The nodes in function {\ttfamily F} which be grouped into levels based on how far (the longest distance) they are from the roots. \mbox{\Hypertarget{namespaceglow_ac81027b5844dd48c60ba42e8169f19c2}\label{namespaceglow_ac81027b5844dd48c60ba42e8169f19c2}} 
\index{glow@{glow}!get\+Contiguous\+Place\+Holder@{get\+Contiguous\+Place\+Holder}}
\index{get\+Contiguous\+Place\+Holder@{get\+Contiguous\+Place\+Holder}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Contiguous\+Place\+Holder()}{getContiguousPlaceHolder()}}
{\footnotesize\ttfamily template$<$typename F\+UN , typename A\+RR $>$ \\
Contiguous\+Placeholders glow\+::get\+Contiguous\+Place\+Holder (\begin{DoxyParamCaption}\item[{const A\+RR \&}]{holders,  }\item[{const F\+UN \&}]{F }\end{DoxyParamCaption})}

Convert placeholders to be ordered as input$\vert$input\+Output$\vert$output$\vert$neither. Packed into \{\hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$, is\+Input, is\+Output\} as \hyperlink{structglow_1_1_placeholder_input_output_info}{Placeholder\+Input\+Output\+Info}. F\+UN could be \hyperlink{classglow_1_1_function}{Function} or \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function}. A\+RR could be std\+::list$<$\+Placeholder $\ast$$>$ or std\+::vector$<$const Placeholder $\ast$$>$ \mbox{\Hypertarget{namespaceglow_a4fef74193703ceb204297b6993af8081}\label{namespaceglow_a4fef74193703ceb204297b6993af8081}} 
\index{glow@{glow}!get\+D\+C\+E\+Pass\+Config@{get\+D\+C\+E\+Pass\+Config}}
\index{get\+D\+C\+E\+Pass\+Config@{get\+D\+C\+E\+Pass\+Config}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+D\+C\+E\+Pass\+Config()}{getDCEPassConfig()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_function_pass_config}{Function\+Pass\+Config} glow\+::get\+D\+C\+E\+Pass\+Config (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
a \hyperlink{classglow_1_1_function_pass_config}{Function\+Pass\+Config} for performing D\+CE. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_abdedf715e997af0b1a4ad4b1882bed49}\label{namespaceglow_abdedf715e997af0b1a4ad4b1882bed49}} 
\index{glow@{glow}!get\+Dot\+File\+Node\+Color@{get\+Dot\+File\+Node\+Color}}
\index{get\+Dot\+File\+Node\+Color@{get\+Dot\+File\+Node\+Color}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Dot\+File\+Node\+Color()}{getDotFileNodeColor()}}
{\footnotesize\ttfamily const char $\ast$ glow\+::get\+Dot\+File\+Node\+Color (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the node color based on {\ttfamily index} which is used in dot file.

the color based on {\ttfamily index} which is used in dot file. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ad9cf5d13b978aa755ff9b01edad65466}\label{namespaceglow_ad9cf5d13b978aa755ff9b01edad65466}} 
\index{glow@{glow}!get\+Floats@{get\+Floats}}
\index{get\+Floats@{get\+Floats}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Floats()}{getFloats()}}
{\footnotesize\ttfamily template$<$typename Attr\+Type $>$ \\
std\+::vector$<$float$>$ glow\+::get\+Floats (\begin{DoxyParamCaption}\item[{const Attr\+Type $\ast$}]{arg }\end{DoxyParamCaption})}

Load a floating record vector from {\ttfamily arg}. \begin{DoxyReturn}{Returns}
a standard vector of floats. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a589ee9d58bb8726a5e764b1dd74f8070}\label{namespaceglow_a589ee9d58bb8726a5e764b1dd74f8070}} 
\index{glow@{glow}!get\+Inputs@{get\+Inputs}}
\index{get\+Inputs@{get\+Inputs}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Inputs()}{getInputs()}}
{\footnotesize\ttfamily Nodes\+Set glow\+::get\+Inputs (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{node }\end{DoxyParamCaption})}



Given a node,. 

\begin{DoxyReturn}{Returns}
the Node\+Set of inputs of this node.
\end{DoxyReturn}
Given a node, \begin{DoxyReturn}{Returns}
the Node\+Set of all nodes that create the results for any of the inputs of this node (i.\+e. input of inputs) 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_af5d8953e310c3650356892fa4e866ce3}\label{namespaceglow_af5d8953e310c3650356892fa4e866ce3}} 
\index{glow@{glow}!get\+Kind\+From\+Node\+Name@{get\+Kind\+From\+Node\+Name}}
\index{get\+Kind\+From\+Node\+Name@{get\+Kind\+From\+Node\+Name}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Kind\+From\+Node\+Name()}{getKindFromNodeName()}}
{\footnotesize\ttfamily Kinded\+::\+Kind glow\+::get\+Kind\+From\+Node\+Name (\begin{DoxyParamCaption}\item[{llvm\+::\+String\+Ref}]{node\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Helper to get the Kind of a \hyperlink{classglow_1_1_node}{Node} (e.\+g. Kinded\+::\+Kind\+::\+Add\+Node\+Kind) given its {\ttfamily node\+Name} (e.\+g. Add). \mbox{\Hypertarget{namespaceglow_a6195ce22fbeafd894c0ce148bb7a8a9a}\label{namespaceglow_a6195ce22fbeafd894c0ce148bb7a8a9a}} 
\index{glow@{glow}!get\+Name\+Of\+Pass@{get\+Name\+Of\+Pass}}
\index{get\+Name\+Of\+Pass@{get\+Name\+Of\+Pass}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Name\+Of\+Pass()}{getNameOfPass()}}
{\footnotesize\ttfamily llvm\+::\+String\+Ref glow\+::get\+Name\+Of\+Pass (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceglow_a3157945b92abd634c79fa9d4724472eb}{Function\+Pass\+ID}}]{pass\+ID }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the name of a \hyperlink{classglow_1_1_function_pass}{Function\+Pass} given its {\ttfamily pass\+ID}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a59d8826ffac432ffcebc8dcd11a85816}\label{namespaceglow_a59d8826ffac432ffcebc8dcd11a85816}} 
\index{glow@{glow}!get\+Node\+Mem\+Usage@{get\+Node\+Mem\+Usage}}
\index{get\+Node\+Mem\+Usage@{get\+Node\+Mem\+Usage}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Node\+Mem\+Usage()}{getNodeMemUsage()}}
{\footnotesize\ttfamily uint64\+\_\+t glow\+::get\+Node\+Mem\+Usage (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{node }\end{DoxyParamCaption})}



Given a node,. 

\begin{DoxyReturn}{Returns}
the memory usage of its inputs (i.\+e. \hyperlink{classglow_1_1_storage}{Storage} input). 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a455ad0b5511a75c369f14b06c1de37fd}\label{namespaceglow_a455ad0b5511a75c369f14b06c1de37fd}} 
\index{glow@{glow}!get\+Origin@{get\+Origin}}
\index{get\+Origin@{get\+Origin}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Origin()}{getOrigin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_value}{Value} $\ast$ glow\+::get\+Origin (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_value}{Value} $\ast$}]{V }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
peels off the layers of tensorviews from a value {\ttfamily V}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a582b647d0167e2bd46758cf24a691ac3}\label{namespaceglow_a582b647d0167e2bd46758cf24a691ac3}} 
\index{glow@{glow}!get\+Origin@{get\+Origin}}
\index{get\+Origin@{get\+Origin}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Origin()}{getOrigin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const \hyperlink{classglow_1_1_value}{Value} $\ast$ glow\+::get\+Origin (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_value}{Value} $\ast$}]{V }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
peels off the layers of tensorviews from a value {\ttfamily V}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a7ec2658c25c6fddc1b6788888a930d71}\label{namespaceglow_a7ec2658c25c6fddc1b6788888a930d71}} 
\index{glow@{glow}!get\+Origin\+Offset@{get\+Origin\+Offset}}
\index{get\+Origin\+Offset@{get\+Origin\+Offset}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Origin\+Offset()}{getOriginOffset()}}
{\footnotesize\ttfamily size\+\_\+t glow\+::get\+Origin\+Offset (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_value}{Value} $\ast$}]{V }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the offset into the \hyperlink{classglow_1_1_value}{Value} returned by get\+Origin. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a4c7ea6df70770cd2ccf2bbfb85077539}\label{namespaceglow_a4c7ea6df70770cd2ccf2bbfb85077539}} 
\index{glow@{glow}!get\+Out\+Mem\+Per\+Node@{get\+Out\+Mem\+Per\+Node}}
\index{get\+Out\+Mem\+Per\+Node@{get\+Out\+Mem\+Per\+Node}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Out\+Mem\+Per\+Node()}{getOutMemPerNode()}}
{\footnotesize\ttfamily uint64\+\_\+t glow\+::get\+Out\+Mem\+Per\+Node (\begin{DoxyParamCaption}\item[{const Nodes\+Set \&}]{nodes,  }\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{node }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the memory usage of the output caused by {\ttfamily node} who has users not in the set {\ttfamily nodes}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a493b517e027e3c2689248c644f3747b5}\label{namespaceglow_a493b517e027e3c2689248c644f3747b5}} 
\index{glow@{glow}!get\+Output\+Save@{get\+Output\+Save}}
\index{get\+Output\+Save@{get\+Output\+Save}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Output\+Save()}{getOutputSave()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_save_node}{Save\+Node} $\ast$ glow\+::get\+Output\+Save (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{\hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the first \hyperlink{classglow_1_1_save_node}{Save\+Node} user of the placeholder {\ttfamily PH} or nullptr if none are found. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ace2ce9f3fea11d339cd0605fe8ece061}\label{namespaceglow_ace2ce9f3fea11d339cd0605fe8ece061}} 
\index{glow@{glow}!get\+Out\+Users@{get\+Out\+Users}}
\index{get\+Out\+Users@{get\+Out\+Users}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Out\+Users()}{getOutUsers()}}
{\footnotesize\ttfamily std\+::vector$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$ glow\+::get\+Out\+Users (\begin{DoxyParamCaption}\item[{const Nodes\+Set \&}]{nodes }\end{DoxyParamCaption})}



Given {\ttfamily nodes}, return a list of nodes who use any node in this set. 

Given {\ttfamily nodes}, return a list of nodes who are not in this set but use any node in this set. \mbox{\Hypertarget{namespaceglow_a352ec64282f28b5487a23bf2d805a528}\label{namespaceglow_a352ec64282f28b5487a23bf2d805a528}} 
\index{glow@{glow}!get\+Out\+Users\+With\+One\+Predecessor@{get\+Out\+Users\+With\+One\+Predecessor}}
\index{get\+Out\+Users\+With\+One\+Predecessor@{get\+Out\+Users\+With\+One\+Predecessor}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Out\+Users\+With\+One\+Predecessor()}{getOutUsersWithOnePredecessor()}}
{\footnotesize\ttfamily std\+::vector$<$ \hyperlink{classglow_1_1_node}{Node} $\ast$ $>$ glow\+::get\+Out\+Users\+With\+One\+Predecessor (\begin{DoxyParamCaption}\item[{const Nodes\+Set \&}]{nodes }\end{DoxyParamCaption})}

Given {\ttfamily nodes}, return a list of nodes who use only the nodes in this set or constant.

Given {\ttfamily nodes}, return a list of nodes who are not in this set but use only the nodes in this set or constant. \mbox{\Hypertarget{namespaceglow_a8a01d4f862cb83ad8979bfa1c5794930}\label{namespaceglow_a8a01d4f862cb83ad8979bfa1c5794930}} 
\index{glow@{glow}!get\+Png\+Info@{get\+Png\+Info}}
\index{get\+Png\+Info@{get\+Png\+Info}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Png\+Info()}{getPngInfo()}}
{\footnotesize\ttfamily std\+::tuple$<$ size\+\_\+t, size\+\_\+t, bool $>$ glow\+::get\+Png\+Info (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}

Reads a png image header from png file {\ttfamily filename} and \begin{DoxyReturn}{Returns}
a tuple containing height, width, and a bool if it is grayscale or not. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aaee7b49ad6e84bdb1a42ac3e5bff797e}\label{namespaceglow_aaee7b49ad6e84bdb1a42ac3e5bff797e}} 
\index{glow@{glow}!get\+Scale\+Offset\+Elem\+Kind\+From\+Fused@{get\+Scale\+Offset\+Elem\+Kind\+From\+Fused}}
\index{get\+Scale\+Offset\+Elem\+Kind\+From\+Fused@{get\+Scale\+Offset\+Elem\+Kind\+From\+Fused}!glow@{glow}}
\subsubsection{\texorpdfstring{get\+Scale\+Offset\+Elem\+Kind\+From\+Fused()}{getScaleOffsetElemKindFromFused()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind} glow\+::get\+Scale\+Offset\+Elem\+Kind\+From\+Fused (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind}}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the scale and offset Elem\+Kind used by the fused Elem\+Kind {\ttfamily e}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a5192591d333ee1a71b03325bb3d9f80a}\label{namespaceglow_a5192591d333ee1a71b03325bb3d9f80a}} 
\index{glow@{glow}!is\+Current\+Debug\+Type@{is\+Current\+Debug\+Type}}
\index{is\+Current\+Debug\+Type@{is\+Current\+Debug\+Type}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Current\+Debug\+Type()}{isCurrentDebugType()}}
{\footnotesize\ttfamily bool glow\+::is\+Current\+Debug\+Type (\begin{DoxyParamCaption}\item[{const char $\ast$}]{type }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if {\ttfamily type} matches the activated debug type. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aeea823a4b44883f04b3cd7ba5eebb9ef}\label{namespaceglow_aeea823a4b44883f04b3cd7ba5eebb9ef}} 
\index{glow@{glow}!is\+Fused\+Quantized\+Elem\+Kind@{is\+Fused\+Quantized\+Elem\+Kind}}
\index{is\+Fused\+Quantized\+Elem\+Kind@{is\+Fused\+Quantized\+Elem\+Kind}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Fused\+Quantized\+Elem\+Kind()}{isFusedQuantizedElemKind()}}
{\footnotesize\ttfamily bool glow\+::is\+Fused\+Quantized\+Elem\+Kind (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind}}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
whether {\ttfamily e} is a fused quantized Elem\+Kind. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_afbc28cae078d0b91e0bda921554f3ae6}\label{namespaceglow_afbc28cae078d0b91e0bda921554f3ae6}} 
\index{glow@{glow}!is\+Input@{is\+Input}}
\index{is\+Input@{is\+Input}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Input()}{isInput()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool glow\+::is\+Input (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH,  }\item[{const \hyperlink{classglow_1_1_function}{Function} \&}]{F }\end{DoxyParamCaption})}



If {\ttfamily PH} is an input placeholder,. 

If {\ttfamily PH} is an input placeholderin the \hyperlink{classglow_1_1_function}{Function} {\ttfamily F}, \begin{DoxyReturn}{Returns}
true. This is determined by checking if the PH is the input to a save\+Node or is used by a non save\+Node.

true. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_acb98192dd9bfc2315759db1806f01ad1}\label{namespaceglow_acb98192dd9bfc2315759db1806f01ad1}} 
\index{glow@{glow}!is\+Input@{is\+Input}}
\index{is\+Input@{is\+Input}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Input()}{isInput()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool glow\+::is\+Input (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH,  }\item[{const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&}]{F }\end{DoxyParamCaption})}



If {\ttfamily PH} is an input placeholder in the function {\ttfamily F},. 

If {\ttfamily PH} is an input placeholder in the \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} {\ttfamily F}, \begin{DoxyReturn}{Returns}
true. This is determined by checking if the PH is always used as an  parameter by the current function.

true. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aac10131240fff18a61a4f525541fe765}\label{namespaceglow_aac10131240fff18a61a4f525541fe765}} 
\index{glow@{glow}!is\+Input@{is\+Input}}
\index{is\+Input@{is\+Input}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Input()}{isInput()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool glow\+::is\+Input (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH,  }\item[{const std\+::vector$<$ const \hyperlink{classglow_1_1_function}{Function} $\ast$$>$ \&}]{funcs }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if {\ttfamily PH} is an input \hyperlink{classglow_1_1_placeholder}{Placeholder} for any function in {\ttfamily funcs}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_af18ed78d6c309a7061f1b1318b9d8aca}\label{namespaceglow_af18ed78d6c309a7061f1b1318b9d8aca}} 
\index{glow@{glow}!is\+Output@{is\+Output}}
\index{is\+Output@{is\+Output}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Output()}{isOutput()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool glow\+::is\+Output (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH,  }\item[{const \hyperlink{classglow_1_1_function}{Function} \&}]{F }\end{DoxyParamCaption})}

\hyperlink{structglow_1_1_use}{Use} template meta-\/programming to check if typename Class\+Name contains get\+Fused\+Activation() method. Below generates a struct named has\+\_\+get\+Fused\+Activation that looks for said method. If {\ttfamily PH} is an output placeholder in the \hyperlink{classglow_1_1_function}{Function} {\ttfamily F}, \begin{DoxyReturn}{Returns}
true. This is determined by checking if the PH has a user which uses the PH as an overwritten input.
\end{DoxyReturn}
If {\ttfamily PH} is an output placeholder, \begin{DoxyReturn}{Returns}
true. This is determined by checking if the PH has a user which uses the PH as an overwritten input. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a5a7a54e3291e2de0fa2c08e14cf1f36b}\label{namespaceglow_a5a7a54e3291e2de0fa2c08e14cf1f36b}} 
\index{glow@{glow}!is\+Output@{is\+Output}}
\index{is\+Output@{is\+Output}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Output()}{isOutput()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool glow\+::is\+Output (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH,  }\item[{const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&}]{F }\end{DoxyParamCaption})}

If {\ttfamily PH} is an output placeholder in the \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} {\ttfamily F}, \begin{DoxyReturn}{Returns}
true. This is determined by checking if the PH has weights which are referenced by other Instructions as Operand\+Kind\+::\+In\+Out or Operand\+Kind\+::\+Out.
\end{DoxyReturn}
If {\ttfamily PH} is an output placeholder in the function {\ttfamily F}, \begin{DoxyReturn}{Returns}
true. This is determined by checking if the PH has a user which uses the PH as an overwritten input. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ab3c36fb4023b57b7f2ea10ac4fe9c459}\label{namespaceglow_ab3c36fb4023b57b7f2ea10ac4fe9c459}} 
\index{glow@{glow}!is\+Output@{is\+Output}}
\index{is\+Output@{is\+Output}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Output()}{isOutput()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool glow\+::is\+Output (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$}]{PH,  }\item[{const std\+::vector$<$ const \hyperlink{classglow_1_1_function}{Function} $\ast$$>$ \&}]{funcs }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if {\ttfamily PH} is an output \hyperlink{classglow_1_1_placeholder}{Placeholder} for any function in {\ttfamily funcs}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a67fc7f0b501763e06363d035e472238c}\label{namespaceglow_a67fc7f0b501763e06363d035e472238c}} 
\index{glow@{glow}!is\+Quantized\+Elem\+Kind@{is\+Quantized\+Elem\+Kind}}
\index{is\+Quantized\+Elem\+Kind@{is\+Quantized\+Elem\+Kind}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Quantized\+Elem\+Kind()}{isQuantizedElemKind()}}
{\footnotesize\ttfamily bool glow\+::is\+Quantized\+Elem\+Kind (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceglow_ab92e14a94329daf4083db670e95fbcdf}{Elem\+Kind}}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
whether {\ttfamily e} is a quantized Elem\+Kind. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aafa588b030c2f1fbed648b8477d7b444}\label{namespaceglow_aafa588b030c2f1fbed648b8477d7b444}} 
\index{glow@{glow}!is\+Tensor\+View@{is\+Tensor\+View}}
\index{is\+Tensor\+View@{is\+Tensor\+View}!glow@{glow}}
\subsubsection{\texorpdfstring{is\+Tensor\+View()}{isTensorView()}}
{\footnotesize\ttfamily bool glow\+::is\+Tensor\+View (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_value}{glow\+::\+Value} $\ast$}]{v }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if the value  is a tensor view. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aa2799bdee5e14247b8699a8dfd8f6ae9}\label{namespaceglow_aa2799bdee5e14247b8699a8dfd8f6ae9}} 
\index{glow@{glow}!legalize\+Name@{legalize\+Name}}
\index{legalize\+Name@{legalize\+Name}!glow@{glow}}
\subsubsection{\texorpdfstring{legalize\+Name()}{legalizeName()}}
{\footnotesize\ttfamily std\+::string glow\+::legalize\+Name (\begin{DoxyParamCaption}\item[{llvm\+::\+String\+Ref}]{name }\end{DoxyParamCaption})}

Legalize {\ttfamily name} used in \hyperlink{classglow_1_1_module}{Module}. In Glow module, the name of placeholders and constants should look like valid C identifiers. Therefore, those symbols can be inspected under debugger. \mbox{\Hypertarget{namespaceglow_ae5f1717e58e71e730005473efae8c91a}\label{namespaceglow_ae5f1717e58e71e730005473efae8c91a}} 
\index{glow@{glow}!load\+Images\+And\+Preprocess@{load\+Images\+And\+Preprocess}}
\index{load\+Images\+And\+Preprocess@{load\+Images\+And\+Preprocess}!glow@{glow}}
\subsubsection{\texorpdfstring{load\+Images\+And\+Preprocess()}{loadImagesAndPreprocess()}}
{\footnotesize\ttfamily void glow\+::load\+Images\+And\+Preprocess (\begin{DoxyParamCaption}\item[{const llvm\+::\+Array\+Ref$<$ std\+::string $>$ \&}]{filenames,  }\item[{\hyperlink{classglow_1_1_tensor}{Tensor} $\ast$}]{input\+Image\+Data,  }\item[{\hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode}}]{image\+Norm\+Mode,  }\item[{\hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order}}]{image\+Channel\+Order,  }\item[{\hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout}}]{image\+Layout }\end{DoxyParamCaption})}

Loads and normalizes all P\+N\+Gs into a tensor in the N\+H\+WC format with the requested channel ordering. 
\begin{DoxyParams}{Parameters}
{\em filenames} & list of filenames to read. \\
\hline
{\em input\+Image\+Data} & \hyperlink{classglow_1_1_tensor}{Tensor} to save the resulting output. \\
\hline
{\em image\+Norm\+Mode} & normalize values to this range. \\
\hline
{\em image\+Channel\+Order} & the order of color channels. \\
\hline
{\em image\+Layout} & the order of dimensions (channel, height, and width). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceglow_a7fbe04791f94ae9ed38fa4c0166e6709}\label{namespaceglow_a7fbe04791f94ae9ed38fa4c0166e6709}} 
\index{glow@{glow}!load\+Operator\+Name@{load\+Operator\+Name}}
\index{load\+Operator\+Name@{load\+Operator\+Name}!glow@{glow}}
\subsubsection{\texorpdfstring{load\+Operator\+Name()}{loadOperatorName()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::string glow\+::load\+Operator\+Name (\begin{DoxyParamCaption}\item[{const T \&}]{op }\end{DoxyParamCaption})}

Returns canonical name for a given operator\+: either {\ttfamily name()} from proto, or its type name. \mbox{\Hypertarget{namespaceglow_a85a9500a329d096bf03201016353f1dd}\label{namespaceglow_a85a9500a329d096bf03201016353f1dd}} 
\index{glow@{glow}!logical\+Devices\+Validation@{logical\+Devices\+Validation}}
\index{logical\+Devices\+Validation@{logical\+Devices\+Validation}!glow@{glow}}
\subsubsection{\texorpdfstring{logical\+Devices\+Validation()}{logicalDevicesValidation()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::logical\+Devices\+Validation (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&}]{partitions,  }\item[{const std\+::map$<$ std\+::string, \hyperlink{structglow_1_1_backend_info}{Backend\+Info} $>$ \&}]{backend\+Map }\end{DoxyParamCaption})}

Check if {\ttfamily partitions} satisfies number of physical devices restriction. I.\+e. check if the number of logical devices is less than the given physical devices. \mbox{\Hypertarget{namespaceglow_a0069e8261c2e2ddf94d4697de80150ad}\label{namespaceglow_a0069e8261c2e2ddf94d4697de80150ad}} 
\index{glow@{glow}!lower@{lower}}
\index{lower@{lower}!glow@{glow}}
\subsubsection{\texorpdfstring{lower()}{lower()}}
{\footnotesize\ttfamily void glow\+::lower (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{\hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&}]{cctx,  }\item[{const \hyperlink{classglow_1_1_backend}{Backend} $\ast$}]{B = {\ttfamily nullptr},  }\item[{const Kind\+Set \&}]{do\+Not\+Lower\+Kinds = {\ttfamily \{\}} }\end{DoxyParamCaption})}

Lower the high-\/level neural network nodes found in {\ttfamily F} into low-\/level linear algebra operators. If {\ttfamily B} is not a nullptr then it can prevent lowering of a node via \hyperlink{classglow_1_1_backend_aba5bec08f5e60626bcc5238f410d632a}{Backend\+::should\+Lower()}; otherwise everything will be lowered. {\ttfamily cctx} will contain a mapping of lowered\+Map from output names of the nodes found and lowered in {\ttfamily F} to the output names of the nodes they were lowered from along with the Node\+Kind. {\ttfamily do\+Not\+Lower\+Kinds} is a set of Node\+Kinds which represents all Nodes that should not be lowered. \mbox{\Hypertarget{namespaceglow_a07a0a4dcd72e491d512294eec2ba422a}\label{namespaceglow_a07a0a4dcd72e491d512294eec2ba422a}} 
\index{glow@{glow}!memory\+Usage\+Validation@{memory\+Usage\+Validation}}
\index{memory\+Usage\+Validation@{memory\+Usage\+Validation}!glow@{glow}}
\subsubsection{\texorpdfstring{memory\+Usage\+Validation()}{memoryUsageValidation()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::memory\+Usage\+Validation (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&}]{partitions,  }\item[{const std\+::map$<$ std\+::string, \hyperlink{structglow_1_1_backend_info}{Backend\+Info} $>$ \&}]{backend\+Map }\end{DoxyParamCaption})}

Check if the memory usage of each partition meets the physical device memory restriction. \mbox{\Hypertarget{namespaceglow_a300f3c7eeb3e5ee04d177a2acc6ac4db}\label{namespaceglow_a300f3c7eeb3e5ee04d177a2acc6ac4db}} 
\index{glow@{glow}!norm\+Mode\+To\+Range@{norm\+Mode\+To\+Range}}
\index{norm\+Mode\+To\+Range@{norm\+Mode\+To\+Range}!glow@{glow}}
\subsubsection{\texorpdfstring{norm\+Mode\+To\+Range()}{normModeToRange()}}
{\footnotesize\ttfamily std\+::pair$<$ float, float $>$ glow\+::norm\+Mode\+To\+Range (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode}}]{mode }\end{DoxyParamCaption})}



Convert the normalization to numeric floating poing ranges. 

\begin{DoxyReturn}{Returns}
the floating-\/point range corresponding to enum value {\ttfamily mode}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a07bee061556f83b0349d96ad196f0faf}\label{namespaceglow_a07bee061556f83b0349d96ad196f0faf}} 
\index{glow@{glow}!optimize\+Communication\+Cost@{optimize\+Communication\+Cost}}
\index{optimize\+Communication\+Cost@{optimize\+Communication\+Cost}!glow@{glow}}
\subsubsection{\texorpdfstring{optimize\+Communication\+Cost()}{optimizeCommunicationCost()}}
{\footnotesize\ttfamily void glow\+::optimize\+Communication\+Cost (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&}]{partitions,  }\item[{Function\+To\+Nodes\+Map \&}]{nodes\+Set,  }\item[{\hyperlink{classglow_1_1_module}{Module} $\ast$}]{mod,  }\item[{uint64\+\_\+t}]{available\+Memory }\end{DoxyParamCaption})}

By using heuristic algorithm to move nodes among {\ttfamily partitions}, optimize the total communication cost of running a module and keep the memory usage of each partition within {\ttfamily available\+Memory}. \mbox{\Hypertarget{namespaceglow_af6b48e8310d02c29962b5469885b3a75}\label{namespaceglow_af6b48e8310d02c29962b5469885b3a75}} 
\index{glow@{glow}!optimize\+Function@{optimize\+Function}}
\index{optimize\+Function@{optimize\+Function}!glow@{glow}}
\subsubsection{\texorpdfstring{optimize\+Function()}{optimizeFunction()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::optimize\+Function (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{const \hyperlink{classglow_1_1_backend}{Backend} \&}]{B,  }\item[{\hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&}]{cctx }\end{DoxyParamCaption})}

Optimize the \hyperlink{classglow_1_1_function}{Function} {\ttfamily F} given compilation options {\ttfamily cctx} for \hyperlink{classglow_1_1_backend}{Backend} . \begin{DoxyReturn}{Returns}
success if all nodes in the final resulting optimized \hyperlink{classglow_1_1_function}{Function} are supported by {\ttfamily B}; if not, this represents a compiler error. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a2bc58f10ed9c082dab795b43217a2d51}\label{namespaceglow_a2bc58f10ed9c082dab795b43217a2d51}} 
\index{glow@{glow}!optimize\+Function\+Before\+Lowering@{optimize\+Function\+Before\+Lowering}}
\index{optimize\+Function\+Before\+Lowering@{optimize\+Function\+Before\+Lowering}!glow@{glow}}
\subsubsection{\texorpdfstring{optimize\+Function\+Before\+Lowering()}{optimizeFunctionBeforeLowering()}}
{\footnotesize\ttfamily \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} glow\+::optimize\+Function\+Before\+Lowering (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{\hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&}]{cctx }\end{DoxyParamCaption})}

Optimize the \hyperlink{classglow_1_1_function}{Function} {\ttfamily F} given compilation options {\ttfamily cctx} performing backend-\/independent optimizations that can be done before lowering. \begin{DoxyReturn}{Returns}
success if there were no compiler errors; if not, this represents a compiler error. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ae095c93d366edde27fb624fe8963e2d7}\label{namespaceglow_ae095c93d366edde27fb624fe8963e2d7}} 
\index{glow@{glow}!outs@{outs}}
\index{outs@{outs}!glow@{glow}}
\subsubsection{\texorpdfstring{outs()}{outs()}}
{\footnotesize\ttfamily llvm\+::raw\+\_\+ostream \& glow\+::outs (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
output stream for stdout. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aab6afbd888776074c6bd9285aa3d9fd8}\label{namespaceglow_aab6afbd888776074c6bd9285aa3d9fd8}} 
\index{glow@{glow}!partitions\+Combine@{partitions\+Combine}}
\index{partitions\+Combine@{partitions\+Combine}!glow@{glow}}
\subsubsection{\texorpdfstring{partitions\+Combine()}{partitionsCombine()}}
{\footnotesize\ttfamily void glow\+::partitions\+Combine (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_node_to_function_map}{Node\+To\+Function\+Map} \&}]{partitions,  }\item[{Function\+To\+Nodes\+Map \&}]{nodes\+Set,  }\item[{\hyperlink{classglow_1_1_module}{Module} $\ast$}]{mod,  }\item[{uint64\+\_\+t}]{available\+Memory }\end{DoxyParamCaption})}

Combine partitions according to the following rules\+: Rule 1 \+:if all outside uses of the nodes in partition1 is in partition2, and the sum of memory consumption of partition1 and partition2 is less than available\+Memory, combine partition1 and partition2. \mbox{\Hypertarget{namespaceglow_a8e9d4a9dc79cc3c3010bc99e93b08fc7}\label{namespaceglow_a8e9d4a9dc79cc3c3010bc99e93b08fc7}} 
\index{glow@{glow}!profile\+Quantization@{profile\+Quantization}}
\index{profile\+Quantization@{profile\+Quantization}!glow@{glow}}
\subsubsection{\texorpdfstring{profile\+Quantization()}{profileQuantization()}}
{\footnotesize\ttfamily void glow\+::profile\+Quantization (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F }\end{DoxyParamCaption})}

Instrument function {\ttfamily F} by inserting quantization profile nodes for capturing stats for quantization. The nodes will refer to tensors allocate in context {\ttfamily bindings}. Don\textquotesingle{}t profile output nodes. \mbox{\Hypertarget{namespaceglow_a1945e52546b506e9c6692b42e6ff78bd}\label{namespaceglow_a1945e52546b506e9c6692b42e6ff78bd}} 
\index{glow@{glow}!profiling\+Graph@{profiling\+Graph}}
\index{profiling\+Graph@{profiling\+Graph}!glow@{glow}}
\subsubsection{\texorpdfstring{profiling\+Graph()}{profilingGraph()}}
{\footnotesize\ttfamily bool glow\+::profiling\+Graph (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
true if profiling the graph. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a327fb998231805cf69b6753e763e683f}\label{namespaceglow_a327fb998231805cf69b6753e763e683f}} 
\index{glow@{glow}!read\+From\+File@{read\+From\+File}}
\index{read\+From\+File@{read\+From\+File}!glow@{glow}}
\subsubsection{\texorpdfstring{read\+From\+File()}{readFromFile()}}
{\footnotesize\ttfamily void glow\+::read\+From\+File (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_tensor}{Tensor} \&}]{T,  }\item[{llvm\+::\+String\+Ref}]{filename }\end{DoxyParamCaption})}

Read \hyperlink{classglow_1_1_tensor}{Tensor} data {\ttfamily T} from a file named {\ttfamily filename}.

NB\+: This function is primarily a debugging aid, not a serialization format. It reads only the binary data of the tensor (the dimensions must be known through other means), and reads tensors assuming host endianness. \mbox{\Hypertarget{namespaceglow_a23bf5dcbdf3e69fcee124d73bc4ecace}\label{namespaceglow_a23bf5dcbdf3e69fcee124d73bc4ecace}} 
\index{glow@{glow}!read\+Png\+Image@{read\+Png\+Image}}
\index{read\+Png\+Image@{read\+Png\+Image}!glow@{glow}}
\subsubsection{\texorpdfstring{read\+Png\+Image()}{readPngImage()}}
{\footnotesize\ttfamily bool glow\+::read\+Png\+Image (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_tensor}{Tensor} $\ast$}]{T,  }\item[{const char $\ast$}]{filename,  }\item[{std\+::pair$<$ float, float $>$}]{range,  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{mean = {\ttfamily zeroMean},  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{stddev = {\ttfamily oneStd} }\end{DoxyParamCaption})}

Reads a png image. \begin{DoxyReturn}{Returns}
True if an error occurred. The values of the image are in the range {\ttfamily range}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_aa05ae0a1df66d2a01e935bcfa21e1874}\label{namespaceglow_aa05ae0a1df66d2a01e935bcfa21e1874}} 
\index{glow@{glow}!read\+Png\+Image\+And\+Preprocess@{read\+Png\+Image\+And\+Preprocess}}
\index{read\+Png\+Image\+And\+Preprocess@{read\+Png\+Image\+And\+Preprocess}!glow@{glow}}
\subsubsection{\texorpdfstring{read\+Png\+Image\+And\+Preprocess()}{readPngImageAndPreprocess()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_tensor}{Tensor} glow\+::read\+Png\+Image\+And\+Preprocess (\begin{DoxyParamCaption}\item[{llvm\+::\+String\+Ref}]{filename,  }\item[{\hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode}}]{image\+Norm\+Mode,  }\item[{\hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order}}]{image\+Channel\+Order,  }\item[{\hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout}}]{image\+Layout,  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{mean = {\ttfamily zeroMean},  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{stddev = {\ttfamily oneStd} }\end{DoxyParamCaption})}

Read a png image and preprocess it according to several parameters. Create a tensor and store the preprocessed image data into this tensor. 
\begin{DoxyParams}{Parameters}
{\em filename} & the png file to read. \\
\hline
{\em image\+Norm\+Mode} & normalize values to this range. \\
\hline
{\em image\+Channel\+Order} & the order of color channels. \\
\hline
{\em image\+Layout} & the order of dimensions (channel, height, and width). \\
\hline
{\em mean} & use special mean to normalize. \\
\hline
{\em stdev} & use special stddev to normalize. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceglow_a4355b249e26c8744ca54250df4d12f89}\label{namespaceglow_a4355b249e26c8744ca54250df4d12f89}} 
\index{glow@{glow}!read\+Png\+Image\+And\+Preprocess@{read\+Png\+Image\+And\+Preprocess}}
\index{read\+Png\+Image\+And\+Preprocess@{read\+Png\+Image\+And\+Preprocess}!glow@{glow}}
\subsubsection{\texorpdfstring{read\+Png\+Image\+And\+Preprocess()}{readPngImageAndPreprocess()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void glow\+::read\+Png\+Image\+And\+Preprocess (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_tensor}{Tensor} \&}]{image\+Data,  }\item[{llvm\+::\+String\+Ref}]{filename,  }\item[{\hyperlink{namespaceglow_af836699afb1d36a88df0d50d74fde931}{Image\+Normalization\+Mode}}]{image\+Norm\+Mode,  }\item[{\hyperlink{namespaceglow_a2747942676633510584a944637b8eb59}{Image\+Channel\+Order}}]{image\+Channel\+Order,  }\item[{\hyperlink{namespaceglow_a06c384b9844d09e4dd277eb509728dce}{Image\+Layout}}]{image\+Layout,  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{mean = {\ttfamily zeroMean},  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{stddev = {\ttfamily oneStd} }\end{DoxyParamCaption})}

Read a png image and preprocess it according to several parameters. Take a tensor as a parameter and store the preprocessed image data into this tensor. 
\begin{DoxyParams}{Parameters}
{\em image\+Data} & the tensor into which the preprocessed image data will be stored. \\
\hline
{\em filename} & the png file to read. \\
\hline
{\em image\+Norm\+Mode} & normalize values to this range. \\
\hline
{\em image\+Channel\+Order} & the order of color channels. \\
\hline
{\em image\+Layout} & the order of dimensions (channel, height, and width). \\
\hline
{\em mean} & use special mean to normalize. \\
\hline
{\em stdev} & use special stddev to normalize. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceglow_a4089f87152e44934daec43bb106d9858}\label{namespaceglow_a4089f87152e44934daec43bb106d9858}} 
\index{glow@{glow}!recursive\+Clone@{recursive\+Clone}}
\index{recursive\+Clone@{recursive\+Clone}!glow@{glow}}
\subsubsection{\texorpdfstring{recursive\+Clone()}{recursiveClone()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1_node}{Node} $\ast$ glow\+::recursive\+Clone (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{newF,  }\item[{\hyperlink{classglow_1_1_node}{Node} $\ast$}]{node,  }\item[{\hyperlink{namespaceglow_afe305f16778f20f331d6b2016221a756}{Node\+Map} \&}]{curr\+To\+New }\end{DoxyParamCaption})}

Clone {\ttfamily node} and its sources into {\ttfamily newF} using old-\/to-\/new mapping {\ttfamily curr\+To\+New}. \mbox{\Hypertarget{namespaceglow_a5efbd9d8157489eb3b55e5c9fafb5fb7}\label{namespaceglow_a5efbd9d8157489eb3b55e5c9fafb5fb7}} 
\index{glow@{glow}!report\+Context@{report\+Context}}
\index{report\+Context@{report\+Context}!glow@{glow}}
\subsubsection{\texorpdfstring{report\+Context()}{reportContext()}}
{\footnotesize\ttfamily template$<$typename Ty $>$ \\
void glow\+::report\+Context (\begin{DoxyParamCaption}\item[{const Ty \&}]{a }\end{DoxyParamCaption})}

Default report\+Context function used to print {\ttfamily a}. The default implementation relies on operator$<$$<$ being available. The actual printing is done calling \hyperlink{namespaceglow_a9d164b45d9fb735f448cd7985bcdf203}{glow\+::report}. \mbox{\Hypertarget{namespaceglow_a2d7264d309f534807df9015c8bccda87}\label{namespaceglow_a2d7264d309f534807df9015c8bccda87}} 
\index{glow@{glow}!run\+Batch@{run\+Batch}}
\index{run\+Batch@{run\+Batch}!glow@{glow}}
\subsubsection{\texorpdfstring{run\+Batch()}{runBatch()}}
{\footnotesize\ttfamily void glow\+::run\+Batch (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_execution_engine}{Execution\+Engine} \&}]{EE,  }\item[{\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{size\+\_\+t}]{iterations,  }\item[{size\+\_\+t \&}]{sample\+Counter,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$$>$}]{ph,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$$>$}]{inputs,  }\item[{llvm\+::\+String\+Ref}]{name = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})}

Runs {\ttfamily iterations} iterations of the compiled function. The method updates a global counter and future invocations of this method continue running iterations of the batch at the next available slice.

The method updates the placeholder in {\ttfamily ph} with the tensors {\ttfamily inputs}. The shape of the slice has to be identical to the shape of slices in the batch. All dimensions, except for the first (batch) dimension must be identical.

The variable {\ttfamily sample\+Counter} is consumed and updated by the function. This variable records the number of samples that were consumed by the network in previous iterations. The next input to be loaded is (sample\+Counter \% batchsize). If there is more than one compiled\+Function {\ttfamily name} must be provided to specify the desired function. \mbox{\Hypertarget{namespaceglow_a70f636287069c1f7f97e401c440ae580}\label{namespaceglow_a70f636287069c1f7f97e401c440ae580}} 
\index{glow@{glow}!run\+D\+C\+E\+Pass@{run\+D\+C\+E\+Pass}}
\index{run\+D\+C\+E\+Pass@{run\+D\+C\+E\+Pass}!glow@{glow}}
\subsubsection{\texorpdfstring{run\+D\+C\+E\+Pass()}{runDCEPass()}}
{\footnotesize\ttfamily bool glow\+::run\+D\+C\+E\+Pass (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{\hyperlink{structglow_1_1_compilation_context}{Compilation\+Context} \&}]{cctx }\end{DoxyParamCaption})}



Helper to run a D\+CE pass on {\ttfamily F} given {\ttfamily cctx}. 

\begin{DoxyReturn}{Returns}
if {\ttfamily was} modified. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a81686f1483028ad3045a94ef9760a3b6}\label{namespaceglow_a81686f1483028ad3045a94ef9760a3b6}} 
\index{glow@{glow}!to\+Binary@{to\+Binary}}
\index{to\+Binary@{to\+Binary}!glow@{glow}}
\subsubsection{\texorpdfstring{to\+Binary()}{toBinary()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily size\+\_\+t glow\+::to\+Binary (\begin{DoxyParamCaption}\item[{float}]{f }\end{DoxyParamCaption})}



Convert a float into an unsigned integer binary representation. 

Convert a float into an unsigned integer binary representation. F\+I\+X\+ME\+: This is a workaround, because defining the hash\+\_\+code hash\+\_\+value(float) does not work for some reason. \mbox{\Hypertarget{namespaceglow_a13cf69ac6cea3abdeffaf975e3f9f02d}\label{namespaceglow_a13cf69ac6cea3abdeffaf975e3f9f02d}} 
\index{glow@{glow}!to\+Binary@{to\+Binary}}
\index{to\+Binary@{to\+Binary}!glow@{glow}}
\subsubsection{\texorpdfstring{to\+Binary()}{toBinary()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::vector$<$ size\+\_\+t $>$ glow\+::to\+Binary (\begin{DoxyParamCaption}\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{vec }\end{DoxyParamCaption})}

Convert a collection of floats into a vector of unsigned integer binary representation. F\+I\+X\+ME\+: This is a workaround, because defining the hash\+\_\+code hash\+\_\+value(float) does not work for some reason.

Convert a collection of floats into a vector of unsigned integer binary representation. \mbox{\Hypertarget{namespaceglow_a697c3d30b72e51fbe7d1a027a77f530c}\label{namespaceglow_a697c3d30b72e51fbe7d1a027a77f530c}} 
\index{glow@{glow}!tolower@{tolower}}
\index{tolower@{tolower}!glow@{glow}}
\subsubsection{\texorpdfstring{tolower()}{tolower()}}
{\footnotesize\ttfamily std\+::string glow\+::tolower (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{in }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the content of the string {\ttfamily in} after conversion to lower case. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_ad735d6bafe7a0cb3ffb5482656235b2e}\label{namespaceglow_ad735d6bafe7a0cb3ffb5482656235b2e}} 
\index{glow@{glow}!unexpected\+Node\+Error\+Message@{unexpected\+Node\+Error\+Message}}
\index{unexpected\+Node\+Error\+Message@{unexpected\+Node\+Error\+Message}!glow@{glow}}
\subsubsection{\texorpdfstring{unexpected\+Node\+Error\+Message()}{unexpectedNodeErrorMessage()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::string glow\+::unexpected\+Node\+Error\+Message (\begin{DoxyParamCaption}\item[{const T \&}]{node,  }\item[{llvm\+::\+String\+Ref}]{message }\end{DoxyParamCaption})}

Prints a single serialized protocol buffer node. This method is useful for debugging the network and printing errors. \mbox{\Hypertarget{namespaceglow_aa54619319c88d7ceb184f4dd70af8ccf}\label{namespaceglow_aa54619319c88d7ceb184f4dd70af8ccf}} 
\index{glow@{glow}!update\+Graph\+Mem\+Info\+By\+Adding\+Node@{update\+Graph\+Mem\+Info\+By\+Adding\+Node}}
\index{update\+Graph\+Mem\+Info\+By\+Adding\+Node@{update\+Graph\+Mem\+Info\+By\+Adding\+Node}!glow@{glow}}
\subsubsection{\texorpdfstring{update\+Graph\+Mem\+Info\+By\+Adding\+Node()}{updateGraphMemInfoByAddingNode()}}
{\footnotesize\ttfamily \hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} glow\+::update\+Graph\+Mem\+Info\+By\+Adding\+Node (\begin{DoxyParamCaption}\item[{const Nodes\+Set \&}]{curr\+Nodes,  }\item[{const \hyperlink{structglow_1_1_graph_mem_info}{Graph\+Mem\+Info} \&}]{info,  }\item[{\hyperlink{classglow_1_1_node}{Node} $\ast$}]{new\+Node }\end{DoxyParamCaption})}

Given nodes set {\ttfamily curr\+Nodes} and its memory usage info {\ttfamily info}, \begin{DoxyReturn}{Returns}
the new memory usage if {\ttfamily new\+Node} is added into {\ttfamily curr\+Nodes}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a24661dfe4d11f5c1cf0db592389a43fc}\label{namespaceglow_a24661dfe4d11f5c1cf0db592389a43fc}} 
\index{glow@{glow}!update\+Input\+Placeholders@{update\+Input\+Placeholders}}
\index{update\+Input\+Placeholders@{update\+Input\+Placeholders}!glow@{glow}}
\subsubsection{\texorpdfstring{update\+Input\+Placeholders()}{updateInputPlaceholders()}}
{\footnotesize\ttfamily void glow\+::update\+Input\+Placeholders (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_placeholder}{Placeholder} $\ast$$>$}]{ph,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$$>$}]{inputs }\end{DoxyParamCaption})}

This method updates the placeholders in {\ttfamily ph} with the tensor content values {\ttfamily inputs}, in {\ttfamily bindings}. \mbox{\Hypertarget{namespaceglow_afe843dcf46487faf7eecfb58d8e15c04}\label{namespaceglow_afe843dcf46487faf7eecfb58d8e15c04}} 
\index{glow@{glow}!update\+Input\+Placeholders\+By\+Name@{update\+Input\+Placeholders\+By\+Name}}
\index{update\+Input\+Placeholders\+By\+Name@{update\+Input\+Placeholders\+By\+Name}!glow@{glow}}
\subsubsection{\texorpdfstring{update\+Input\+Placeholders\+By\+Name()}{updateInputPlaceholdersByName()}}
{\footnotesize\ttfamily void glow\+::update\+Input\+Placeholders\+By\+Name (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} \&}]{bindings,  }\item[{\hyperlink{classglow_1_1_module}{Module} $\ast$}]{mod,  }\item[{llvm\+::\+Array\+Ref$<$ llvm\+::\+String\+Ref $>$}]{ph,  }\item[{llvm\+::\+Array\+Ref$<$ \hyperlink{classglow_1_1_tensor}{Tensor} $\ast$$>$}]{inputs }\end{DoxyParamCaption})}

This method updates the placeholders in the module. The placeholders are found by name in {\ttfamily ph} with the tensor content values {\ttfamily inputs}. \mbox{\Hypertarget{namespaceglow_acfb0a7a5b75a41f5ba57843e7f242338}\label{namespaceglow_acfb0a7a5b75a41f5ba57843e7f242338}} 
\index{glow@{glow}!write\+Png\+Image@{write\+Png\+Image}}
\index{write\+Png\+Image@{write\+Png\+Image}!glow@{glow}}
\subsubsection{\texorpdfstring{write\+Png\+Image()}{writePngImage()}}
{\footnotesize\ttfamily bool glow\+::write\+Png\+Image (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_tensor}{Tensor} $\ast$}]{T,  }\item[{const char $\ast$}]{filename,  }\item[{std\+::pair$<$ float, float $>$}]{range,  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{mean = {\ttfamily zeroMean},  }\item[{llvm\+::\+Array\+Ref$<$ float $>$}]{stddev = {\ttfamily oneStd} }\end{DoxyParamCaption})}

Writes a png image. \begin{DoxyReturn}{Returns}
True if an error occurred. The values of the image are in the range {\ttfamily range}. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceglow_a5605652aaef5081976134120c3dcd4d5}\label{namespaceglow_a5605652aaef5081976134120c3dcd4d5}} 
\index{glow@{glow}!write\+To\+File@{write\+To\+File}}
\index{write\+To\+File@{write\+To\+File}!glow@{glow}}
\subsubsection{\texorpdfstring{write\+To\+File()}{writeToFile()}}
{\footnotesize\ttfamily void glow\+::write\+To\+File (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_tensor}{Tensor} \&}]{T,  }\item[{llvm\+::\+String\+Ref}]{filename }\end{DoxyParamCaption})}

Write \hyperlink{classglow_1_1_tensor}{Tensor} data {\ttfamily T} to a file named {\ttfamily filename}.

NB\+: This function is primarily a debugging aid, not a serialization format. It stores only the binary data of the tensor (not the dimensions), and writes tensors assuming host endianness. 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespaceglow_ad352d0b626337dc5b2e9ef7593268075}\label{namespaceglow_ad352d0b626337dc5b2e9ef7593268075}} 
\index{glow@{glow}!Debug\+Flag@{Debug\+Flag}}
\index{Debug\+Flag@{Debug\+Flag}!glow@{glow}}
\subsubsection{\texorpdfstring{Debug\+Flag}{DebugFlag}}
{\footnotesize\ttfamily bool glow\+::\+Debug\+Flag = false}



Set to true if \textquotesingle{}-\/debug-\/glow\textquotesingle{} command line option is specified. 

Exported boolean set by -\/debug-\/glow option. 