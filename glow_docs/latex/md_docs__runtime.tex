The Glow runtime is responsible for handling adding and running networks on Glow. Below is a high level view of the runtime architecture. It consists of five key components\+: Host\+Manager, Device\+Manager, Partitioner, Provisioner, and Executor.

\section*{Data Structures\+:}

There are a few key data structures used by the runtime and can be found in \hyperlink{_runtime_types_8h_source}{Runtime\+Types.\+h}, they are discussed below.

\subsubsection*{Device\+Info\+:}

This structure contains information about the device that the partitioner will use to partition a network. This inlcudes things like available memory and computation capability.

\subsubsection*{Device\+Config\+:}

A base class used in configuring a Device\+Manager. It is meant to contain information that allows the Device\+Manager to uniquely identify the device and initialize it.

\subsubsection*{D\+AG}

When a network is partitioned, its partitions and their relations are modeled in a D\+AG. The D\+AG contains the information for the entire network.

\subsubsection*{D\+A\+G\+Node}

The D\+A\+G\+Node is a single node in the D\+AG and contains everything needed to run a partition and model the partitions\textquotesingle{}s dependencies.

\section*{Components}

The runtime is composed of a few key elements\+: Host\+Manager, Partitioner, Provisioner, Executor, and Device\+Manager.



\subsubsection*{Host Manager\+:}

The Host\+Manager is the container for the other components. It serves as the interface externally, handling network init and run requests. The Host\+Manager routes a request through the other components and stores the execution\+D\+AG for each network family member.

\subsubsection*{Partitioner\+:}

This component is responsible for dividing up the provided network into sub-\/networks that can be run on multiple devices. It receives a Module and Device\+Info from the Host\+Manager and lowers the module. Then it does the partitioning based on hardware constraints and heuristics to optimize execution time. It outputs a list of execution\+D\+A\+Gs, one per network.

\subsubsection*{Provisioner\+:}

The Provisioner takes in the list of execution\+D\+AG and assigns sub-\/function to specific devices. The Provisioner compiles each sub-\/function and stores them in a map, it then passes a pointer to the compiled\+Function and a Module reference to the Device\+Manager to initialize the function on the device. It fills in the remaining fields of the excecution\+D\+A\+Gs and returns them in a list to the Host\+Manager.

\subsubsection*{Executor\+:}

The Executor handles the execution of the network. It walks the execution\+D\+AG calling execution of each sub network in accordance with their dependencies. This handles allocation of contexts for the sub-\/networks, and moving one network\textquotesingle{}s outputs to the inputs of another network.

\subsubsection*{Device Manager\+:}

The Device\+Manager is an abstraction for the device which runs on the host. The manager handles initializing the device, collecting constants and preparing the device for execution, and executing a network on the device. It also handles unloading networks from the device. There is a backend specific Device\+Manager per backend type.

\section*{Device A\+PI\+:}

There is a pairing between the backend and the device manager. The backend is provided a module which contains the computation graph. It returns a backend specific compiled function which inherits from compiled\+Function and contains the instructions to run the network on the device. The compiled\+Function will serve as a container/abstraction for device specific executable code. The specific format is left to the backend implementation.

The backend specific device manager inherits from Device\+Manager and consumes the compiled\+Function generated by its matching backend. The Device\+Manager knows how to copy the device specific code to the device and initialize it for execution. The Device\+Manager also handles execution which means loading the inputs to the device waiting for the device to signal that the outputs are ready, and copying outputs from the device.



\section*{Network Initialization\+:}

Below we have a diagram illustrating the process of adding a network to the Runtime.
\begin{DoxyItemize}
\item A Module containing some functions to be added, is provided to the Host\+Manager.
\item The Host\+Manager passes this Module along to the Partitioner which partitions the network.
\item The D\+A\+Gs output from the Partitioner are then passed to the Provisioner which handles actual device allocation.
\item The Device\+Manager handles preparing the device to run the function. This includes allocating memory on the device, copying constants from the Module to the device, and loading the function on the device.
\end{DoxyItemize}



\section*{Network Execution\+:}

For execution we have a similar diagram stepping through the network execution process.
\begin{DoxyItemize}
\item The Host\+Manager is provided a network name and Execution\+Context.
\item The Host\+Manager passes the Execution\+Context on to the Executor, along with the D\+AG for the network.
\item The Executor calls into the Device\+Manager to kick off execution for all partitions which have no unment dependancies. It procedes to walk the D\+AG and execute each partition as its dependancies are met.
\end{DoxyItemize}

 