\hypertarget{classglow_1_1runtime_1_1_device_manager}{}\section{glow\+:\+:runtime\+:\+:Device\+Manager Class Reference}
\label{classglow_1_1runtime_1_1_device_manager}\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}


Interface managing a specific instance of a device.  




{\ttfamily \#include $<$Device\+Manager.\+h$>$}

Inheritance diagram for glow\+:\+:runtime\+:\+:Device\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.244444cm]{classglow_1_1runtime_1_1_device_manager}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_abbfb4fb1458c6725d304cd581e247cbf}\label{classglow_1_1runtime_1_1_device_manager_abbfb4fb1458c6725d304cd581e247cbf}} 
{\bfseries Device\+Manager} (const \hyperlink{structglow_1_1runtime_1_1_device_config}{Device\+Config} \&config)
\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a5adbd25b00686c38947ea6380e03e574}\label{classglow_1_1runtime_1_1_device_manager_a5adbd25b00686c38947ea6380e03e574}} 
virtual \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{classglow_1_1runtime_1_1_device_manager_a5adbd25b00686c38947ea6380e03e574}{init} ()
\begin{DoxyCompactList}\small\item\em Initialize the device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classglow_1_1runtime_1_1_device_manager_a9bbf9a88f8bf9ddc0ce63590580aa91f}{add\+Network} (const \hyperlink{classglow_1_1_module}{Module} $\ast$module, Function\+Map\+Ty functions, Ready\+C\+B\+Ty ready\+CB)=0
\item 
virtual void \hyperlink{classglow_1_1runtime_1_1_device_manager_a147c76a007db17659c1962c1fa864f9a}{evict\+Network} (std\+::string function\+Name, Evict\+Function\+C\+B\+Ty evict\+CB=\mbox{[}$\,$\mbox{]}(std\+::string, \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error}) \{ \})=0
\item 
virtual runtime\+::\+Run\+Identifier\+Ty \hyperlink{classglow_1_1runtime_1_1_device_manager_ac182cdf6ed9f6903c11fa71c0446d1f7}{run\+Function} (std\+::string function\+Name, std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_execution_context}{Execution\+Context} $>$ context, runtime\+::\+Result\+C\+B\+Ty result\+CB)=0
\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a0f32d3a9c8f72962febe2d7b284486ba}\label{classglow_1_1runtime_1_1_device_manager_a0f32d3a9c8f72962febe2d7b284486ba}} 
virtual \hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error} \hyperlink{classglow_1_1runtime_1_1_device_manager_a0f32d3a9c8f72962febe2d7b284486ba}{stop} (bool block=true)
\begin{DoxyCompactList}\small\item\em Stops execution and shuts down the Device. \end{DoxyCompactList}\item 
llvm\+::\+String\+Ref \hyperlink{classglow_1_1runtime_1_1_device_manager_aa86bf2fba88df94818b1bb5cec5dd2d7}{get\+Backend\+Name} ()
\item 
llvm\+::\+String\+Ref \hyperlink{classglow_1_1runtime_1_1_device_manager_a839a6b19dd88cbfee2c758d92ac4e1e0}{get\+Param\+By\+Name} (llvm\+::\+String\+Ref name) const
\item 
virtual uint64\+\_\+t \hyperlink{classglow_1_1runtime_1_1_device_manager_ad158f1c1f9f32b48927f50d48f80decb}{get\+Maximum\+Memory} () const =0
\item 
virtual uint64\+\_\+t \hyperlink{classglow_1_1runtime_1_1_device_manager_a5a84ac3b23b9b6d72f50d763913ed8aa}{get\+Available\+Memory} () const =0
\item 
virtual bool \hyperlink{classglow_1_1runtime_1_1_device_manager_ae9bba4abda9cb6aa1359a69e942feb22}{is\+Memory\+Available} (uint64\+\_\+t estimate) const =0
\item 
const \hyperlink{structglow_1_1runtime_1_1_device_config}{Device\+Config} \& \hyperlink{classglow_1_1runtime_1_1_device_manager_a70a7ee3ea3c0b27c0d0d934e45b99ca3}{get\+Device\+Config} ()
\item 
virtual \hyperlink{structglow_1_1runtime_1_1_device_info}{Device\+Info} \hyperlink{classglow_1_1runtime_1_1_device_manager_aaf319fc3b9aa67c5e053bdf690e89d34}{get\+Device\+Info} () const
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a3e68dafd3ed5d97930301a02b13a7a8a}\label{classglow_1_1runtime_1_1_device_manager_a3e68dafd3ed5d97930301a02b13a7a8a}} 
static \hyperlink{classglow_1_1runtime_1_1_device_manager}{Device\+Manager} $\ast$ \hyperlink{classglow_1_1runtime_1_1_device_manager_a3e68dafd3ed5d97930301a02b13a7a8a}{create\+Device\+Manager} (const \hyperlink{structglow_1_1runtime_1_1_device_config}{Device\+Config} \&config)
\begin{DoxyCompactList}\small\item\em Create a device manager based on the device config {\ttfamily config}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_ab3ff4fec5795590f9ad2765ae1d415af}\label{classglow_1_1runtime_1_1_device_manager_ab3ff4fec5795590f9ad2765ae1d415af}} 
static unsigned \hyperlink{classglow_1_1runtime_1_1_device_manager_ab3ff4fec5795590f9ad2765ae1d415af}{num\+Devices} (llvm\+::\+String\+Ref backend\+Name)
\begin{DoxyCompactList}\small\item\em Query the system for the number of devices of a specified kind. \end{DoxyCompactList}\item 
static std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{structglow_1_1runtime_1_1_device_config}{runtime\+::\+Device\+Config} $>$ $>$ \hyperlink{classglow_1_1runtime_1_1_device_manager_a3ba362bdcfcc16c652cf1fdd769291db}{generate\+Device\+Configs} (llvm\+::\+String\+Ref backend\+Name)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_abcc952c3f1b9895669ca7a9855346f7a}\label{classglow_1_1runtime_1_1_device_manager_abcc952c3f1b9895669ca7a9855346f7a}} 
void \hyperlink{classglow_1_1runtime_1_1_device_manager_abcc952c3f1b9895669ca7a9855346f7a}{export\+Memory\+Counters} ()
\begin{DoxyCompactList}\small\item\em Helper method to export memory usage counters. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a4b49e79110084226d80fe445d1a9d2cc}\label{classglow_1_1runtime_1_1_device_manager_a4b49e79110084226d80fe445d1a9d2cc}} 
void \hyperlink{classglow_1_1runtime_1_1_device_manager_a4b49e79110084226d80fe445d1a9d2cc}{zero\+Memory\+Counters} ()
\begin{DoxyCompactList}\small\item\em Helper method to zero out memory counters, used when a device is freed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a77fc2be49d409dd7228f9c83525ba651}\label{classglow_1_1runtime_1_1_device_manager_a77fc2be49d409dd7228f9c83525ba651}} 
\hyperlink{structglow_1_1runtime_1_1_device_config}{Device\+Config} \hyperlink{classglow_1_1runtime_1_1_device_manager_a77fc2be49d409dd7228f9c83525ba651}{config\+\_\+}
\begin{DoxyCompactList}\small\item\em Configuration object for the device. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a9f09dfe989c0ddb00809ed12888e527c}\label{classglow_1_1runtime_1_1_device_manager_a9f09dfe989c0ddb00809ed12888e527c}} 
const std\+::string \hyperlink{classglow_1_1runtime_1_1_device_manager_a9f09dfe989c0ddb00809ed12888e527c}{available\+Memory\+Key\+\_\+} \{\char`\"{}glow.\+device.\+available\+\_\+memory.\+device\char`\"{}\}
\begin{DoxyCompactList}\small\item\em String for logging available memory for the device. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_aa267c5e28fdeeb4fe59ad94bdf71e5fa}\label{classglow_1_1runtime_1_1_device_manager_aa267c5e28fdeeb4fe59ad94bdf71e5fa}} 
const std\+::string \hyperlink{classglow_1_1runtime_1_1_device_manager_aa267c5e28fdeeb4fe59ad94bdf71e5fa}{used\+Memory\+Key\+\_\+} \{\char`\"{}glow.\+device.\+used\+\_\+memory.\+device\char`\"{}\}
\begin{DoxyCompactList}\small\item\em String for logging used memory for the device. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_af95be4fe47e7cf4f5f8061d573eef9b5}\label{classglow_1_1runtime_1_1_device_manager_af95be4fe47e7cf4f5f8061d573eef9b5}} 
std\+::atomic$<$ uint64\+\_\+t $>$ \hyperlink{classglow_1_1runtime_1_1_device_manager_af95be4fe47e7cf4f5f8061d573eef9b5}{max\+Memory\+Bytes\+\_\+} \{0\}
\begin{DoxyCompactList}\small\item\em Maximum available memory on the device. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a37380c1f168e833e9382e6560866be19}\label{classglow_1_1runtime_1_1_device_manager_a37380c1f168e833e9382e6560866be19}} 
std\+::atomic$<$ uint64\+\_\+t $>$ \hyperlink{classglow_1_1runtime_1_1_device_manager_a37380c1f168e833e9382e6560866be19}{used\+Memory\+Bytes\+\_\+} \{0\}
\begin{DoxyCompactList}\small\item\em Amount of memory used by all models. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Interface managing a specific instance of a device. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a9bbf9a88f8bf9ddc0ce63590580aa91f}\label{classglow_1_1runtime_1_1_device_manager_a9bbf9a88f8bf9ddc0ce63590580aa91f}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!add\+Network@{add\+Network}}
\index{add\+Network@{add\+Network}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{add\+Network()}{addNetwork()}}
{\footnotesize\ttfamily virtual void glow\+::runtime\+::\+Device\+Manager\+::add\+Network (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_module}{Module} $\ast$}]{module,  }\item[{Function\+Map\+Ty}]{functions,  }\item[{Ready\+C\+B\+Ty}]{ready\+CB }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Load the provided module into the device, ready\+CB will be called when ready to use. {\ttfamily functions} contains the list of functions to load, keyed by their name (as used in run\+Function). 

Implemented in \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_ac812a0a4b70e788e13255ad144bf792f}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager_a4fcbaacf52744393b047392777c9ae14}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_dummy_device_manager_a73a826505a055281b9ad2902f6ffdb0f}{glow\+::runtime\+::\+Dummy\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_queue_backed_device_manager_a70b2d1886841e1c223e6813e218545f5}{glow\+::runtime\+::\+Queue\+Backed\+Device\+Manager}.

\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a147c76a007db17659c1962c1fa864f9a}\label{classglow_1_1runtime_1_1_device_manager_a147c76a007db17659c1962c1fa864f9a}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!evict\+Network@{evict\+Network}}
\index{evict\+Network@{evict\+Network}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{evict\+Network()}{evictNetwork()}}
{\footnotesize\ttfamily virtual void glow\+::runtime\+::\+Device\+Manager\+::evict\+Network (\begin{DoxyParamCaption}\item[{std\+::string}]{function\+Name,  }\item[{Evict\+Function\+C\+B\+Ty}]{evict\+CB = {\ttfamily \mbox{[}\mbox{]}(std\+:\+:string,~\hyperlink{namespaceglow_afdb176c3a672ef66db0ecfc19a8d39bf}{Error})~\{~\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Remove (and delete) the provided function, freeing up space on the device. {\ttfamily evict\+CB} will be called when the operation is completed or attempted and failed. 

Implemented in \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_a142fa73f19c5731a522a40c2646c070e}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_dummy_device_manager_a69a52700a23ae64f2c9db09e1e32c038}{glow\+::runtime\+::\+Dummy\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager_ae8afcfbbd9badbdd13dacc08d813ec2d}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_queue_backed_device_manager_abbccad8e2a9b082eb6c5865352c67ef8}{glow\+::runtime\+::\+Queue\+Backed\+Device\+Manager}.

\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a3ba362bdcfcc16c652cf1fdd769291db}\label{classglow_1_1runtime_1_1_device_manager_a3ba362bdcfcc16c652cf1fdd769291db}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!generate\+Device\+Configs@{generate\+Device\+Configs}}
\index{generate\+Device\+Configs@{generate\+Device\+Configs}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{generate\+Device\+Configs()}{generateDeviceConfigs()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{structglow_1_1runtime_1_1_device_config}{runtime\+::\+Device\+Config} $>$ $>$ glow\+::runtime\+::\+Device\+Manager\+::generate\+Device\+Configs (\begin{DoxyParamCaption}\item[{llvm\+::\+String\+Ref}]{backend\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Device discovery for a given backend kind. Returns a vector of configs for all found devices. \mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a5a84ac3b23b9b6d72f50d763913ed8aa}\label{classglow_1_1runtime_1_1_device_manager_a5a84ac3b23b9b6d72f50d763913ed8aa}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!get\+Available\+Memory@{get\+Available\+Memory}}
\index{get\+Available\+Memory@{get\+Available\+Memory}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{get\+Available\+Memory()}{getAvailableMemory()}}
{\footnotesize\ttfamily virtual uint64\+\_\+t glow\+::runtime\+::\+Device\+Manager\+::get\+Available\+Memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}
the currently available memory (in bytes) available on the device, for provisioning new networks. 
\end{DoxyReturn}


Implemented in \hyperlink{classglow_1_1runtime_1_1_open_c_l_device_manager_a8ed9fd00ebbed793fd430f9dd227a2cd}{glow\+::runtime\+::\+Open\+C\+L\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_a9b23cdaa74210f057dd3bb6f839e0509}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager_ab494e0ba08e0859f436ef591c15f7fd5}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_c_p_u_device_manager_a652125a46bce98a6b08cfb9907b03b26}{glow\+::runtime\+::\+C\+P\+U\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_interpreter_device_manager_aad7c95da9a3fe8627093a3ba8ad224d4}{glow\+::runtime\+::\+Interpreter\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_dummy_device_manager_a96ef72c763a1932e1482c29b4eea486b}{glow\+::runtime\+::\+Dummy\+Device\+Manager}.

\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_aa86bf2fba88df94818b1bb5cec5dd2d7}\label{classglow_1_1runtime_1_1_device_manager_aa86bf2fba88df94818b1bb5cec5dd2d7}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!get\+Backend\+Name@{get\+Backend\+Name}}
\index{get\+Backend\+Name@{get\+Backend\+Name}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{get\+Backend\+Name()}{getBackendName()}}
{\footnotesize\ttfamily llvm\+::\+String\+Ref glow\+::runtime\+::\+Device\+Manager\+::get\+Backend\+Name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the name of backend that powers this Device. 
\end{DoxyReturn}
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a70a7ee3ea3c0b27c0d0d934e45b99ca3}\label{classglow_1_1runtime_1_1_device_manager_a70a7ee3ea3c0b27c0d0d934e45b99ca3}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!get\+Device\+Config@{get\+Device\+Config}}
\index{get\+Device\+Config@{get\+Device\+Config}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{get\+Device\+Config()}{getDeviceConfig()}}
{\footnotesize\ttfamily const \hyperlink{structglow_1_1runtime_1_1_device_config}{Device\+Config}\& glow\+::runtime\+::\+Device\+Manager\+::get\+Device\+Config (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the \hyperlink{structglow_1_1runtime_1_1_device_config}{Device\+Config} which initialized this device. 
\end{DoxyReturn}
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_aaf319fc3b9aa67c5e053bdf690e89d34}\label{classglow_1_1runtime_1_1_device_manager_aaf319fc3b9aa67c5e053bdf690e89d34}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!get\+Device\+Info@{get\+Device\+Info}}
\index{get\+Device\+Info@{get\+Device\+Info}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{get\+Device\+Info()}{getDeviceInfo()}}
{\footnotesize\ttfamily virtual \hyperlink{structglow_1_1runtime_1_1_device_info}{Device\+Info} glow\+::runtime\+::\+Device\+Manager\+::get\+Device\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
the \hyperlink{structglow_1_1runtime_1_1_device_info}{Device\+Info} for this device containing peak limits for compute and bandwidths (used in partitioning). 
\end{DoxyReturn}


Reimplemented in \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_a5c73935d669a16b259c37b335caae76d}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_c_p_u_device_manager_af2ab7f66e45a81dd9fe1f2ad4054bc6c}{glow\+::runtime\+::\+C\+P\+U\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_interpreter_device_manager_a02839dd04dcd6e6c3d768f39c666b67b}{glow\+::runtime\+::\+Interpreter\+Device\+Manager}.

\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_ad158f1c1f9f32b48927f50d48f80decb}\label{classglow_1_1runtime_1_1_device_manager_ad158f1c1f9f32b48927f50d48f80decb}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!get\+Maximum\+Memory@{get\+Maximum\+Memory}}
\index{get\+Maximum\+Memory@{get\+Maximum\+Memory}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{get\+Maximum\+Memory()}{getMaximumMemory()}}
{\footnotesize\ttfamily virtual uint64\+\_\+t glow\+::runtime\+::\+Device\+Manager\+::get\+Maximum\+Memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}
the maximum memory (in bytes) available on the device. 
\end{DoxyReturn}


Implemented in \hyperlink{classglow_1_1runtime_1_1_open_c_l_device_manager_aec918b4dd4a7a0cd926844cf225db306}{glow\+::runtime\+::\+Open\+C\+L\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_a2e8ddfc33d1a4f482bcd1f9a5e4e5350}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager_ae71ea73f150f1c35a735ba06efa871db}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_c_p_u_device_manager_a865758926a01983e4867ce0c2583ec3a}{glow\+::runtime\+::\+C\+P\+U\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_interpreter_device_manager_a6b7d0747cee65050a106437a55997036}{glow\+::runtime\+::\+Interpreter\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_dummy_device_manager_a58bc8e9d658c8b173d27527a4251e5e0}{glow\+::runtime\+::\+Dummy\+Device\+Manager}.

\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_a839a6b19dd88cbfee2c758d92ac4e1e0}\label{classglow_1_1runtime_1_1_device_manager_a839a6b19dd88cbfee2c758d92ac4e1e0}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!get\+Param\+By\+Name@{get\+Param\+By\+Name}}
\index{get\+Param\+By\+Name@{get\+Param\+By\+Name}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{get\+Param\+By\+Name()}{getParamByName()}}
{\footnotesize\ttfamily llvm\+::\+String\+Ref glow\+::runtime\+::\+Device\+Manager\+::get\+Param\+By\+Name (\begin{DoxyParamCaption}\item[{llvm\+::\+String\+Ref}]{name }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a string with {\ttfamily name} in parameters. 
\end{DoxyReturn}
\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_ae9bba4abda9cb6aa1359a69e942feb22}\label{classglow_1_1runtime_1_1_device_manager_ae9bba4abda9cb6aa1359a69e942feb22}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!is\+Memory\+Available@{is\+Memory\+Available}}
\index{is\+Memory\+Available@{is\+Memory\+Available}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{is\+Memory\+Available()}{isMemoryAvailable()}}
{\footnotesize\ttfamily virtual bool glow\+::runtime\+::\+Device\+Manager\+::is\+Memory\+Available (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{estimate }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}
true if we expect a \hyperlink{classglow_1_1_module}{Module} with the estimated constant size will fit on the device. 
\end{DoxyReturn}


Implemented in \hyperlink{classglow_1_1runtime_1_1_open_c_l_device_manager_ab94967240f9d1ef5ae26f3a242488809}{glow\+::runtime\+::\+Open\+C\+L\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_aadaab8c13097bb7ec64b219874549c7f}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager_a543e27b561eef6581859d844565c1ac1}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_c_p_u_device_manager_a61e188ea68529ec4a4037e7df81f98f8}{glow\+::runtime\+::\+C\+P\+U\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_interpreter_device_manager_a04615e8203b6f581e8646f631346418a}{glow\+::runtime\+::\+Interpreter\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_dummy_device_manager_a51b1549661977f06447122f0529d8b14}{glow\+::runtime\+::\+Dummy\+Device\+Manager}.

\mbox{\Hypertarget{classglow_1_1runtime_1_1_device_manager_ac182cdf6ed9f6903c11fa71c0446d1f7}\label{classglow_1_1runtime_1_1_device_manager_ac182cdf6ed9f6903c11fa71c0446d1f7}} 
\index{glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}!run\+Function@{run\+Function}}
\index{run\+Function@{run\+Function}!glow\+::runtime\+::\+Device\+Manager@{glow\+::runtime\+::\+Device\+Manager}}
\subsubsection{\texorpdfstring{run\+Function()}{runFunction()}}
{\footnotesize\ttfamily virtual runtime\+::\+Run\+Identifier\+Ty glow\+::runtime\+::\+Device\+Manager\+::run\+Function (\begin{DoxyParamCaption}\item[{std\+::string}]{function\+Name,  }\item[{std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_execution_context}{Execution\+Context} $>$}]{context,  }\item[{runtime\+::\+Result\+C\+B\+Ty}]{result\+CB }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Execute the named \hyperlink{classglow_1_1_function}{Function} in an already provided network on the device. function\+Name must match the name of a function already added. The \hyperlink{classglow_1_1_execution_context}{Execution\+Context}\textquotesingle{}s \hyperlink{classglow_1_1_placeholder_bindings}{Placeholder\+Bindings} should have all Placeholders allocated. result\+CB will be called with the \hyperlink{classglow_1_1_execution_context}{Execution\+Context} containing output tensors filled, and any generated Trace\+Events. 

Implemented in \hyperlink{classglow_1_1runtime_1_1_habana_device_manager_a345fedf5deacdb44274ed92de5dcc962}{glow\+::runtime\+::\+Habana\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_dummy_device_manager_a6a0da3ce939dea1323eead33a27d5487}{glow\+::runtime\+::\+Dummy\+Device\+Manager}, \hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager_a86f8010d5b5c6f235144d930f8392d3a}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager}, and \hyperlink{classglow_1_1runtime_1_1_queue_backed_device_manager_a46bdff62e862da50435f4744a3587f1a}{glow\+::runtime\+::\+Queue\+Backed\+Device\+Manager}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/glow/\+Backends/Device\+Manager.\+h\item 
lib/\+Backends/Device\+Managers.\+cpp\end{DoxyCompactItemize}
