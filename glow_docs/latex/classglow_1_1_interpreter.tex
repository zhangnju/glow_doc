\hypertarget{classglow_1_1_interpreter}{}\section{glow\+:\+:Interpreter Class Reference}
\label{classglow_1_1_interpreter}\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}}


{\ttfamily \#include $<$Interpreter.\+h$>$}

Inheritance diagram for glow\+:\+:Interpreter\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classglow_1_1_interpreter}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classglow_1_1_interpreter_a3f07abd1439980178feb6558cfc1a2dd}\label{classglow_1_1_interpreter_a3f07abd1439980178feb6558cfc1a2dd}} 
\hyperlink{classglow_1_1_interpreter_a3f07abd1439980178feb6558cfc1a2dd}{Interpreter} ()=default
\begin{DoxyCompactList}\small\item\em Ctor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classglow_1_1_interpreter_a1e3131fdf6c79558e269a0241f8ba202}\label{classglow_1_1_interpreter_a1e3131fdf6c79558e269a0241f8ba202}} 
size\+\_\+t {\bfseries get\+Trace\+Event\+Data\+Size} () const override
\item 
\hyperlink{classglow_1_1runtime_1_1_device_manager}{runtime\+::\+Device\+Manager} $\ast$ \hyperlink{classglow_1_1_interpreter_ab14be2abaedd8d7e090bf1aaf874c423}{create\+Device\+Manager} (const \hyperlink{structglow_1_1runtime_1_1_device_config}{runtime\+::\+Device\+Config} \&device\+Config) override
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static size\+\_\+t \hyperlink{classglow_1_1_interpreter_ab113f61cd88594a27b3a86b45c43a3b1}{get\+Trace\+Event\+Data\+Size\+Static} ()
\end{DoxyCompactItemize}
\subsection*{Backend methods.}
\label{_amgrp74a5605ee0c2530d0af87631bd615b01}%
 This is the implementation of the \hyperlink{classglow_1_1_backend}{Backend} interface. \begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classglow_1_1_interpreter_a411faff129fc4eb700f1dfd834839e11}\label{classglow_1_1_interpreter_a411faff129fc4eb700f1dfd834839e11}} 
{\bfseries $\sim$\+Interpreter} () override=default
\item 
\mbox{\Hypertarget{classglow_1_1_interpreter_a3232216f9576c8085d334fc356193184}\label{classglow_1_1_interpreter_a3232216f9576c8085d334fc356193184}} 
std\+::string {\bfseries get\+Backend\+Name} () const override
\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_compiled_function}{Compiled\+Function} $>$ \hyperlink{classglow_1_1_interpreter_a24793ffaf0f6a80a2983dcb117719659}{compile\+IR} (std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} $>$ IR) const override
\item 
\mbox{\Hypertarget{classglow_1_1_interpreter_ade5bdc8e683c53c6a1cebf3959a673e3}\label{classglow_1_1_interpreter_ade5bdc8e683c53c6a1cebf3959a673e3}} 
std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_compiled_function}{Compiled\+Function} $>$ {\bfseries compile\+I\+R\+Without\+Constants} (std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} $>$ IR) const
\item 
\hyperlink{classglow_1_1detail_1_1_glow_expected}{Expected}$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_compiled_function}{Compiled\+Function} $>$ $>$ \hyperlink{classglow_1_1_interpreter_a1de9a9294a6ede268ca5b13f980be67e}{compile} (\hyperlink{classglow_1_1_function}{Function} $\ast$F, const \hyperlink{structglow_1_1_backend_options}{Backend\+Options} \&opts) const override
\begin{DoxyCompactList}\small\item\em Generate code for input function. \end{DoxyCompactList}\item 
bool \hyperlink{classglow_1_1_interpreter_adafc02e2ecf1481c5b08c2f5c909647e}{is\+Op\+Supported} (const \hyperlink{classglow_1_1_node_info}{Node\+Info} \&NI) const override
\item 
bool \hyperlink{classglow_1_1_interpreter_a9dd7a307318bd87414bac5d8cabf5a6f}{verify} (const \hyperlink{classglow_1_1_function}{Function} \&F) const override
\item 
bool \hyperlink{classglow_1_1_interpreter_a2e26be458097546c6bbcdaf59e8f493b}{verify} (const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&IR) const override
\item 
bool \hyperlink{classglow_1_1_interpreter_a4af3e91f6b07d5f896b8db8b4e4d2df4}{should\+Lower} (const \hyperlink{classglow_1_1_node}{Node} $\ast$N) const override
\item 
\mbox{\Hypertarget{classglow_1_1_interpreter_a23e237c4de5b5c5cb2ce9de9ae51173c}\label{classglow_1_1_interpreter_a23e237c4de5b5c5cb2ce9de9ae51173c}} 
static std\+::string {\bfseries get\+Name} ()
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This is the I\+R-\/interpreter. It owns the IR, and the heap, and is able to execute the instructions one at a time. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classglow_1_1_interpreter_a1de9a9294a6ede268ca5b13f980be67e}\label{classglow_1_1_interpreter_a1de9a9294a6ede268ca5b13f980be67e}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!compile@{compile}}
\index{compile@{compile}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{compile()}{compile()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1detail_1_1_glow_expected}{Expected}$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_compiled_function}{Compiled\+Function} $>$ $>$ Interpreter\+::compile (\begin{DoxyParamCaption}\item[{\hyperlink{classglow_1_1_function}{Function} $\ast$}]{F,  }\item[{const \hyperlink{structglow_1_1_backend_options}{Backend\+Options} \&}]{opts }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Generate code for input function. 


\begin{DoxyParams}{Parameters}
{\em F} & given settings in {\ttfamily opts}. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classglow_1_1_backend_ab5f153ac5a6b2d1824f7a9c80ffc72f1}{glow\+::\+Backend}.

\mbox{\Hypertarget{classglow_1_1_interpreter_a24793ffaf0f6a80a2983dcb117719659}\label{classglow_1_1_interpreter_a24793ffaf0f6a80a2983dcb117719659}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!compile\+IR@{compile\+IR}}
\index{compile\+IR@{compile\+IR}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{compile\+I\+R()}{compileIR()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_compiled_function}{Compiled\+Function} $>$ Interpreter\+::compile\+IR (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} $>$}]{IR }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Generate code for input IR function 
\begin{DoxyParams}{Parameters}
{\em I\+R.} & This is used only for unit testing. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classglow_1_1_backend_using_glow_i_r_ab7531d0b400c5f9763f8a58f05565159}{glow\+::\+Backend\+Using\+Glow\+IR}.

\mbox{\Hypertarget{classglow_1_1_interpreter_ab14be2abaedd8d7e090bf1aaf874c423}\label{classglow_1_1_interpreter_ab14be2abaedd8d7e090bf1aaf874c423}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!create\+Device\+Manager@{create\+Device\+Manager}}
\index{create\+Device\+Manager@{create\+Device\+Manager}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{create\+Device\+Manager()}{createDeviceManager()}}
{\footnotesize\ttfamily \hyperlink{classglow_1_1runtime_1_1_device_manager}{runtime\+::\+Device\+Manager}$\ast$ glow\+::\+Interpreter\+::create\+Device\+Manager (\begin{DoxyParamCaption}\item[{const \hyperlink{structglow_1_1runtime_1_1_device_config}{runtime\+::\+Device\+Config} \&}]{device\+Config }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Create device manager corresponding to the backend based on the device\+Config. 

Reimplemented from \hyperlink{classglow_1_1_backend_ab52ff7cc7a83edb282bea2cbf4b8766e}{glow\+::\+Backend}.

\mbox{\Hypertarget{classglow_1_1_interpreter_ab113f61cd88594a27b3a86b45c43a3b1}\label{classglow_1_1_interpreter_ab113f61cd88594a27b3a86b45c43a3b1}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!get\+Trace\+Event\+Data\+Size\+Static@{get\+Trace\+Event\+Data\+Size\+Static}}
\index{get\+Trace\+Event\+Data\+Size\+Static@{get\+Trace\+Event\+Data\+Size\+Static}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{get\+Trace\+Event\+Data\+Size\+Static()}{getTraceEventDataSizeStatic()}}
{\footnotesize\ttfamily static size\+\_\+t glow\+::\+Interpreter\+::get\+Trace\+Event\+Data\+Size\+Static (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

\begin{DoxyReturn}{Returns}
the size of metrics collected for a single \hyperlink{structglow_1_1_trace_event}{Trace\+Event}. 
\end{DoxyReturn}
\mbox{\Hypertarget{classglow_1_1_interpreter_adafc02e2ecf1481c5b08c2f5c909647e}\label{classglow_1_1_interpreter_adafc02e2ecf1481c5b08c2f5c909647e}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!is\+Op\+Supported@{is\+Op\+Supported}}
\index{is\+Op\+Supported@{is\+Op\+Supported}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{is\+Op\+Supported()}{isOpSupported()}}
{\footnotesize\ttfamily bool Interpreter\+::is\+Op\+Supported (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node_info}{Node\+Info} \&}]{NI }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
whether the provided {\ttfamily NI} is supported by the backend. 
\end{DoxyReturn}


Implements \hyperlink{classglow_1_1_backend_a386f7e534956c47f8a6b1457d6e87c67}{glow\+::\+Backend}.

\mbox{\Hypertarget{classglow_1_1_interpreter_a4af3e91f6b07d5f896b8db8b4e4d2df4}\label{classglow_1_1_interpreter_a4af3e91f6b07d5f896b8db8b4e4d2df4}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!should\+Lower@{should\+Lower}}
\index{should\+Lower@{should\+Lower}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{should\+Lower()}{shouldLower()}}
{\footnotesize\ttfamily bool Interpreter\+::should\+Lower (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_node}{Node} $\ast$}]{N }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
true if the supplied \hyperlink{classglow_1_1_node}{Node}  should be lowered. By default, all Nodes are candidates for lowering. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classglow_1_1_backend_aba5bec08f5e60626bcc5238f410d632a}{glow\+::\+Backend}.

\mbox{\Hypertarget{classglow_1_1_interpreter_a9dd7a307318bd87414bac5d8cabf5a6f}\label{classglow_1_1_interpreter_a9dd7a307318bd87414bac5d8cabf5a6f}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!verify@{verify}}
\index{verify@{verify}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{verify()}{verify()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Interpreter\+::verify (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_function}{Function} \&}]{F }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
whether the provided {\ttfamily F} conforms to the backend-\/dependent graph constraints. Giving the backend an opportunity to check that everything conforms to its specific restrictions by overriding this function. It is highly recommended for backends to make their backend specific verifications a super-\/set of target independent \hyperlink{classglow_1_1_function_a73897a61138cf69eacb41357839815df}{Function\+::verify()} by calling it in their overridden implementation. It is not a strict requirement, of course, in case they diverge / the backend has a good reason not to call \hyperlink{classglow_1_1_function_a73897a61138cf69eacb41357839815df}{Function\+::verify()}. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classglow_1_1_backend_a868ff3dc24281eba5900c3ad84baef1b}{glow\+::\+Backend}.

\mbox{\Hypertarget{classglow_1_1_interpreter_a2e26be458097546c6bbcdaf59e8f493b}\label{classglow_1_1_interpreter_a2e26be458097546c6bbcdaf59e8f493b}} 
\index{glow\+::\+Interpreter@{glow\+::\+Interpreter}!verify@{verify}}
\index{verify@{verify}!glow\+::\+Interpreter@{glow\+::\+Interpreter}}
\subsubsection{\texorpdfstring{verify()}{verify()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Interpreter\+::verify (\begin{DoxyParamCaption}\item[{const \hyperlink{classglow_1_1_i_r_function}{I\+R\+Function} \&}]{IR }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
whether the provided {\ttfamily IR} conforms to the backend-\/dependent graph constraints. Giving the backend an opportunity to check that everything conforms to its specific restrictions by overriding this function. It is highly recommended for backends to make their backend specific verifications a super-\/set of target independent \hyperlink{classglow_1_1_i_r_function_a3add272c76243daef4950bf3ff68338c}{I\+R\+Function\+::verify()} by calling it in their overridden implementation. It is not a strict requirement, of course, in case they diverge / the backend has a good reason not to call \hyperlink{classglow_1_1_i_r_function_a3add272c76243daef4950bf3ff68338c}{I\+R\+Function\+::verify()}. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classglow_1_1_backend_a19b5580a7274a1457bcdf3fc05f98cbd}{glow\+::\+Backend}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lib/\+Backends/\+Interpreter/Interpreter.\+h\item 
lib/\+Backends/\+Interpreter/Interpreter.\+cpp\end{DoxyCompactItemize}
