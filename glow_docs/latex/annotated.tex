\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_abstract_dotty_printer}{Abstract\+Dotty\+Printer} \\*A helper class for visiting and generating the dotty graph file }{\pageref{class_abstract_dotty_printer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_adaptive_avg_pool_grad_inst}{glow\+::\+Adaptive\+Avg\+Pool\+Grad\+Inst} }{\pageref{classglow_1_1_adaptive_avg_pool_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_adaptive_avg_pool_grad_node}{glow\+::\+Adaptive\+Avg\+Pool\+Grad\+Node} }{\pageref{classglow_1_1_adaptive_avg_pool_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_adaptive_avg_pool_inst}{glow\+::\+Adaptive\+Avg\+Pool\+Inst} }{\pageref{classglow_1_1_adaptive_avg_pool_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_adaptive_avg_pool_node}{glow\+::\+Adaptive\+Avg\+Pool\+Node} \\*Performs an Adaptive Average Pool operation on the Input given }{\pageref{classglow_1_1_adaptive_avg_pool_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_add_grad_node}{glow\+::\+Add\+Grad\+Node} }{\pageref{classglow_1_1_add_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_add_node}{glow\+::\+Add\+Node} \\*Performs Add on the L\+HS and R\+HS operands }{\pageref{classglow_1_1_add_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_alloc_activation_inst}{glow\+::\+Alloc\+Activation\+Inst} }{\pageref{classglow_1_1_alloc_activation_inst}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_allocations_info}{glow\+::\+Allocations\+Info} }{\pageref{structglow_1_1_allocations_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_arg_max_inst}{glow\+::\+Arg\+Max\+Inst} }{\pageref{classglow_1_1_arg_max_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_arg_max_node}{glow\+::\+Arg\+Max\+Node} \\*Finds index of a maximum element along Axis.\+If Keep\+Dims is not true, the axis is removed from output }{\pageref{classglow_1_1_arg_max_node}}{}
\item\contentsline{section}{\hyperlink{class_arg_max_node_importer}{Arg\+Max\+Node\+Importer} }{\pageref{class_arg_max_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_avg_pool_grad_inst}{glow\+::\+Avg\+Pool\+Grad\+Inst} }{\pageref{classglow_1_1_avg_pool_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_avg_pool_grad_node}{glow\+::\+Avg\+Pool\+Grad\+Node} }{\pageref{classglow_1_1_avg_pool_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_avg_pool_inst}{glow\+::\+Avg\+Pool\+Inst} }{\pageref{classglow_1_1_avg_pool_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_avg_pool_node}{glow\+::\+Avg\+Pool\+Node} \\*Performs an Average Pool operation on the Input given provided Kernels, Strides, and Pads. Supported layouts are defined in the Convolution\+Layout enum\+: N\+H\+WC and N\+C\+HW }{\pageref{classglow_1_1_avg_pool_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_backend}{glow\+::onnxifi\+::\+Backend} \\*\hyperlink{classglow_1_1onnxifi_1_1_backend}{Backend} associated with the Glow backend }{\pageref{classglow_1_1onnxifi_1_1_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_backend}{glow\+::\+Backend} }{\pageref{classglow_1_1_backend}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_backend_hints}{glow\+::\+Backend\+Hints} \\*Hints provided to the \hyperlink{classglow_1_1_backend}{Backend}, the backend is not required to honor them }{\pageref{structglow_1_1_backend_hints}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_backend_info}{glow\+::\+Backend\+Info} }{\pageref{structglow_1_1_backend_info}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_backend_options}{glow\+::\+Backend\+Options} \\*Options relevant to Backends during compilation }{\pageref{structglow_1_1_backend_options}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_backend_using_glow_i_r}{glow\+::\+Backend\+Using\+Glow\+IR} }{\pageref{classglow_1_1_backend_using_glow_i_r}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_base_factory}{glow\+::\+Base\+Factory$<$ Key, Base $>$} }{\pageref{classglow_1_1_base_factory}}{}
\item\contentsline{section}{\hyperlink{class_batch_add_node_importer}{Batch\+Add\+Node\+Importer} }{\pageref{class_batch_add_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batch_box_cox_node}{glow\+::\+Batch\+Box\+Cox\+Node} \\*Apply box-\/cox transform for each column for each column in NxD input tensor }{\pageref{classglow_1_1_batch_box_cox_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_add_inst}{glow\+::\+Batched\+Add\+Inst} }{\pageref{classglow_1_1_batched_add_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_add_node}{glow\+::\+Batched\+Add\+Node} \\*Adds the \textquotesingle{}Slice\textquotesingle{} operand to each one of the slices in the batch }{\pageref{classglow_1_1_batched_add_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_reduce_add_inst}{glow\+::\+Batched\+Reduce\+Add\+Inst} }{\pageref{classglow_1_1_batched_reduce_add_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_reduce_add_node}{glow\+::\+Batched\+Reduce\+Add\+Node} \\*Accumulates all of the layers in the batch and produce a tensor that has the same dimensions as the input tensor without the first dimension }{\pageref{classglow_1_1_batched_reduce_add_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_reduce_mean_node}{glow\+::\+Batched\+Reduce\+Mean\+Node} \\*Performs Average Mean operation on the Input given Axes }{\pageref{classglow_1_1_batched_reduce_mean_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_reduce_min_inst}{glow\+::\+Batched\+Reduce\+Min\+Inst} }{\pageref{classglow_1_1_batched_reduce_min_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batched_reduce_min_node}{glow\+::\+Batched\+Reduce\+Min\+Node} \\*Performs Reduce Min operation on the Input given Axes }{\pageref{classglow_1_1_batched_reduce_min_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batch_mat_mul_node}{glow\+::\+Batch\+Mat\+Mul\+Node} \\*Performs batch matrix multiplication between the L\+HS and R\+HS. The operands are a stack of two dimensional matrices. Example\+: (N, A, Z) x (N, Z, B) =$>$ (N, A, B) }{\pageref{classglow_1_1_batch_mat_mul_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batch_normalization_grad_node}{glow\+::\+Batch\+Normalization\+Grad\+Node} }{\pageref{classglow_1_1_batch_normalization_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batch_normalization_node}{glow\+::\+Batch\+Normalization\+Node} \\*Performs batch normalization on the Input tensor with the provided Scale, Bias, Mean, Var, Channel\+Idx, Epsilon, and Momentum. Similar to Caffe2 Spatial\+BN, and O\+N\+NX Batch\+Normalization operator }{\pageref{classglow_1_1_batch_normalization_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batch_one_hot_inst}{glow\+::\+Batch\+One\+Hot\+Inst} }{\pageref{classglow_1_1_batch_one_hot_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_batch_one_hot_node}{glow\+::\+Batch\+One\+Hot\+Node} \\*Expands each row of the Data to a row of zeros and ones, according to One Hot Encoding. i-\/th element of Result\textquotesingle{}s row is one iff Values\mbox{[}i\mbox{]} equals to the corresponding element of Data }{\pageref{classglow_1_1_batch_one_hot_node}}{}
\item\contentsline{section}{\hyperlink{class_batch_one_hot_node_importer}{Batch\+One\+Hot\+Node\+Importer} }{\pageref{class_batch_one_hot_node_importer}}{}
\item\contentsline{section}{\hyperlink{class_binary_eltwise_node_importer}{Binary\+Eltwise\+Node\+Importer$<$ Eltwise\+Node\+Type, eltwise\+Type $>$} }{\pageref{class_binary_eltwise_node_importer}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1yaml_1_1_block_scalar_traits_3_01glow_1_1_multi_line_str_01_4}{llvm\+::yaml\+::\+Block\+Scalar\+Traits$<$ glow\+::\+Multi\+Line\+Str $>$} }{\pageref{structllvm_1_1yaml_1_1_block_scalar_traits_3_01glow_1_1_multi_line_str_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_block_stream}{glow\+::\+Block\+Stream} }{\pageref{classglow_1_1_block_stream}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_bound_interpreter_function}{glow\+::\+Bound\+Interpreter\+Function} \\*An \hyperlink{classglow_1_1_interpreter_function}{Interpreter\+Function} bound to a specific invocation }{\pageref{classglow_1_1_bound_interpreter_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_bucketize_node}{glow\+::\+Bucketize\+Node} \\*Performs bucketization on the input given Boundaries }{\pageref{classglow_1_1_bucketize_node}}{}
\item\contentsline{section}{\hyperlink{class_builder}{Builder} }{\pageref{class_builder}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_bundle_saver}{glow\+::\+Bundle\+Saver} }{\pageref{classglow_1_1_bundle_saver}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_caffe2_model_loader}{glow\+::\+Caffe2\+Model\+Loader} \\*Loads \hyperlink{namespacecaffe2}{caffe2} models }{\pageref{classglow_1_1_caffe2_model_loader}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_channel_shuffle_node}{glow\+::\+Channel\+Shuffle\+Node} \\*Performs Channel shuffle }{\pageref{classglow_1_1_channel_shuffle_node}}{}
\item\contentsline{section}{\hyperlink{struct_channel_shuffle_params}{Channel\+Shuffle\+Params} \\*Parameters that are used to define Channel\+Shuffle operators }{\pageref{struct_channel_shuffle_params}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_channelwise_quantized_convolution_inst}{glow\+::\+Channelwise\+Quantized\+Convolution\+Inst} }{\pageref{classglow_1_1_channelwise_quantized_convolution_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_channelwise_quantized_convolution_node}{glow\+::\+Channelwise\+Quantized\+Convolution\+Node} \\*Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, and Group. Quantization parameters are provided by Scales and Offsets. If Groupwise is true then the quantization is per-\/group otherwise it is per-\/channel }{\pageref{classglow_1_1_channelwise_quantized_convolution_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_check_state}{glow\+::detail\+::\+Check\+State$<$ Do\+Checks $>$} }{\pageref{classglow_1_1detail_1_1_check_state}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_check_state_3_01false_01_4}{glow\+::detail\+::\+Check\+State$<$ false $>$} \\*Specialization of \hyperlink{classglow_1_1detail_1_1_check_state}{Check\+State} with checking disabled }{\pageref{classglow_1_1detail_1_1_check_state_3_01false_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_check_state_3_01true_01_4}{glow\+::detail\+::\+Check\+State$<$ true $>$} \\*Specialization of \hyperlink{classglow_1_1detail_1_1_check_state}{Check\+State} with checking enabled }{\pageref{classglow_1_1detail_1_1_check_state_3_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_child_mem_size_based_scheduler}{glow\+::\+Child\+Mem\+Size\+Based\+Scheduler} }{\pageref{classglow_1_1_child_mem_size_based_scheduler}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_clip_node}{glow\+::\+Clip\+Node} \\*Clip range of inputs to lie in \mbox{[}Min, Max\mbox{]} }{\pageref{classglow_1_1_clip_node}}{}
\item\contentsline{section}{\hyperlink{class_clip_node_importer}{Clip\+Node\+Importer} }{\pageref{class_clip_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cmp_e_q_node}{glow\+::\+Cmp\+E\+Q\+Node} \\*Performs an element-\/wise equal comparison on the L\+HS and R\+HS operands. Inputs must be integer }{\pageref{classglow_1_1_cmp_e_q_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cmp_l_t_e_node}{glow\+::\+Cmp\+L\+T\+E\+Node} \\*Performs Cmp\+L\+TE on the L\+HS and R\+HS operands. Generates a mask that\textquotesingle{}s consumed by the select instruction. The format of the result is target-\/ and type-\/specific }{\pageref{classglow_1_1_cmp_l_t_e_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cmp_l_t_node}{glow\+::\+Cmp\+L\+T\+Node} \\*Compares X and Y element wise sets Dest\mbox{[}i\mbox{]} true if L\+HS\mbox{[}i\mbox{]} $<$ R\+HS\mbox{[}i\mbox{]} otherwise false. Final result is a mask consumed by Select, O\+N\+NX Where, operator }{\pageref{classglow_1_1_cmp_l_t_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_common_operator_loader}{glow\+::\+Common\+Operator\+Loader$<$ Op\+Type, Attr\+Type $>$} }{\pageref{classglow_1_1_common_operator_loader}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_common_operator_writer}{glow\+::\+Common\+Operator\+Writer$<$ Traits $>$} }{\pageref{classglow_1_1_common_operator_writer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_compare_operator_equal}{glow\+::\+Compare\+Operator\+Equal$<$ Ty $>$} \\*Operator == }{\pageref{structglow_1_1_compare_operator_equal}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_compare_operator_greater_equal}{glow\+::\+Compare\+Operator\+Greater\+Equal$<$ Ty $>$} \\*Operator $>$= }{\pageref{structglow_1_1_compare_operator_greater_equal}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_compare_operator_greater_than}{glow\+::\+Compare\+Operator\+Greater\+Than$<$ Ty $>$} \\*Operator $>$ }{\pageref{structglow_1_1_compare_operator_greater_than}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_compare_operator_less_equal}{glow\+::\+Compare\+Operator\+Less\+Equal$<$ Ty $>$} \\*Operator $<$= }{\pageref{structglow_1_1_compare_operator_less_equal}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_compare_with_name}{glow\+::\+Compare\+With\+Name$<$ Ty $>$} \\*Interface that the comparison operator must implement }{\pageref{structglow_1_1_compare_with_name}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_compilation_context}{glow\+::\+Compilation\+Context} \\*Context for compilation }{\pageref{structglow_1_1_compilation_context}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_compiled_function}{glow\+::\+Compiled\+Function} \\*Interface for executing a compiled function }{\pageref{classglow_1_1_compiled_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_concat_node}{glow\+::\+Concat\+Node} }{\pageref{classglow_1_1_concat_node}}{}
\item\contentsline{section}{\hyperlink{class_concat_node_importer}{Concat\+Node\+Importer} }{\pageref{class_concat_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_constant}{glow\+::\+Constant} }{\pageref{classglow_1_1_constant}}{}
\item\contentsline{section}{\hyperlink{class_convert_node_importer}{Convert\+Node\+Importer$<$ Typed\+Node $>$} }{\pageref{class_convert_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convert_to_inst}{glow\+::\+Convert\+To\+Inst} }{\pageref{classglow_1_1_convert_to_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convert_to_node}{glow\+::\+Convert\+To\+Node} \\*Convert the input from its current type to the destination type. The input and output types must have the same shapes. Moreover the input and output types must not be quantized types. Quantized types should use the appropriate Quantize, Dequantize, and Rescale nodes }{\pageref{classglow_1_1_convert_to_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution3_d_grad_inst}{glow\+::\+Convolution3\+D\+Grad\+Inst} }{\pageref{classglow_1_1_convolution3_d_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution3_d_grad_node}{glow\+::\+Convolution3\+D\+Grad\+Node} }{\pageref{classglow_1_1_convolution3_d_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution3_d_inst}{glow\+::\+Convolution3\+D\+Inst} }{\pageref{classglow_1_1_convolution3_d_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution3_d_node}{glow\+::\+Convolution3\+D\+Node} \\*Performs 3D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, and Group }{\pageref{classglow_1_1_convolution3_d_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution_grad_inst}{glow\+::\+Convolution\+Grad\+Inst} }{\pageref{classglow_1_1_convolution_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution_grad_node}{glow\+::\+Convolution\+Grad\+Node} }{\pageref{classglow_1_1_convolution_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution_inst}{glow\+::\+Convolution\+Inst} }{\pageref{classglow_1_1_convolution_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_convolution_node}{glow\+::\+Convolution\+Node} \\*Performs 2D Convolution using a given Input, Filter, and Bias tensors, as well as provided Kernels, Strides, Pads, Group and Dilation. Supported Layouts are defined in the Convolution\+Layout enum\+: N\+H\+WC and N\+C\+HW. Supported Fused\+Activations are defined in the Fused\+Activation enum }{\pageref{classglow_1_1_convolution_node}}{}
\item\contentsline{section}{\hyperlink{class_convolution_node_importer}{Convolution\+Node\+Importer} }{\pageref{class_convolution_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_copy_inst}{glow\+::\+Copy\+Inst} }{\pageref{classglow_1_1_copy_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_backend}{glow\+::\+C\+P\+U\+Backend} }{\pageref{classglow_1_1_c_p_u_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_conv_d_k_k_c8_inst}{glow\+::\+C\+P\+U\+Conv\+D\+K\+K\+C8\+Inst} }{\pageref{classglow_1_1_c_p_u_conv_d_k_k_c8_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_conv_d_k_k_c8_node}{glow\+::\+C\+P\+U\+Conv\+D\+K\+K\+C8\+Node} \\*This is a cpu-\/specific convolution implementation where the filter is transposed to the shape \mbox{[}D/8, K, K, C, 8\mbox{]} }{\pageref{classglow_1_1_c_p_u_conv_d_k_k_c8_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_c_p_u_device_manager}{glow\+::runtime\+::\+C\+P\+U\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_c_p_u_device_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_function}{glow\+::\+C\+P\+U\+Function} \\*A Glow IR function compiled for the C\+PU using L\+L\+VM }{\pageref{classglow_1_1_c_p_u_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_l_l_v_m_i_r_gen}{glow\+::\+C\+P\+U\+L\+L\+V\+M\+I\+R\+Gen} }{\pageref{classglow_1_1_c_p_u_l_l_v_m_i_r_gen}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_max_splat_inst}{glow\+::\+C\+P\+U\+Max\+Splat\+Inst} }{\pageref{classglow_1_1_c_p_u_max_splat_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_c_p_u_max_splat_node}{glow\+::\+C\+P\+U\+Max\+Splat\+Node} \\*A Max node with one splat input; C\+PU specific }{\pageref{classglow_1_1_c_p_u_max_splat_node}}{}
\item\contentsline{section}{\hyperlink{class_c_rnn_l_m}{C\+Rnn\+LM} }{\pageref{class_c_rnn_l_m}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cross_entropy_loss_grad_inst}{glow\+::\+Cross\+Entropy\+Loss\+Grad\+Inst} }{\pageref{classglow_1_1_cross_entropy_loss_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cross_entropy_loss_grad_node}{glow\+::\+Cross\+Entropy\+Loss\+Grad\+Node} }{\pageref{classglow_1_1_cross_entropy_loss_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cross_entropy_loss_inst}{glow\+::\+Cross\+Entropy\+Loss\+Inst} }{\pageref{classglow_1_1_cross_entropy_loss_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_cross_entropy_loss_node}{glow\+::\+Cross\+Entropy\+Loss\+Node} \\*Computes the average cross entropy loss of the input }{\pageref{classglow_1_1_cross_entropy_loss_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_d_a_g}{glow\+::runtime\+::\+D\+AG} }{\pageref{structglow_1_1runtime_1_1_d_a_g}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_d_a_g_node}{glow\+::runtime\+::\+D\+A\+G\+Node} }{\pageref{structglow_1_1runtime_1_1_d_a_g_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_dealloc_activation_inst}{glow\+::\+Dealloc\+Activation\+Inst} }{\pageref{classglow_1_1_dealloc_activation_inst}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_debug_info}{glow\+::\+Debug\+Info} \\*A P\+OD struct that stores information related to debug info }{\pageref{structglow_1_1_debug_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_debug_print_inst}{glow\+::\+Debug\+Print\+Inst} }{\pageref{classglow_1_1_debug_print_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_dequantize_inst}{glow\+::\+Dequantize\+Inst} }{\pageref{classglow_1_1_dequantize_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_dequantize_node}{glow\+::\+Dequantize\+Node} \\*Convert quantized input tensor into the float representation. x = Scale $\ast$ (x\+\_\+q -\/ Offset) }{\pageref{classglow_1_1_dequantize_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_description_builder}{glow\+::\+Description\+Builder} \\*A helper class that builds a textual descriptor of a group of parameters }{\pageref{classglow_1_1_description_builder}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_device_bindings}{glow\+::\+Device\+Bindings} }{\pageref{classglow_1_1_device_bindings}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_device_config}{glow\+::runtime\+::\+Device\+Config} }{\pageref{structglow_1_1runtime_1_1_device_config}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_device_config_helper}{glow\+::\+Device\+Config\+Helper} \\*Data structure used to read the yaml file for Device Configs }{\pageref{structglow_1_1_device_config_helper}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_device_info}{glow\+::runtime\+::\+Device\+Info} }{\pageref{structglow_1_1runtime_1_1_device_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_device_manager}{glow\+::runtime\+::\+Device\+Manager} \\*Interface managing a specific instance of a device }{\pageref{classglow_1_1runtime_1_1_device_manager}}{}
\item\contentsline{section}{\hyperlink{struct_dictionary}{Dictionary} }{\pageref{struct_dictionary}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_div_grad_node}{glow\+::\+Div\+Grad\+Node} }{\pageref{classglow_1_1_div_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_div_node}{glow\+::\+Div\+Node} \\*Performs Div on the L\+HS and R\+HS operands }{\pageref{classglow_1_1_div_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_dummy_device_manager}{glow\+::runtime\+::\+Dummy\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_dummy_device_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_add_inst}{glow\+::\+Element\+Add\+Inst} }{\pageref{classglow_1_1_element_add_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_cmp_e_q_inst}{glow\+::\+Element\+Cmp\+E\+Q\+Inst} }{\pageref{classglow_1_1_element_cmp_e_q_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_cmp_l_t_e_inst}{glow\+::\+Element\+Cmp\+L\+T\+E\+Inst} }{\pageref{classglow_1_1_element_cmp_l_t_e_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_cmp_l_t_inst}{glow\+::\+Element\+Cmp\+L\+T\+Inst} }{\pageref{classglow_1_1_element_cmp_l_t_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_div_inst}{glow\+::\+Element\+Div\+Inst} }{\pageref{classglow_1_1_element_div_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_exp_inst}{glow\+::\+Element\+Exp\+Inst} }{\pageref{classglow_1_1_element_exp_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_is_na_n_inst}{glow\+::\+Element\+Is\+Na\+N\+Inst} }{\pageref{classglow_1_1_element_is_na_n_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_log_inst}{glow\+::\+Element\+Log\+Inst} }{\pageref{classglow_1_1_element_log_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_max_inst}{glow\+::\+Element\+Max\+Inst} }{\pageref{classglow_1_1_element_max_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_min_inst}{glow\+::\+Element\+Min\+Inst} }{\pageref{classglow_1_1_element_min_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_mul_inst}{glow\+::\+Element\+Mul\+Inst} }{\pageref{classglow_1_1_element_mul_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_pow_inst}{glow\+::\+Element\+Pow\+Inst} }{\pageref{classglow_1_1_element_pow_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_select_inst}{glow\+::\+Element\+Select\+Inst} }{\pageref{classglow_1_1_element_select_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_element_sub_inst}{glow\+::\+Element\+Sub\+Inst} }{\pageref{classglow_1_1_element_sub_inst}}{}
\item\contentsline{section}{\hyperlink{struct_emulator_only_tests}{Emulator\+Only\+Tests} }{\pageref{struct_emulator_only_tests}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_event}{glow\+::onnxifi\+::\+Event} }{\pageref{classglow_1_1onnxifi_1_1_event}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_trace_info_1_1_event}{glow\+::\+Trace\+Info\+::\+Event} }{\pageref{structglow_1_1_trace_info_1_1_event}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_execution_context}{glow\+::\+Execution\+Context} }{\pageref{classglow_1_1_execution_context}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_execution_engine}{glow\+::\+Execution\+Engine} }{\pageref{classglow_1_1_execution_engine}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_execution_state}{glow\+::runtime\+::\+Execution\+State} }{\pageref{classglow_1_1runtime_1_1_execution_state}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_executor}{glow\+::runtime\+::\+Executor} }{\pageref{classglow_1_1runtime_1_1_executor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_exp_node}{glow\+::\+Exp\+Node} \\*Performs element-\/wise exponential to the Input }{\pageref{classglow_1_1_exp_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_extract_tensor_inst}{glow\+::\+Extract\+Tensor\+Inst} }{\pageref{classglow_1_1_extract_tensor_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_factory_registry}{glow\+::\+Factory\+Registry$<$ Key, Base $>$} }{\pageref{classglow_1_1_factory_registry}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_file_adapter}{glow\+::\+File\+Adapter} }{\pageref{classglow_1_1_file_adapter}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1float16}{glow\+::float16} }{\pageref{classglow_1_1float16}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1yaml_1_1_mapping_traits_3_01glow_1_1_node_quantization_info_01_4_1_1_float_normalized}{llvm\+::yaml\+::\+Mapping\+Traits$<$ glow\+::\+Node\+Quantization\+Info $>$\+::\+Float\+Normalized} }{\pageref{structllvm_1_1yaml_1_1_mapping_traits_3_01glow_1_1_node_quantization_info_01_4_1_1_float_normalized}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1yaml_1_1_float_wrapper}{llvm\+::yaml\+::\+Float\+Wrapper} }{\pageref{structllvm_1_1yaml_1_1_float_wrapper}}{}
\item\contentsline{section}{\hyperlink{class_f_r_q_s_l_w_s_node_importer}{F\+R\+Q\+S\+L\+W\+S\+Node\+Importer} }{\pageref{class_f_r_q_s_l_w_s_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_fully_connected_grad_node}{glow\+::\+Fully\+Connected\+Grad\+Node} }{\pageref{classglow_1_1_fully_connected_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_fully_connected_node}{glow\+::\+Fully\+Connected\+Node} \\*Creates a Fully\+Connected node where the Input tensor and Weights tensor are multiplied, and then the Bias tensor is added to it, producing the Output }{\pageref{classglow_1_1_fully_connected_node}}{}
\item\contentsline{section}{\hyperlink{class_fully_connected_node_importer}{Fully\+Connected\+Node\+Importer} }{\pageref{class_fully_connected_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_function}{glow\+::\+Function} \\*Represents the compute graph }{\pageref{classglow_1_1_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_function_converter}{glow\+::\+Function\+Converter} }{\pageref{classglow_1_1_function_converter}}{}
\item\contentsline{section}{\hyperlink{class_function_dotty_printer}{Function\+Dotty\+Printer} }{\pageref{class_function_dotty_printer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_function_name_comparator}{glow\+::\+Function\+Name\+Comparator} }{\pageref{structglow_1_1_function_name_comparator}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_function_pass}{glow\+::\+Function\+Pass} }{\pageref{classglow_1_1_function_pass}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_function_pass_config}{glow\+::\+Function\+Pass\+Config} }{\pageref{classglow_1_1_function_pass_config}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_function_pass_manager}{glow\+::\+Function\+Pass\+Manager} }{\pageref{classglow_1_1_function_pass_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_function_pass_pipeline}{glow\+::\+Function\+Pass\+Pipeline} \\*Implementation of a pipeline for executing a series of Function\+Passes }{\pageref{classglow_1_1_function_pass_pipeline}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node}{glow\+::\+Fused\+Rowwise\+Quantized\+Sparse\+Lengths\+Sum\+Node} \\*Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). The input data is fused rowwise-\/quantized, where the Scales and Offsets are appended to the end of each row. Thus, Data must be a two-\/dimensional tensor }{\pageref{classglow_1_1_fused_rowwise_quantized_sparse_lengths_sum_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_inst}{glow\+::\+Fused\+Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Inst} }{\pageref{classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node}{glow\+::\+Fused\+Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Node} \\*Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices). The input data is fused rowwise-\/quantized, where the Scales and Offsets are appended to the end of each row. Thus, Data must be a two-\/dimensional tensor }{\pageref{classglow_1_1_fused_rowwise_quantized_sparse_lengths_weighted_sum_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_gather_inst}{glow\+::\+Gather\+Inst} }{\pageref{classglow_1_1_gather_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_gather_node}{glow\+::\+Gather\+Node} \\*Gathers entries of the outer-\/most dimension of Data indexed by Indices, and concatenates them. Output tensor will have dimensions\+: \{I\+\_\+0, I\+\_\+1, ... I\+\_\+n, D\+\_\+1, D\+\_\+2, ... D\+\_\+m\}, where D\+\_\+i and I\+\_\+j denote Data and Indices dimensions respectively. If batch\+Dims is not zero, the gather operator will treat the first batch\+Dims as the batch and will concat the result of the gather operation on each sample in the batch }{\pageref{classglow_1_1_gather_node}}{}
\item\contentsline{section}{\hyperlink{class_gather_node_importer}{Gather\+Node\+Importer} }{\pageref{class_gather_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_gather_ranges_inst}{glow\+::\+Gather\+Ranges\+Inst} }{\pageref{classglow_1_1_gather_ranges_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_gather_ranges_node}{glow\+::\+Gather\+Ranges\+Node} \\*Gathers entries of Data into Output in groups specified by the elements of Ranges. Each element of Ranges contains a list of pairs of indices of the form (index, length) which specify which entries of data to gather. The ordering of elements in Ranges and of pairs within an element is preserved in Output. Lengths contains the lengths of the ranges gathered by each list of pairs in Ranges }{\pageref{classglow_1_1_gather_ranges_node}}{}
\item\contentsline{section}{\hyperlink{class_gather_ranges_node_importer}{Gather\+Ranges\+Node\+Importer} }{\pageref{class_gather_ranges_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_glow_error}{glow\+::detail\+::\+Glow\+Error} }{\pageref{classglow_1_1detail_1_1_glow_error}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_glow_error_empty}{glow\+::detail\+::\+Glow\+Error\+Empty} }{\pageref{classglow_1_1detail_1_1_glow_error_empty}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_glow_error_success}{glow\+::detail\+::\+Glow\+Error\+Success} }{\pageref{classglow_1_1detail_1_1_glow_error_success}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_glow_error_value}{glow\+::detail\+::\+Glow\+Error\+Value} }{\pageref{classglow_1_1detail_1_1_glow_error_value}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_glow_expected}{glow\+::detail\+::\+Glow\+Expected$<$ T $>$} }{\pageref{classglow_1_1detail_1_1_glow_expected}}{}
\item\contentsline{section}{\hyperlink{classllvm_1_1orc_1_1_glow_j_i_t}{llvm\+::orc\+::\+Glow\+J\+IT} }{\pageref{classllvm_1_1orc_1_1_glow_j_i_t}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_glow_onnxifi_manager}{glow\+::onnxifi\+::\+Glow\+Onnxifi\+Manager} }{\pageref{classglow_1_1onnxifi_1_1_glow_onnxifi_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_graph}{glow\+::onnxifi\+::\+Graph} }{\pageref{classglow_1_1onnxifi_1_1_graph}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_graph_grad_mapper}{glow\+::\+Graph\+Grad\+Mapper} }{\pageref{classglow_1_1_graph_grad_mapper}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_graph_mem_info}{glow\+::\+Graph\+Mem\+Info} \\*The memory usage of a subgraph (i.\+e. a list of nodes of a function) }{\pageref{structglow_1_1_graph_mem_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_graph_post_order_visitor}{glow\+::\+Graph\+Post\+Order\+Visitor} \\*A helper class for ordering Graph nodes in a post-\/order order }{\pageref{classglow_1_1_graph_post_order_visitor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_graph_pre_order_visitor}{glow\+::\+Graph\+Pre\+Order\+Visitor} \\*A helper class for ordering Graph nodes in a pre-\/order order }{\pageref{classglow_1_1_graph_pre_order_visitor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_habana_backend}{glow\+::\+Habana\+Backend} }{\pageref{classglow_1_1_habana_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_habana_bindings}{glow\+::\+Habana\+Bindings} }{\pageref{classglow_1_1_habana_bindings}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_habana_device_manager}{glow\+::runtime\+::\+Habana\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_habana_device_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_habana_function}{glow\+::\+Habana\+Function} }{\pageref{classglow_1_1_habana_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_habana_i_o_buffer}{glow\+::\+Habana\+I\+O\+Buffer} }{\pageref{classglow_1_1_habana_i_o_buffer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_habana_i_o_buffer_pool}{glow\+::\+Habana\+I\+O\+Buffer\+Pool} }{\pageref{classglow_1_1_habana_i_o_buffer_pool}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_habana_wait_handle}{glow\+::\+Habana\+Wait\+Handle} }{\pageref{classglow_1_1_habana_wait_handle}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_handle}{glow\+::\+Handle$<$ Elem\+Ty $>$} }{\pageref{classglow_1_1_handle}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_handle_iterator}{glow\+::\+Handle\+Iterator$<$ Elem\+Ty, Is\+Const $>$} }{\pageref{classglow_1_1_handle_iterator}}{}
\item\contentsline{section}{\hyperlink{structstd_1_1hash_3_01glow_1_1_node_value_01_4}{std\+::hash$<$ glow\+::\+Node\+Value $>$} }{\pageref{structstd_1_1hash_3_01glow_1_1_node_value_01_4}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_hooked_function}{glow\+::\+Hooked\+Function} }{\pageref{structglow_1_1_hooked_function}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_host_config}{glow\+::runtime\+::\+Host\+Config} }{\pageref{structglow_1_1runtime_1_1_host_config}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_host_manager}{glow\+::runtime\+::\+Host\+Manager} }{\pageref{classglow_1_1runtime_1_1_host_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_host_manager_backend}{glow\+::onnxifi\+::\+Host\+Manager\+Backend} }{\pageref{classglow_1_1onnxifi_1_1_host_manager_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_host_manager_graph}{glow\+::onnxifi\+::\+Host\+Manager\+Graph} }{\pageref{classglow_1_1onnxifi_1_1_host_manager_graph}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1ilist__traits_3_01glow_1_1_node_01_4}{llvm\+::ilist\+\_\+traits$<$ glow\+::\+Node $>$} }{\pageref{structllvm_1_1ilist__traits_3_01glow_1_1_node_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_inference_pool_env}{glow\+::runtime\+::\+Inference\+Pool\+Env} }{\pageref{classglow_1_1runtime_1_1_inference_pool_env}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_inference_thread_env}{glow\+::runtime\+::\+Inference\+Thread\+Env} }{\pageref{classglow_1_1runtime_1_1_inference_thread_env}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_inflight_barrier}{glow\+::runtime\+::\+Inflight\+Barrier} }{\pageref{classglow_1_1runtime_1_1_inflight_barrier}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1onnxifi_1_1_inline_graph}{glow\+::onnxifi\+::\+Inline\+Graph} }{\pageref{classglow_1_1onnxifi_1_1_inline_graph}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_i_n_n_p_i_node_importer}{glow\+::\+I\+N\+N\+P\+I\+Node\+Importer} \\*Interface class for all node specific importers }{\pageref{classglow_1_1_i_n_n_p_i_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_insert_tensor_inst}{glow\+::\+Insert\+Tensor\+Inst} }{\pageref{classglow_1_1_insert_tensor_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_insert_tensor_node}{glow\+::\+Insert\+Tensor\+Node} \\*Insert tensor Small into tensor Big given indices Start. Small is inserted Count times along Axis. The resulting \hyperlink{classglow_1_1_tensor}{Tensor} will have the same type as the input Big tensor }{\pageref{classglow_1_1_insert_tensor_node}}{}
\item\contentsline{section}{\hyperlink{class_instr_builder}{Instr\+Builder} }{\pageref{class_instr_builder}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_instruction}{glow\+::\+Instruction} \\*This represents an instruction in our IR }{\pageref{classglow_1_1_instruction}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_instruction_numbering}{glow\+::\+Instruction\+Numbering} \\*A helper class used for instructions numbering }{\pageref{classglow_1_1_instruction_numbering}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_instruction_traits}{glow\+::\+Instruction\+Traits} }{\pageref{structglow_1_1_instruction_traits}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_interpreter}{glow\+::\+Interpreter} }{\pageref{classglow_1_1_interpreter}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_interpreter_device_manager}{glow\+::runtime\+::\+Interpreter\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_interpreter_device_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_interpreter_function}{glow\+::\+Interpreter\+Function} \\*\hyperlink{classglow_1_1_function}{Function} \char`\"{}compiled\char`\"{} for execution by the interpreter }{\pageref{classglow_1_1_interpreter_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_int_lookup_table_inst}{glow\+::\+Int\+Lookup\+Table\+Inst} }{\pageref{classglow_1_1_int_lookup_table_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_int_lookup_table_node}{glow\+::\+Int\+Lookup\+Table\+Node} \\*Simple mapping between quantized numbers.\+This can be used as quantized sigmoid or tanh functions }{\pageref{classglow_1_1_int_lookup_table_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_i_r_builder}{glow\+::\+I\+R\+Builder} \\*The \hyperlink{classglow_1_1_i_r_builder}{I\+R\+Builder} constructs the IR in the function }{\pageref{classglow_1_1_i_r_builder}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_i_r_function}{glow\+::\+I\+R\+Function} \\*A function that represents the compilation unit }{\pageref{classglow_1_1_i_r_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_i_r_gen_visitor}{glow\+::\+I\+R\+Gen\+Visitor} }{\pageref{classglow_1_1_i_r_gen_visitor}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1detail_1_1_is_error}{glow\+::detail\+::\+Is\+Error$<$ T $>$} \\*Is true\+\_\+type only if applied to Error or a descendant }{\pageref{structglow_1_1detail_1_1_is_error}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1detail_1_1_is_expected}{glow\+::detail\+::\+Is\+Expected$<$ typename $>$} \\*Is true\+\_\+type only if applied to Expected }{\pageref{structglow_1_1detail_1_1_is_expected}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1detail_1_1_is_expected_3_01_glow_expected_3_01_t_01_4_01_4}{glow\+::detail\+::\+Is\+Expected$<$ Glow\+Expected$<$ T $>$ $>$} }{\pageref{structglow_1_1detail_1_1_is_expected_3_01_glow_expected_3_01_t_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_is_na_n_node}{glow\+::\+Is\+Na\+N\+Node} \\*Determines whether each element of the Input is NaN and generates a mask that can be consumed by a Select node }{\pageref{classglow_1_1_is_na_n_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1tagged__list__details_1_1_iterator}{glow\+::tagged\+\_\+list\+\_\+details\+::\+Iterator$<$ T, Is\+Reverse, Is\+Const $>$} \\*\hyperlink{classglow_1_1tagged__list__details_1_1_iterator}{Iterator} for a Tagged\+List$<$\+T$>$ }{\pageref{classglow_1_1tagged__list__details_1_1_iterator}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1tagged__list__details_1_1_iterator_traits}{glow\+::tagged\+\_\+list\+\_\+details\+::\+Iterator\+Traits$<$ T, Is\+Const $>$} \\*Traits for sorting out iterator types }{\pageref{structglow_1_1tagged__list__details_1_1_iterator_traits}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1tagged__list__details_1_1_iterator_traits_3_01_t_00_01false_01_4}{glow\+::tagged\+\_\+list\+\_\+details\+::\+Iterator\+Traits$<$ T, false $>$} }{\pageref{structglow_1_1tagged__list__details_1_1_iterator_traits_3_01_t_00_01false_01_4}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1tagged__list__details_1_1_iterator_traits_3_01_t_00_01true_01_4}{glow\+::tagged\+\_\+list\+\_\+details\+::\+Iterator\+Traits$<$ T, true $>$} }{\pageref{structglow_1_1tagged__list__details_1_1_iterator_traits_3_01_t_00_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_kernel_launch}{glow\+::\+Kernel\+Launch} \\*A helper struct with information about kernels launches }{\pageref{structglow_1_1_kernel_launch}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_kinded}{glow\+::\+Kinded} \\*Subclasses of \hyperlink{classglow_1_1_value}{Value} have an enum that describe their kind }{\pageref{classglow_1_1_kinded}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_lengths_range_fill_inst}{glow\+::\+Lengths\+Range\+Fill\+Inst} }{\pageref{classglow_1_1_lengths_range_fill_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_lengths_range_fill_node}{glow\+::\+Lengths\+Range\+Fill\+Node} \\*Converts an input Lengths 1D vector into a range sequence }{\pageref{classglow_1_1_lengths_range_fill_node}}{}
\item\contentsline{section}{\hyperlink{class_lengths_range_fill_node_importer}{Lengths\+Range\+Fill\+Node\+Importer} }{\pageref{class_lengths_range_fill_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_lengths_sum_inst}{glow\+::\+Lengths\+Sum\+Inst} }{\pageref{classglow_1_1_lengths_sum_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_lengths_sum_node}{glow\+::\+Lengths\+Sum\+Node} \\*Sums slices of the outermost dimension of Data in groups defined by Lengths. The first Lengths\mbox{[}0\mbox{]} slices are added together and stored in Result\mbox{[}0\mbox{]}, the subsequent Lengths\mbox{[}1\mbox{]} slices are added together and stored in Result\mbox{[}1\mbox{]}, etc }{\pageref{classglow_1_1_lengths_sum_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_lengths_to_ranges_inst}{glow\+::\+Lengths\+To\+Ranges\+Inst} }{\pageref{classglow_1_1_lengths_to_ranges_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_lengths_to_ranges_node}{glow\+::\+Lengths\+To\+Ranges\+Node} \\*Given a vector of segment lengths, calculates offsets of each segment and packs them next to the lengths. For the input vector of length N the output is a Nx2 matrix with (offset, lengths) packaged for each segment }{\pageref{classglow_1_1_lengths_to_ranges_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1tagged__list__details_1_1_list_impl}{glow\+::tagged\+\_\+list\+\_\+details\+::\+List\+Impl} \\*Template-\/free implementation of the {\ttfamily \hyperlink{classglow_1_1_tagged_list}{Tagged\+List}} }{\pageref{classglow_1_1tagged__list__details_1_1_list_impl}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_l_l_v_m_backend}{glow\+::\+L\+L\+V\+M\+Backend} }{\pageref{classglow_1_1_l_l_v_m_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_l_l_v_m_compiled_function}{glow\+::\+L\+L\+V\+M\+Compiled\+Function} \\*A Glow IR function compiled using L\+L\+VM }{\pageref{classglow_1_1_l_l_v_m_compiled_function}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_l_l_v_m_i_r_gen}{glow\+::\+L\+L\+V\+M\+I\+R\+Gen} }{\pageref{classglow_1_1_l_l_v_m_i_r_gen}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_loader}{glow\+::\+Loader} }{\pageref{classglow_1_1_loader}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_load_weight_result}{glow\+::\+Load\+Weight\+Result} }{\pageref{structglow_1_1_load_weight_result}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_local_response_normalization_grad_inst}{glow\+::\+Local\+Response\+Normalization\+Grad\+Inst} }{\pageref{classglow_1_1_local_response_normalization_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_local_response_normalization_grad_node}{glow\+::\+Local\+Response\+Normalization\+Grad\+Node} }{\pageref{classglow_1_1_local_response_normalization_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_local_response_normalization_inst}{glow\+::\+Local\+Response\+Normalization\+Inst} }{\pageref{classglow_1_1_local_response_normalization_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_local_response_normalization_node}{glow\+::\+Local\+Response\+Normalization\+Node} \\*Performs local response normalization on the Input tensor with the provided Scale, Bias, Mean, Var, Channel\+Idx, Epsilon, and Momentum. Similar to Caffe2 and O\+N\+NX L\+RN }{\pageref{classglow_1_1_local_response_normalization_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_log_context}{glow\+::\+Log\+Context} \\*A class for logging all compilation related activities }{\pageref{classglow_1_1_log_context}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_log_create}{glow\+::\+Log\+Create} }{\pageref{structglow_1_1_log_create}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_log_delete}{glow\+::\+Log\+Delete} }{\pageref{structglow_1_1_log_delete}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_log_event}{glow\+::\+Log\+Event} }{\pageref{structglow_1_1_log_event}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_log_input_change}{glow\+::\+Log\+Input\+Change} }{\pageref{structglow_1_1_log_input_change}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_log_node}{glow\+::\+Log\+Node} \\*Performs element-\/wise natural log to the Input }{\pageref{classglow_1_1_log_node}}{}
\item\contentsline{section}{\hyperlink{class_log_node_importer}{Log\+Node\+Importer} }{\pageref{class_log_node_importer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_log_scope}{glow\+::\+Log\+Scope} }{\pageref{structglow_1_1_log_scope}}{}
\item\contentsline{section}{\hyperlink{class_l_r_n_node_importer}{L\+R\+N\+Node\+Importer} }{\pageref{class_l_r_n_node_importer}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1yaml_1_1_mapping_traits_3_01glow_1_1_device_config_helper_01_4}{llvm\+::yaml\+::\+Mapping\+Traits$<$ glow\+::\+Device\+Config\+Helper $>$} }{\pageref{structllvm_1_1yaml_1_1_mapping_traits_3_01glow_1_1_device_config_helper_01_4}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1yaml_1_1_mapping_traits_3_01glow_1_1_node_quantization_info_01_4}{llvm\+::yaml\+::\+Mapping\+Traits$<$ glow\+::\+Node\+Quantization\+Info $>$} \\*Mapping for Node\+Quantization\+Info yaml serializer }{\pageref{structllvm_1_1yaml_1_1_mapping_traits_3_01glow_1_1_node_quantization_info_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_mat_mul_inst}{glow\+::\+Mat\+Mul\+Inst} }{\pageref{classglow_1_1_mat_mul_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_mat_mul_node}{glow\+::\+Mat\+Mul\+Node} \\*Performs matrix multiplication between the L\+HS and R\+H\+S.\+Example\+: (A, Z) x (Z, B) =$>$ (A, B) }{\pageref{classglow_1_1_mat_mul_node}}{}
\item\contentsline{section}{\hyperlink{class_mat_mul_node_importer}{Mat\+Mul\+Node\+Importer$<$ Mat\+Mul\+Node\+Type $>$} }{\pageref{class_mat_mul_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_max_node}{glow\+::\+Max\+Node} \\*Performs Max on the L\+HS and R\+HS operands }{\pageref{classglow_1_1_max_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_max_pool_grad_node}{glow\+::\+Max\+Pool\+Grad\+Node} }{\pageref{classglow_1_1_max_pool_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_max_pool_inst}{glow\+::\+Max\+Pool\+Inst} }{\pageref{classglow_1_1_max_pool_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_max_pool_node}{glow\+::\+Max\+Pool\+Node} \\*Performs a Max Pool with Argmax operation on the Input given provided Kernels, Strides, and Pads. Argmax is a flattened index corresponding to respective max element. Supported layouts are defined in the Convolution\+Layout enum\+: N\+H\+WC and N\+C\+HW }{\pageref{classglow_1_1_max_pool_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_max_pool_with_argmax_grad_inst}{glow\+::\+Max\+Pool\+With\+Argmax\+Grad\+Inst} }{\pageref{classglow_1_1_max_pool_with_argmax_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_max_pool_with_argmax_inst}{glow\+::\+Max\+Pool\+With\+Argmax\+Inst} }{\pageref{classglow_1_1_max_pool_with_argmax_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_mean_var_normalization_node}{glow\+::\+Mean\+Var\+Normalization\+Node} \\*Calculates new normalized mean and variance based on the input mean, variance, and input }{\pageref{classglow_1_1_mean_var_normalization_node}}{}
\item\contentsline{section}{\hyperlink{struct_member_type_info}{Member\+Type\+Info} }{\pageref{struct_member_type_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_memory_allocator}{glow\+::\+Memory\+Allocator} }{\pageref{classglow_1_1_memory_allocator}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_min_node}{glow\+::\+Min\+Node} \\*Performs Min on the L\+HS and R\+HS operands }{\pageref{classglow_1_1_min_node}}{}
\item\contentsline{section}{\hyperlink{struct_model}{Model} }{\pageref{struct_model}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_module}{glow\+::\+Module} }{\pageref{classglow_1_1_module}}{}
\item\contentsline{section}{\hyperlink{class_module_dotty_printer}{Module\+Dotty\+Printer} }{\pageref{class_module_dotty_printer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_modulo_inst}{glow\+::\+Modulo\+Inst} }{\pageref{classglow_1_1_modulo_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_modulo_node}{glow\+::\+Modulo\+Node} \\*Performs elementwise modulo operation on the input where each element in the output is the corresponding element in the input data modulo Divisor }{\pageref{classglow_1_1_modulo_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_mul_grad_node}{glow\+::\+Mul\+Grad\+Node} }{\pageref{classglow_1_1_mul_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_mul_node}{glow\+::\+Mul\+Node} \\*Performs Mul on the L\+HS and R\+HS operands }{\pageref{classglow_1_1_mul_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_multi_line_str}{glow\+::\+Multi\+Line\+Str} \\*Data structure for multi string format used in yaml file }{\pageref{structglow_1_1_multi_line_str}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_named}{glow\+::\+Named} \\*This add the capability to name subclasses }{\pageref{classglow_1_1_named}}{}
\item\contentsline{section}{\hyperlink{structneuron}{neuron} }{\pageref{structneuron}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_n_n_p_i_backend}{glow\+::\+N\+N\+P\+I\+Backend} \\*This is the Intel Neural-\/\+Network Processor for Inference (N\+N\+PI) backend }{\pageref{classglow_1_1_n_n_p_i_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_n_n_p_i_compiled_function}{glow\+::\+N\+N\+P\+I\+Compiled\+Function} \\*\hyperlink{classglow_1_1_function}{Function} \char`\"{}compiled\char`\"{} for execution by the N\+N\+PI backend }{\pageref{classglow_1_1_n_n_p_i_compiled_function}}{}
\item\contentsline{section}{\hyperlink{class_n_n_p_i_custom_d_s_p_node_importer}{N\+N\+P\+I\+Custom\+D\+S\+P\+Node\+Importer} }{\pageref{class_n_n_p_i_custom_d_s_p_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_n_n_p_i_device_manager}{glow\+::runtime\+::\+N\+N\+P\+I\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_n_n_p_i_device_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_n_n_p_i_env_variables}{glow\+::\+N\+N\+P\+I\+Env\+Variables} }{\pageref{classglow_1_1_n_n_p_i_env_variables}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_n_n_p_i_importer}{glow\+::\+N\+N\+P\+I\+Importer} \\*This class imports Glow IR to the N\+N\+PI backend }{\pageref{classglow_1_1_n_n_p_i_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_n_n_p_i_message_logger}{glow\+::\+N\+N\+P\+I\+Message\+Logger} \\*N\+N\+PI logging stream controller }{\pageref{classglow_1_1_n_n_p_i_message_logger}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node}{glow\+::\+Node} \\*Represents a node in the compute graph }{\pageref{classglow_1_1_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1tagged__list__details_1_1_node_base}{glow\+::tagged\+\_\+list\+\_\+details\+::\+Node\+Base} }{\pageref{classglow_1_1tagged__list__details_1_1_node_base}}{}
\item\contentsline{section}{\hyperlink{class_node_builder}{Node\+Builder} }{\pageref{class_node_builder}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_node_handle}{glow\+::\+Node\+Handle} }{\pageref{structglow_1_1_node_handle}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_info}{glow\+::\+Node\+Info} }{\pageref{classglow_1_1_node_info}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_node_name_and_kind}{glow\+::\+Node\+Name\+And\+Kind} }{\pageref{structglow_1_1_node_name_and_kind}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_node_quantization_info}{glow\+::\+Node\+Quantization\+Info} \\*\hyperlink{classglow_1_1_tensor}{Tensor} quantization parameters for a given node }{\pageref{structglow_1_1_node_quantization_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_to_function_map}{glow\+::\+Node\+To\+Function\+Map} }{\pageref{classglow_1_1_node_to_function_map}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_node_use}{glow\+::\+Node\+Use} \\*A \textquotesingle{}\hyperlink{structglow_1_1_use}{Use}\textquotesingle{} is a use-\/list representation of a \hyperlink{classglow_1_1_node}{Node} operand }{\pageref{structglow_1_1_node_use}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_node_value}{glow\+::\+Node\+Value} }{\pageref{structglow_1_1_node_value}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_value_array_ref}{glow\+::\+Node\+Value\+Array\+Ref} }{\pageref{classglow_1_1_node_value_array_ref}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_value_iterator_impl}{glow\+::\+Node\+Value\+Iterator\+Impl$<$ is\+\_\+const\+\_\+iter $>$} }{\pageref{classglow_1_1_node_value_iterator_impl}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_visitor}{glow\+::\+Node\+Visitor$<$ Impl\+Class, Ret\+Ty, Arg\+Tys $>$} }{\pageref{classglow_1_1_node_visitor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_visitor_base}{glow\+::\+Node\+Visitor\+Base$<$ Impl\+Class $>$} }{\pageref{classglow_1_1_node_visitor_base}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_node_walker}{glow\+::\+Node\+Walker} \\*A walker that recursively visits a node and its children }{\pageref{classglow_1_1_node_walker}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_o_c_l_backend}{glow\+::\+O\+C\+L\+Backend} \\*This is the Open\+CL backend }{\pageref{classglow_1_1_o_c_l_backend}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_one_err_only}{glow\+::\+One\+Err\+Only} }{\pageref{classglow_1_1_one_err_only}}{}
\item\contentsline{section}{\hyperlink{struct_o_n_n_x___t_r_a_i_t_s}{O\+N\+N\+X\+\_\+\+T\+R\+A\+I\+TS} \\*O\+N\+NX traits for protobuf types }{\pageref{struct_o_n_n_x___t_r_a_i_t_s}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_o_n_n_x_i_f_i_model_loader}{glow\+::\+O\+N\+N\+X\+I\+F\+I\+Model\+Loader} }{\pageref{classglow_1_1_o_n_n_x_i_f_i_model_loader}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_o_n_n_x_model_loader}{glow\+::\+O\+N\+N\+X\+Model\+Loader} \\*Loads O\+N\+NX models }{\pageref{classglow_1_1_o_n_n_x_model_loader}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_o_n_n_x_model_writer}{glow\+::\+O\+N\+N\+X\+Model\+Writer} \\*Writes O\+N\+NX models }{\pageref{classglow_1_1_o_n_n_x_model_writer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1detail_1_1_opaque}{glow\+::detail\+::\+Opaque$<$ T $>$} }{\pageref{classglow_1_1detail_1_1_opaque}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_open_c_l_buffer}{glow\+::runtime\+::\+Open\+C\+L\+Buffer} }{\pageref{classglow_1_1runtime_1_1_open_c_l_buffer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_open_c_l_command_queue}{glow\+::runtime\+::\+Open\+C\+L\+Command\+Queue} }{\pageref{structglow_1_1runtime_1_1_open_c_l_command_queue}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_open_c_l_command_queue_pool}{glow\+::runtime\+::\+Open\+C\+L\+Command\+Queue\+Pool} }{\pageref{classglow_1_1runtime_1_1_open_c_l_command_queue_pool}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_open_c_l_device_bindings}{glow\+::runtime\+::\+Open\+C\+L\+Device\+Bindings} }{\pageref{structglow_1_1runtime_1_1_open_c_l_device_bindings}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_open_c_l_device_manager}{glow\+::runtime\+::\+Open\+C\+L\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_open_c_l_device_manager}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_open_c_l_function}{glow\+::\+Open\+C\+L\+Function} \\*A Glow IR function compiled for Open\+CL }{\pageref{classglow_1_1_open_c_l_function}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_optimization_options}{glow\+::\+Optimization\+Options} \\*Options relevant to optimizations during compilation }{\pageref{structglow_1_1_optimization_options}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_padding_t_l_b_r}{glow\+::\+Padding\+T\+L\+BR} }{\pageref{structglow_1_1_padding_t_l_b_r}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_padding_t_l_n_b_r_f}{glow\+::\+Padding\+T\+L\+N\+B\+RF} }{\pageref{structglow_1_1_padding_t_l_n_b_r_f}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_pad_node}{glow\+::\+Pad\+Node} \\*Performs padding of a given input tensor. The Padding information must be specified for each dimension of the tensor in Pads (start and end padding). In case the padding is negative, it means that the tensor must be cropped. Mode defines how extra padding elements are created. Supported modes are defined in the Padding\+Mode enum\+: C\+O\+N\+S\+T\+A\+NT, R\+E\+F\+L\+E\+CT, E\+D\+GE. \hyperlink{classglow_1_1_value}{Value} is only used with the C\+O\+N\+S\+T\+A\+NT mode }{\pageref{classglow_1_1_pad_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_partition_config}{glow\+::runtime\+::\+Partition\+Config} \\*This is struct for user defined partition }{\pageref{structglow_1_1runtime_1_1_partition_config}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_partitioner}{glow\+::\+Partitioner} }{\pageref{classglow_1_1_partitioner}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_partitioner_base}{glow\+::\+Partitioner\+Base} }{\pageref{classglow_1_1_partitioner_base}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_placeholder}{glow\+::\+Placeholder} }{\pageref{classglow_1_1_placeholder}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_placeholder_bindings}{glow\+::\+Placeholder\+Bindings} }{\pageref{classglow_1_1_placeholder_bindings}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_placeholder_input_output_info}{glow\+::\+Placeholder\+Input\+Output\+Info} \\*Contains information for placeholder during allocation }{\pageref{structglow_1_1_placeholder_input_output_info}}{}
\item\contentsline{section}{\hyperlink{class_pool_node_importer}{Pool\+Node\+Importer$<$ Pool\+Node\+Type, pool\+Type $>$} }{\pageref{class_pool_node_importer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_post_order_visitor}{glow\+::\+Post\+Order\+Visitor} \\*A helper class for ordering the nodes in a post-\/order order }{\pageref{structglow_1_1_post_order_visitor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_pow_node}{glow\+::\+Pow\+Node} \\*Performs elementwise pow(\+L\+H\+S, R\+H\+S) }{\pageref{classglow_1_1_pow_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_precision_configuration}{glow\+::\+Precision\+Configuration} \\*Configuration for different precision modes }{\pageref{structglow_1_1_precision_configuration}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_p_relu_node}{glow\+::\+P\+Relu\+Node} \\*Applies P\+Re\+LU, slope $\ast$ min(0, x) + max(0, x), to each element in the Input tensor }{\pageref{classglow_1_1_p_relu_node}}{}
\item\contentsline{section}{\hyperlink{class_p_relu_node_importer}{P\+Relu\+Node\+Importer} }{\pageref{class_p_relu_node_importer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_pre_order_visitor}{glow\+::\+Pre\+Order\+Visitor} \\*A helper class for ordering the nodes in a pre-\/order order }{\pageref{structglow_1_1_pre_order_visitor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_protobuf_loader}{glow\+::\+Protobuf\+Loader} \\*Loads model\+: graph and weights }{\pageref{classglow_1_1_protobuf_loader}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_protobuf_writer}{glow\+::\+Protobuf\+Writer} \\*Writes model\+: graph and weights }{\pageref{classglow_1_1_protobuf_writer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_provisioner}{glow\+::runtime\+::\+Provisioner} }{\pageref{classglow_1_1runtime_1_1_provisioner}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_pseudo_r_n_g}{glow\+::\+Pseudo\+R\+NG} }{\pageref{classglow_1_1_pseudo_r_n_g}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1quantization_1_1_quantization_configuration}{glow\+::quantization\+::\+Quantization\+Configuration} \\*Configuration for Quantization, passed into quantize\+Function() }{\pageref{structglow_1_1quantization_1_1_quantization_configuration}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_quantization_profile_inst}{glow\+::\+Quantization\+Profile\+Inst} }{\pageref{classglow_1_1_quantization_profile_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_quantization_profile_node}{glow\+::\+Quantization\+Profile\+Node} \\*Generate profile (distribution of values) of the Input tensor. This data is used for quantization of the tensor later on. Profiled\+Node\+Name contains the name of the node which is profiled by the Quantization\+Profile node. Profiled\+Node\+Name is helpful as lowering might transform the original graph. Profiled\+Output\+Number contains the position of the node\textquotesingle{}s output which gets profiled }{\pageref{classglow_1_1_quantization_profile_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_quantization_transform32_to8}{glow\+::\+Quantization\+Transform32\+To8} }{\pageref{structglow_1_1_quantization_transform32_to8}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_quantize_inst}{glow\+::\+Quantize\+Inst} }{\pageref{classglow_1_1_quantize_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_quantize_node}{glow\+::\+Quantize\+Node} \\*Quantize floating point tensor. This operation converts floating point numbers to integers based on the given Scale and Offset. Scale and Offset are deduced from the type of the output.\+x\+\_\+q = clip(round(x/\+Scale) + Offset, -\/128, 127) }{\pageref{classglow_1_1_quantize_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_queue_backed_device_manager}{glow\+::runtime\+::\+Queue\+Backed\+Device\+Manager} }{\pageref{classglow_1_1runtime_1_1_queue_backed_device_manager}}{}
\item\contentsline{section}{\hyperlink{class_reduce_add_node_importer}{Reduce\+Add\+Node\+Importer} }{\pageref{class_reduce_add_node_importer}}{}
\item\contentsline{section}{\hyperlink{class_reduce_mult_axes_node_importer}{Reduce\+Mult\+Axes\+Node\+Importer$<$ Reduce\+Node\+Type, reduce\+Type $>$} }{\pageref{class_reduce_mult_axes_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_register_factory}{glow\+::\+Register\+Factory$<$ Key, Factory, Base $>$} }{\pageref{classglow_1_1_register_factory}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_regression_grad_node}{glow\+::\+Regression\+Grad\+Node} }{\pageref{classglow_1_1_regression_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_regression_node}{glow\+::\+Regression\+Node} \\*Takes an Input tensor and creates a regression output layer }{\pageref{classglow_1_1_regression_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_relu_grad_node}{glow\+::\+Relu\+Grad\+Node} }{\pageref{classglow_1_1_relu_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_relu_inst}{glow\+::\+Relu\+Inst} }{\pageref{classglow_1_1_relu_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_relu_node}{glow\+::\+Relu\+Node} \\*Applies Re\+LU, max(0, x), to each element in the Input tensor }{\pageref{classglow_1_1_relu_node}}{}
\item\contentsline{section}{\hyperlink{class_relu_node_importer}{Relu\+Node\+Importer} }{\pageref{class_relu_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_replace_na_n_node}{glow\+::\+Replace\+Na\+N\+Node} \\*Replaces Na\+Ns found in Input with \hyperlink{classglow_1_1_value}{Value} }{\pageref{classglow_1_1_replace_na_n_node}}{}
\item\contentsline{section}{\hyperlink{class_replace_na_n_node_importer}{Replace\+Na\+N\+Node\+Importer} }{\pageref{class_replace_na_n_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_rescale_quantized_inst}{glow\+::\+Rescale\+Quantized\+Inst} }{\pageref{classglow_1_1_rescale_quantized_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_rescale_quantized_node}{glow\+::\+Rescale\+Quantized\+Node} \\*Rescale the input quantized tensor to a new Scale and Offset. The new Scale and Offset are specified by the output type passed to the constructor }{\pageref{classglow_1_1_rescale_quantized_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_reshape_node}{glow\+::\+Reshape\+Node} \\*Reshape the Input tensor to shape Dims }{\pageref{classglow_1_1_reshape_node}}{}
\item\contentsline{section}{\hyperlink{class_reshape_node_importer}{Reshape\+Node\+Importer} }{\pageref{class_reshape_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_resize_nearest_inst}{glow\+::\+Resize\+Nearest\+Inst} }{\pageref{classglow_1_1_resize_nearest_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_resize_nearest_node}{glow\+::\+Resize\+Nearest\+Node} \\*Given Input tensor of \mbox{[}N,H,W,C\mbox{]}, where N is the batch, C is the channel or depth, H is the height and W is the width, Generates an Output tensor with resized spatial dimensions using nearest neighbor interpolation. The Output tensor is of shape \mbox{[}N, floor(\+H$\ast$\+Height\+Scale), floor(\+W$\ast$\+Width\+Scale), C\mbox{]} }{\pageref{classglow_1_1_resize_nearest_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_rowwise_quantized_fully_connected_inst}{glow\+::\+Rowwise\+Quantized\+Fully\+Connected\+Inst} }{\pageref{classglow_1_1_rowwise_quantized_fully_connected_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_rowwise_quantized_fully_connected_node}{glow\+::\+Rowwise\+Quantized\+Fully\+Connected\+Node} \\*Creates a Rowwise\+Quantized\+Fully\+Connected node where the Input matrix and the transpose of Weights matrix are multiplied, and then the Bias vector is broadcast-\/added to the result. Input, Bias and Result are regularly quantized, while Weights use row-\/wisequantization }{\pageref{classglow_1_1_rowwise_quantized_fully_connected_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_inst}{glow\+::\+Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Inst} }{\pageref{classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node}{glow\+::\+Rowwise\+Quantized\+Sparse\+Lengths\+Weighted\+Sum\+Node} \\*Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices). The input data is rowwise-\/quantized, where the Scales and Offsets are 1D tensors of length equal to the first dim of Data }{\pageref{classglow_1_1_rowwise_quantized_sparse_lengths_weighted_sum_node}}{}
\item\contentsline{section}{\hyperlink{class_r_q_f_c_node_importer}{R\+Q\+F\+C\+Node\+Importer} }{\pageref{class_r_q_f_c_node_importer}}{}
\item\contentsline{section}{\hyperlink{class_r_q_s_l_w_s_node_importer}{R\+Q\+S\+L\+W\+S\+Node\+Importer} }{\pageref{class_r_q_s_l_w_s_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_runtime_bundle}{glow\+::runtime\+::\+Runtime\+Bundle} }{\pageref{classglow_1_1runtime_1_1_runtime_bundle}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1runtime_1_1_runtime_symbol_info}{glow\+::runtime\+::\+Runtime\+Symbol\+Info} \\*Contains information for initialization and handling of symbol at runtime }{\pageref{structglow_1_1runtime_1_1_runtime_symbol_info}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_save_node}{glow\+::\+Save\+Node} \\*Specifies a node whose Input will be copied to Output.\+This node prevents graph optimizations from eliminating this node and all of its ancestor nodes. Generally intended to save the final result of a network }{\pageref{classglow_1_1_save_node}}{}
\item\contentsline{section}{\hyperlink{class_save_node_importer}{Save\+Node\+Importer} }{\pageref{class_save_node_importer}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1yaml_1_1_scalar_traits_3_01_float_wrapper_01_4}{llvm\+::yaml\+::\+Scalar\+Traits$<$ Float\+Wrapper $>$} }{\pageref{structllvm_1_1yaml_1_1_scalar_traits_3_01_float_wrapper_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_scatter_data_inst}{glow\+::\+Scatter\+Data\+Inst} }{\pageref{classglow_1_1_scatter_data_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_scatter_data_node}{glow\+::\+Scatter\+Data\+Node} \\*Copies each slice from Slices into Data at the corresponding index in Indices. For example, given input Data \{\{1,2\},\{3,4\},\{5,6\}\}, Slices \{\{-\/3,-\/4\}\}, and Indices \{\{1\}\}, the result is \{\{1,2\},\{-\/3,-\/4\},\{5,6\}\}. It also supports multi-\/dimensional indices. For example, given input Data \{\{1,2\},\{3,4\},\{5,6\}\}, Slices \{-\/3,-\/4\}, and Indices \{\{1,0\},\{1,1\}\} also produces \{\{1,2\},\{-\/3,-\/4\},\{5,6\}\}. If Cumulative is true, the node adds values from Slices to Data instead of copying. For example, given input Data \{\{1,2\},\{3,4\},\{5,6\}\}, Slices \{\{-\/3,-\/4\}\}, and Indices \{1\}, the result is \{\{1,2\},\{0,0\},\{5,6\}\}. If an index is specified several times, its updates will be added several times as well }{\pageref{classglow_1_1_scatter_data_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_scheduler}{glow\+::\+Scheduler} }{\pageref{classglow_1_1_scheduler}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_scoped_log_block}{glow\+::\+Scoped\+Log\+Block} \\*Helper class which traces the start and end of a compilation log scope }{\pageref{classglow_1_1_scoped_log_block}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_scoped_trace_block}{glow\+::\+Scoped\+Trace\+Block} }{\pageref{classglow_1_1_scoped_trace_block}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_segment}{glow\+::\+Segment} \\*A P\+OD struct that represents a single half-\/open allocation \mbox{[}start .. end) }{\pageref{classglow_1_1_segment}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_select_node}{glow\+::\+Select\+Node} \\*Selects between values on the L\+HS or R\+HS, depending on the value of Cond. Cond is generated by the compare instruction, and is target-\/ and type-\/specific }{\pageref{classglow_1_1_select_node}}{}
\item\contentsline{section}{\hyperlink{class_select_node_importer}{Select\+Node\+Importer} }{\pageref{class_select_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_s_g_d_node}{glow\+::\+S\+G\+D\+Node} \\*Stochastic Gradient Descent node used during training. Produces the updated weight that needs to be used instead of Weight for the next iteration }{\pageref{classglow_1_1_s_g_d_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_shape_h_w}{glow\+::\+Shape\+HW} }{\pageref{structglow_1_1_shape_h_w}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_shape_h_w_d}{glow\+::\+Shape\+H\+WD} }{\pageref{structglow_1_1_shape_h_w_d}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_shape_n_c_h_w}{glow\+::\+Shape\+N\+C\+HW} }{\pageref{structglow_1_1_shape_n_c_h_w}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_shape_n_h_w_c}{glow\+::\+Shape\+N\+H\+WC} }{\pageref{structglow_1_1_shape_n_h_w_c}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_shape_n_h_w_d_c}{glow\+::\+Shape\+N\+H\+W\+DC} }{\pageref{structglow_1_1_shape_n_h_w_d_c}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sigmoid_cross_entropy_with_logits_node}{glow\+::\+Sigmoid\+Cross\+Entropy\+With\+Logits\+Node} \\*Computes the sigmoid cross entropy between two inputs }{\pageref{classglow_1_1_sigmoid_cross_entropy_with_logits_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sigmoid_grad_node}{glow\+::\+Sigmoid\+Grad\+Node} }{\pageref{classglow_1_1_sigmoid_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sigmoid_inst}{glow\+::\+Sigmoid\+Inst} }{\pageref{classglow_1_1_sigmoid_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sigmoid_node}{glow\+::\+Sigmoid\+Node} \\*Applies Sigmoid, 1 / (1 + exp(-\/x)), to each element in the Input tensor }{\pageref{classglow_1_1_sigmoid_node}}{}
\item\contentsline{section}{\hyperlink{class_sigmoid_node_importer}{Sigmoid\+Node\+Importer} }{\pageref{class_sigmoid_node_importer}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1simplify__type_3_01const_01glow_1_1_node_handle_01_4}{llvm\+::simplify\+\_\+type$<$ const glow\+::\+Node\+Handle $>$} \\*Allow casting const Node\+Handle into Node$\ast$ }{\pageref{structllvm_1_1simplify__type_3_01const_01glow_1_1_node_handle_01_4}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1simplify__type_3_01const_01glow_1_1_node_value_01_4}{llvm\+::simplify\+\_\+type$<$ const glow\+::\+Node\+Value $>$} \\*Allow casting Node\+Value into Node$\ast$ }{\pageref{structllvm_1_1simplify__type_3_01const_01glow_1_1_node_value_01_4}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1simplify__type_3_01glow_1_1_node_handle_01_4}{llvm\+::simplify\+\_\+type$<$ glow\+::\+Node\+Handle $>$} \\*Allow casting Node\+Handle into Node$\ast$ }{\pageref{structllvm_1_1simplify__type_3_01glow_1_1_node_handle_01_4}}{}
\item\contentsline{section}{\hyperlink{structllvm_1_1simplify__type_3_01glow_1_1_node_value_01_4}{llvm\+::simplify\+\_\+type$<$ glow\+::\+Node\+Value $>$} \\*Allow casting Node\+Value into Node$\ast$ }{\pageref{structllvm_1_1simplify__type_3_01glow_1_1_node_value_01_4}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_slice_node}{glow\+::\+Slice\+Node} \\*Produces a slice of the Input tensor. The Start vector defines the starting indices for each dimension from which the slice should be taken. The end index for each dimension is determined from the input type\textquotesingle{}s shape }{\pageref{classglow_1_1_slice_node}}{}
\item\contentsline{section}{\hyperlink{class_slice_node_importer}{Slice\+Node\+Importer} }{\pageref{class_slice_node_importer}}{}
\item\contentsline{section}{\hyperlink{class_s_l_w_s_node_importer}{S\+L\+W\+S\+Node\+Importer} }{\pageref{class_s_l_w_s_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_soft_max_grad_inst}{glow\+::\+Soft\+Max\+Grad\+Inst} }{\pageref{classglow_1_1_soft_max_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_soft_max_grad_node}{glow\+::\+Soft\+Max\+Grad\+Node} }{\pageref{classglow_1_1_soft_max_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_soft_max_inst}{glow\+::\+Soft\+Max\+Inst} }{\pageref{classglow_1_1_soft_max_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_soft_max_node}{glow\+::\+Soft\+Max\+Node} \\*Performs Soft\+Max normalization on the Input tensor }{\pageref{classglow_1_1_soft_max_node}}{}
\item\contentsline{section}{\hyperlink{class_soft_max_node_importer}{Soft\+Max\+Node\+Importer} }{\pageref{class_soft_max_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_space_to_depth_inst}{glow\+::\+Space\+To\+Depth\+Inst} }{\pageref{classglow_1_1_space_to_depth_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_space_to_depth_node}{glow\+::\+Space\+To\+Depth\+Node} \\*Given Input tensor of \mbox{[}N,H,W,C\mbox{]}, where N is the batch axis, C is the channel or depth, H is the height and W is the width. This produces Output tensor of \mbox{[}N, H/\+Block\+Size, W/\+Block\+Size, C $\ast$ Block\+Size $\ast$ Block\+Size\mbox{]} }{\pageref{classglow_1_1_space_to_depth_node}}{}
\item\contentsline{section}{\hyperlink{class_space_to_depth_node_importer}{Space\+To\+Depth\+Node\+Importer} }{\pageref{class_space_to_depth_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_sum_inst}{glow\+::\+Sparse\+Lengths\+Sum\+Inst} }{\pageref{classglow_1_1_sparse_lengths_sum_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_sum_node}{glow\+::\+Sparse\+Lengths\+Sum\+Node} \\*Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices) }{\pageref{classglow_1_1_sparse_lengths_sum_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_weighted_sum_grad_inst}{glow\+::\+Sparse\+Lengths\+Weighted\+Sum\+Grad\+Inst} }{\pageref{classglow_1_1_sparse_lengths_weighted_sum_grad_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_weighted_sum_grad_node}{glow\+::\+Sparse\+Lengths\+Weighted\+Sum\+Grad\+Node} }{\pageref{classglow_1_1_sparse_lengths_weighted_sum_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_weighted_sum_inst}{glow\+::\+Sparse\+Lengths\+Weighted\+Sum\+Inst} }{\pageref{classglow_1_1_sparse_lengths_weighted_sum_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_weighted_sum_node}{glow\+::\+Sparse\+Lengths\+Weighted\+Sum\+Node} \\*Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Lengths) entries\+: first Lengths\mbox{[}0\mbox{]} slices are aggregated to Result\mbox{[}0\mbox{]}, next Lengths\mbox{[}1\mbox{]} slices are aggregated to Result\mbox{[}1\mbox{]}, etc. I.\+e. sum(\+Lengths) must be equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices) }{\pageref{classglow_1_1_sparse_lengths_weighted_sum_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_weighted_sum_offsets_inst}{glow\+::\+Sparse\+Lengths\+Weighted\+Sum\+Offsets\+Inst} }{\pageref{classglow_1_1_sparse_lengths_weighted_sum_offsets_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_lengths_weighted_sum_offsets_node}{glow\+::\+Sparse\+Lengths\+Weighted\+Sum\+Offsets\+Node} \\*Gathers slices of the outer-\/most dimension of Data indexed by Indices vector, and then accumulates them into len(\+Offsets) entries\+: first slice between Offsets\mbox{[}0\mbox{]} and Offsets\mbox{[}1\mbox{]} (or total length if there\textquotesingle{}s only one elem in Offsets) are aggregated to Result\mbox{[}0\mbox{]}, etc. I.\+e. largest offset must be less than or equal to len(\+Indices). Before doing aggregation, each individual slice is scaled by its weight\+: Result\mbox{[}0\mbox{]} = Weights\mbox{[}0\mbox{]} $\ast$ Slice(0) + Weights\mbox{[}1\mbox{]} $\ast$ Slice(1) + ... It implies that len(\+Weights) == len(\+Indices) }{\pageref{classglow_1_1_sparse_lengths_weighted_sum_offsets_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_to_dense_inst}{glow\+::\+Sparse\+To\+Dense\+Inst} }{\pageref{classglow_1_1_sparse_to_dense_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_to_dense_mask_inst}{glow\+::\+Sparse\+To\+Dense\+Mask\+Inst} }{\pageref{classglow_1_1_sparse_to_dense_mask_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_to_dense_mask_node}{glow\+::\+Sparse\+To\+Dense\+Mask\+Node} \\*Converts the sparse representation specified by the pair (Indices, Values) into a dense one, where compacted tensor only contains I\+Ds from given Mask. Indices cannot contain duplicate values. Lengths is used to distinguish elements from different examples of one batch. That is, first Lengths\mbox{[}0\mbox{]} index-\/value pairs belong to batch\textquotesingle{}s example 0, next Lengths\mbox{[}1\mbox{]} pairs belong to example 1, and so on }{\pageref{classglow_1_1_sparse_to_dense_mask_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sparse_to_dense_node}{glow\+::\+Sparse\+To\+Dense\+Node} \\*Converts the sparse representation specified by the pair (Indices, Values) into a dense one. This dense representation contains each value from Values at the corresponding index specified in Indices. Unspecified indices are filled with zeroes. Indices may contain duplicate values and in this case, all of the corresponding values in Values are added together }{\pageref{classglow_1_1_sparse_to_dense_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_splat_inst}{glow\+::\+Splat\+Inst} }{\pageref{classglow_1_1_splat_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_splat_node}{glow\+::\+Splat\+Node} \\*Generate a tensor of a specific type filled with \textquotesingle{}\hyperlink{classglow_1_1_value}{Value}\textquotesingle{}.Splat always keep floating point value internally but canquantize it based on the output type }{\pageref{classglow_1_1_splat_node}}{}
\item\contentsline{section}{\hyperlink{class_splat_node_importer}{Splat\+Node\+Importer} }{\pageref{class_splat_node_importer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_tensor_pool_1_1_stats}{glow\+::\+Tensor\+Pool\+::\+Stats} \\*Statistics relating to the usage of the pool }{\pageref{structglow_1_1_tensor_pool_1_1_stats}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_stats_exporter}{glow\+::\+Stats\+Exporter} }{\pageref{classglow_1_1_stats_exporter}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_stats_exporter_registry}{glow\+::\+Stats\+Exporter\+Registry} \\*Registry of Stats\+Exporters }{\pageref{classglow_1_1_stats_exporter_registry}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_storage}{glow\+::\+Storage} }{\pageref{classglow_1_1_storage}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_str_check}{glow\+::\+Str\+Check} }{\pageref{classglow_1_1_str_check}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sub_grad_node}{glow\+::\+Sub\+Grad\+Node} }{\pageref{classglow_1_1_sub_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_sub_node}{glow\+::\+Sub\+Node} \\*Performs Sub on the L\+HS and R\+HS operands }{\pageref{classglow_1_1_sub_node}}{}
\item\contentsline{section}{\hyperlink{structsynapse}{synapse} }{\pageref{structsynapse}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tagged_list}{glow\+::\+Tagged\+List$<$ T, Traits $>$} }{\pageref{classglow_1_1_tagged_list}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tagged_list_node}{glow\+::\+Tagged\+List\+Node$<$ T $>$} }{\pageref{classglow_1_1_tagged_list_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_tagged_list_traits}{glow\+::\+Tagged\+List\+Traits$<$ T $>$} }{\pageref{structglow_1_1_tagged_list_traits}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tanh_grad_node}{glow\+::\+Tanh\+Grad\+Node} }{\pageref{classglow_1_1_tanh_grad_node}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tanh_inst}{glow\+::\+Tanh\+Inst} }{\pageref{classglow_1_1_tanh_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tanh_node}{glow\+::\+Tanh\+Node} \\*Applies hyperbolic tangent to each element in the Input tensor }{\pageref{classglow_1_1_tanh_node}}{}
\item\contentsline{section}{\hyperlink{class_tanh_node_importer}{Tanh\+Node\+Importer} }{\pageref{class_tanh_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tensor}{glow\+::\+Tensor} \\*A class that represents a contiguous n-\/dimensional array (a tensor) }{\pageref{classglow_1_1_tensor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tensor_pool}{glow\+::\+Tensor\+Pool} }{\pageref{classglow_1_1_tensor_pool}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_tensor_quantization_params}{glow\+::\+Tensor\+Quantization\+Params} }{\pageref{structglow_1_1_tensor_quantization_params}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tensor_view_inst}{glow\+::\+Tensor\+View\+Inst} }{\pageref{classglow_1_1_tensor_view_inst}}{}
\item\contentsline{section}{\hyperlink{class_tester}{Tester} }{\pageref{class_tester}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_thread_executor}{glow\+::\+Thread\+Executor} \\*An executor that runs Tasks on a single thread }{\pageref{classglow_1_1_thread_executor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_thread_pool}{glow\+::\+Thread\+Pool} \\*Thread pool for asynchronous execution of generic functions }{\pageref{classglow_1_1_thread_pool}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1runtime_1_1_thread_pool_executor}{glow\+::runtime\+::\+Thread\+Pool\+Executor} }{\pageref{classglow_1_1runtime_1_1_thread_pool_executor}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_tile_node}{glow\+::\+Tile\+Node} \\*Tile an Input tensor Count times along Axis }{\pageref{classglow_1_1_tile_node}}{}
\item\contentsline{section}{\hyperlink{class_tile_node_importer}{Tile\+Node\+Importer} }{\pageref{class_tile_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_top_k_inst}{glow\+::\+Top\+K\+Inst} }{\pageref{classglow_1_1_top_k_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_top_k_node}{glow\+::\+Top\+K\+Node} \\*Finds the top K maximal elements for each vector in the tensor. Vectors are defined as the last dimension in the tensor. The input shape \{D\+\_\+0, D\+\_\+1, ... D\+\_\+n\} results in the outputs \{D\+\_\+0, D\+\_\+1, ... D\+\_\+n-\/1, K\}, sorted in non-\/decreasing order }{\pageref{classglow_1_1_top_k_node}}{}
\item\contentsline{section}{\hyperlink{class_topk_node_importer}{Topk\+Node\+Importer} }{\pageref{class_topk_node_importer}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_topological_sort_based_scheduler}{glow\+::\+Topological\+Sort\+Based\+Scheduler} }{\pageref{classglow_1_1_topological_sort_based_scheduler}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_trace_context}{glow\+::\+Trace\+Context} }{\pageref{classglow_1_1_trace_context}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_trace_event}{glow\+::\+Trace\+Event} }{\pageref{structglow_1_1_trace_event}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_trace_event_inst}{glow\+::\+Trace\+Event\+Inst} }{\pageref{classglow_1_1_trace_event_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_trace_event_node}{glow\+::\+Trace\+Event\+Node} \\*Inserts a \hyperlink{structglow_1_1_trace_event}{Trace\+Event} for profiling }{\pageref{classglow_1_1_trace_event_node}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_trace_info}{glow\+::\+Trace\+Info} }{\pageref{structglow_1_1_trace_info}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_training_config}{glow\+::\+Training\+Config} }{\pageref{structglow_1_1_training_config}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_transpose_inst}{glow\+::\+Transpose\+Inst} }{\pageref{classglow_1_1_transpose_inst}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_transpose_node}{glow\+::\+Transpose\+Node} \\*Transpose the Input tensor based on the vector Shuffle, which assigns a new axis for each dimension in Input }{\pageref{classglow_1_1_transpose_node}}{}
\item\contentsline{section}{\hyperlink{class_transpose_node_importer}{Transpose\+Node\+Importer} }{\pageref{class_transpose_node_importer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_type}{glow\+::\+Type} \\*A class that represents a type of a tensor }{\pageref{structglow_1_1_type}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_type_a_to_type_b_function_converter}{glow\+::\+Type\+A\+To\+Type\+B\+Function\+Converter} }{\pageref{classglow_1_1_type_a_to_type_b_function_converter}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_typed}{glow\+::\+Typed} \\*Subclasses of this class have a type associated with them }{\pageref{classglow_1_1_typed}}{}
\item\contentsline{section}{\hyperlink{class_unary_eltwise_node_importer}{Unary\+Eltwise\+Node\+Importer$<$ Eltwise\+Node\+Type, eltwise\+Type $>$} }{\pageref{class_unary_eltwise_node_importer}}{}
\item\contentsline{section}{\hyperlink{structglow_1_1_use}{glow\+::\+Use} }{\pageref{structglow_1_1_use}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_use_def}{glow\+::\+Use\+Def$<$ User\+Ty, Use $>$} \\*A \hyperlink{classglow_1_1_use_def}{Use\+Def} is something that can be an operand for an instruction }{\pageref{classglow_1_1_use_def}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_value}{glow\+::\+Value} }{\pageref{classglow_1_1_value}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_value_uses}{glow\+::\+Value\+Uses} }{\pageref{classglow_1_1_value_uses}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_value_uses_1_1_value_uses_iterator}{glow\+::\+Value\+Uses\+::\+Value\+Uses\+Iterator$<$ is\+\_\+const\+\_\+iter $>$} \\*The actual iterator implementation }{\pageref{classglow_1_1_value_uses_1_1_value_uses_iterator}}{}
\item\contentsline{section}{\hyperlink{structvocab__word}{vocab\+\_\+word} }{\pageref{structvocab__word}}{}
\item\contentsline{section}{\hyperlink{struct_vocabulary}{Vocabulary} }{\pageref{struct_vocabulary}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_weight_var}{glow\+::\+Weight\+Var} }{\pageref{classglow_1_1_weight_var}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_zip_reader}{glow\+::\+Zip\+Reader} \\*Zip reader }{\pageref{classglow_1_1_zip_reader}}{}
\item\contentsline{section}{\hyperlink{classglow_1_1_zip_writer}{glow\+::\+Zip\+Writer} \\*Zip Writer }{\pageref{classglow_1_1_zip_writer}}{}
\end{DoxyCompactList}
